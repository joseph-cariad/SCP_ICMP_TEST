/**
 * \file
 *
 * \brief AUTOSAR Dcm
 *
 * This file contains the implementation of the AUTOSAR
 * module Dcm.
 *
 * \version 5.0.9
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2021 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */

#ifndef DCM_DSP_SVCH_READDATABYPERIODICIDENTIFIER_H
#define DCM_DSP_SVCH_READDATABYPERIODICIDENTIFIER_H

/* !LINKSTO Dcm.Dsn.File.RDBPI.PublicApi,1 */
/* This file contains the public API of the implementation of the Diagnostic
 * Service ReadDataByPeriodicIdentifier. */

/*==================[inclusions]=================================================================*/

#include <Std_Types.h>         /* AUTOSAR standard types */
#include <Dcm_Int.h>
#include <Dcm_Hsm.h>

#include <Dcm_Dsp_DidServices.h>

#if (DCM_DSP_USE_SERVICE_0X2A == STD_ON)

/*==================[macros]=====================================================================*/

#if (defined DCM_PDID_TRANSRING_REMOVE_FIRST)
  #error "DCM_PDID_TRANSRING_REMOVE_FIRST is already defined"
#endif
#define DCM_PDID_TRANSRING_REMOVE_FIRST 0U

#if (defined DCM_PDID_TRANSRING_REMOVE_ALL)
  #error "DCM_PDID_TRANSRING_REMOVE_ALL is already defined"
#endif
#define DCM_PDID_TRANSRING_REMOVE_ALL   1U

/*==================[type definitions]===========================================================*/

/** \brief Structure describing a periodic DID **/
typedef struct
{
  /** \brief The periodic data identifier */
  VAR(uint16, TYPEDEF) PDID;

  /** \brief Timer of the periodic DID */
  VAR(uint16, TYPEDEF) PeriodicTimer;

  /** \brief RxPduId of this periodic client */
  VAR(PduIdType, TYPEDEF) RxPduId;

  /** \brief Transmission mode of the periodic DID */
  VAR(uint8, TYPEDEF) TransmissionMode;

  /** \brief Next periodic DID to be processed in order of configuration */
  VAR(uint8, TYPEDEF) IndexOfNextPeriodicDID;
}
Dcm_PeriodicDIDType;

/** \brief Structure describing a periodic DID sampling buffer **/
typedef struct
{
  /** \brief Number of occupied bytes in this buffer */
  VAR(uint16, TYPEDEF) Occupied;

  /** \brief Pointer to the next sample buffer in the transmission ring to be sent */
  VAR(uint16, TYPEDEF) SendNext;

#if ((DCM_HAS_PERIODIC_RESPONSE_TYPE2 == STD_ON) && (DCM_NUM_PERIODIC_TRANSMISSIONS > 0U))
  /** \brief TxConnection ID which is used for the transmission of a sample */
  Dcm_BufferUserType TxConnectionId;
#endif /* ((DCM_HAS_PERIODIC_RESPONSE_TYPE2 == STD_ON) && (DCM_NUM_PERIODIC_TRANSMISSIONS > 0U)) */

  /** \brief Sampling buffer that holds the data generated by one periodic DID */
  VAR(uint8, TYPEDEF) SamplingBuffer[DCM_PERIODIC_DID_SAMPLING_BUFFER_SIZE];

  /** \brief PDID entry in scheduler table that generated this sample */
  VAR(uint8, TYPEDEF) IndexInSchedulerTable;
}
Dcm_SamplingBufferType;

/** \brief Structure holding the elements for periodic DID processing */
typedef struct
{
  /** \brief Beginning of the periodic samples in the transmission ring */
  VAR(uint16, TYPEDEF) HeadTransmissionRing;

  /** \brief Place where new periodic samples can be added to the transmission ring */
  VAR(uint16, TYPEDEF) TailTransmissionRing;

  /** \brief Number of periodic samples in the transmission ring */
  VAR(uint16, TYPEDEF) NumberOfTransmittableSamples;

#if ( (DCM_HAS_PERIODIC_RESPONSE_TYPE2 == STD_ON) && \
      (DCM_NUM_PERIODIC_TRANSMISSIONS > 0U) )
  /** \brief Number of periodic transmissions sent via UUDT that need to be confirmed */
  VAR(uint16, TYPEDEF) SamplesSentUUDT;
#endif /* ( (DCM_HAS_PERIODIC_RESPONSE_TYPE2 == STD_ON) && \
            (DCM_NUM_PERIODIC_TRANSMISSIONS > 0U) ) */

  /** \brief Scheduler table for the transmission of periodic DIDs */
  VAR(Dcm_PeriodicDIDType, TYPEDEF) SchedulerTable[DCM_MAX_PERIODIC_DID_SCHEDULER];

  /** \brief Start processing the list of periodic DIDs at this index */
  VAR(uint8, TYPEDEF) NextPeriodicDIDList;

  /** \brief Beginning of the list of periodic DIDs in order of configuration */
  VAR(uint8, TYPEDEF) HeadPeriodicDIDList;

  /** \brief End of the list of periodic DIDs in order of configuration */
  VAR(uint8, TYPEDEF) TailPeriodicDIDList;

  /** \brief Number of periodic DIDs scheduled */
  VAR(uint8, TYPEDEF) NumberOfScheduledPDIDs;

  /** \brief Transmission ring used to manage the periodic DID samples transmissions */
  VAR(Dcm_SamplingBufferType, TYPEDEF) TransmissionRing[DCM_PERIODIC_DID_TRANSMISSION_RING_ENTRIES];

  /** \brief Flag indicating the need to recheck the conditions of the periodic DIDs after
   *         a security level or diagnostic session change */
  VAR(boolean, TYPEDEF) ForceReValidateConditions;

#if ( (DCM_HAS_PERIODIC_RESPONSE_TYPE2 == STD_ON) && \
      (DCM_NUM_PERIODIC_TRANSMISSIONS > 0U) )
  /** \brief Array holding the next periodic connection for each main connection */
  VAR(Dcm_PeriodicConnectionIndexType, TYPEDEF) OffsetToNextPeriodicConnection[DCM_NUM_RX_PDU_ID];

  /** \brief The RxPduId identifying the current periodic UUDT client */
  VAR(PduIdType, TYPEDEF) CurrentClientRxPduId;

  /** \brief Keeps track of how many periodic TxPduIds from the current periodic client
   *         have been used */
  VAR(uint8, TYPEDEF) CurrentClientConnectionsUsed;
#endif /* ( (DCM_HAS_PERIODIC_RESPONSE_TYPE2 == STD_ON) && \
            (DCM_NUM_PERIODIC_TRANSMISSIONS > 0U) ) */
}
Dcm_PeriodicDIDContextType;

/*==================[external function declarations]=============================================*/
#define DCM_START_SEC_CODE
#include <Dcm_MemMap.h>

/** \brief The generic service handler for UDS service 0x2A
 **
 ** \param[in]    OpStatus Operation state of the function.
 ** \param[inout] pMsgContext Message related information for one diagnsotic protocol identifier.
 **
 ** \retval DCM_E_DONE         Operation completed
 ** \retval DCM_E_PENDING      Operation did not complete, it must be called again
 ** \retval DCM_E_FORCE_RCRRP  The DCM shall send an "response pending" immediately
 ** \retval DCM_E_PROCESS_PAGE One page is ready to be given to the PduR
 **
 ** \Reentrancy{Non-reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(Std_ReturnType, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_SvcH(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_MsgContextType, AUTOMATIC, DCM_VAR) pMsgContext);

/** \brief The function that processes periodic DIDs of type 1
 **
 ** \param[in]    InstIdx   HSM instance index
 **
 ** \retval nothing
 **
 ** \note This function should only be called if there is some processing ongoing
 **
 ** \Reentrancy{Non-reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_ProcessPDID(
  uint8 InstIdx);

#if ( (DCM_HAS_PERIODIC_RESPONSE_TYPE2 == STD_ON) && \
      (DCM_NUM_PERIODIC_TRANSMISSIONS > 0U) )
/** \brief Function that prepares the sending of periodic DIDs of type 2 (UUDT)
 **
 ** \param[in]    InstIdx   HSM instance index
 **
 ** \retval nothing
 **
 ** \note This function should only be called if there is some processing ongoing
 **
 ** \Reentrancy{Non-reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_UUDTSetup(
  uint8 InstIdx);

/** \brief Function that sends the periodic DIDs of type 2 (UUDT)
 **
 ** \param[in]    InstIdx   HSM instance index
 **
 ** \retval nothing
 **
 ** \Reentrancy{Non-reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_UUDTSendNextPDID(
  uint8 InstIdx);

/** \brief Confirm one periodic transmission and check if there are more confirmations pending
 **
 ** \retval TRUE    No more pending confirmations
 ** \retval FALSE   Not all confirmations have yet been received
 **
 ** \Reentrancy{Non-reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(boolean, DCM_CODE)
  Dcm_Dsp_ReadDataByPeriodicIdentifier_ConfirmAndCheckPendingConfirmations(
  void);

/** \brief Remove samples generated by a given PDID from the transmission ring
 **        when the sample has been comfirmed as transmitted
 **
 ** \param[in] TxConnectionId  ConntectionId of the connection on which the sample was transmitted
 **
 ** \retval None
 **/
extern FUNC(void, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_RemoveUUDTSampleOnConfirmation(
  Dcm_BufferUserType TxConnectionId);

#endif /* ( (DCM_HAS_PERIODIC_RESPONSE_TYPE2 == STD_ON) && \
            (DCM_NUM_PERIODIC_TRANSMISSIONS > 0U) ) */

/** \brief Initialize the internals of the ReadDataByPeriodicIdentifier service
 **
 ** \retval None
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_Init(
  void);

/** \brief Force the checking of scheduled periodic identifiers for session security level and
 **        mode condition
 **
 ** \retval None
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_ForceReValidate(
  void);

/** \brief Check if the periodic tx channel for the periodic DID sample to be send is enabled
 **
 ** \retval TRUE    Channel is enabled
 ** \retval FALSE   Channel is NOT enabled
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(boolean, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_IsPeriodicTxChannelEnabled(
  void);

/** \brief Remove all, or a number of given PDID from the periodic scheduler list
 **
 ** \param[in] BufferPDIDs    Buffer holding the periodic DIDs (lower octet)
 ** \param[in] NumberOfPDIDs  Number of periodic DIDs in that buffer. Zero -> remove all.
 **
 ** \retval None
 **
 ** \Reentrancy{Non-reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_RemoveFromSchedulerTable(
  P2CONST(uint8, AUTOMATIC, DCM_VAR) BufferPDIDs,
  uint8 NumberOfPDIDs);

/** \brief Remove all PDID from the periodic scheduler list that have a security level configured
 **
 ** \retval None
 **
 ** \Reentrancy{Non-reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_RemoveSecuredFromSchedulerTable(
  void);

/** \brief Get the number of periodic DID samples that are ready for transmission
 **
 ** \retval Number of samples that are available in the transmission ring
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(uint16, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_GetNumberOfTransmittableSamples(
  void);

/** \brief This function performs required actions upon session change.
 **
 **  \param[in] OldSession          Session level before change
 **  \param[in] NewSession          Session level after change
 **
 **  \return void
 **/
extern FUNC(void, DCM_CODE) Dcm_Dsp_ReadDataByPeriodicIdentifier_SessionChange(
  Dcm_SesCtrlType OldSession, Dcm_SesCtrlType NewSession);

#define DCM_STOP_SEC_CODE
#include <Dcm_MemMap.h>
/*==================[internal function declarations]=============================================*/

/*==================[external constants]=========================================================*/

/*==================[internal constants]=========================================================*/

/*==================[external data]==============================================================*/

#define DCM_START_SEC_VAR_CLEARED_8
#include <Dcm_MemMap.h>

extern VAR(uint8, DCM_VAR) Dcm_PeriodicDidListBuf[2U];

#define DCM_STOP_SEC_VAR_CLEARED_8
#include <Dcm_MemMap.h>

/*==================[internal data]==============================================================*/

/*==================[external function definitions]==============================================*/

/*==================[internal function definitions]==============================================*/

#endif /* #if (DCM_DSP_USE_SERVICE_0X2A == STD_ON) */

#endif /* ifndef DCM_DSP_SVCH_READDATABYPERIODICIDENTIFIER_H */
/*==================[end of file]================================================================*/
