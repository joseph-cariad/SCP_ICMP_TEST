/**
 * \file
 *
 * \brief AUTOSAR FiM
 *
 * This file contains the implementation of the AUTOSAR
 * module FiM.
 *
 * \version 2.5.3
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2021 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */


 /* MISRA-C:2012 Deviation List
  *
  *  MISRAC2012-1) Deviated Rule: 8.9 (advisory)
  *     "An object should be defined at block scope if its identifier only
  *     appears in a single function."
  *
  *     Reason:
  *     The AUTOSAR memory mapping requires that functions are mapped to
  *     SEC_CODE memory sections. Objects at block scope require a
  *     different mapping, e.g. to a SEC_VAR section, which leads to
  *     nested memory sections, which is not supported by some compilers.
  *
  *  MISRAC2012-2) Deviated Rule: 8.3 (required)
  *     "All declarations of an object or function shall use the same
  *      names and type qualifiers."
  *
  *     Reason:
  *     Autosar FiM  ASR 4.0.3 specification wrongly defines the RTE generated
  *     type as FunctionIdType. To be inline with specification following
  *     typedef is required which shall be removed once rfc#52203 is
  *     implemented.
  */

 /* tasking Deviation List
  *
  * TASKING-1) Deviated Rule: W549
  * W549: condition is always true
  *
  * Reason: false positive, see tasking issue TCVX-41885 (TASKING VX-toolset for TriCore)
  *
  */

/*==================[inclusions]============================================*/
/* !LINKSTO dsn.FiM.IncludeStr,1 */

#include <Std_Types.h>         /* AUTOSAR standard types */
#include <TSAutosar.h>         /* EB specific standard types */
#include <TSMem.h>             /* TS_MemSet() */

#include <FiM.h>               /* Module public API */
#include <FiM_Int.h>           /* Module internal interface */
#include <FiM_Trace.h>         /* Dbg related macros for FiM */
#include <SchM_FiM.h>          /* Header of Schedule Manager for FiM */

#if (FIM_DEV_ERROR_DETECT == STD_ON)
# include <Det.h>              /* Det API */
#endif

#include <Dem.h>               /* The APIs to report errors as well as the required
                                * EventId symbols are included. */

#if (FIM_INCLUDE_RTE == STD_ON)
# include <Rte_FiM.h>          /* API generated by RTE */
#endif

/*==================[macros]================================================*/
/* !LINKSTO FIM.Version.Check,1 */

/*------------------[AUTOSAR vendor identification check]-------------------*/

#ifndef FIM_VENDOR_ID /* configuration check */
#error FIM_VENDOR_ID must be defined
#endif

#if (FIM_VENDOR_ID != 1U) /* vendor check */
#error FIM_VENDOR_ID has wrong vendor id
#endif

/*------------------[AUTOSAR release version identification check]----------*/

#ifndef FIM_AR_RELEASE_MAJOR_VERSION /* configuration check */
#error FIM_AR_RELEASE_MAJOR_VERSION must be defined
#endif

/* major version check */
#if (FIM_AR_RELEASE_MAJOR_VERSION != 4U)
#error FIM_AR_RELEASE_MAJOR_VERSION wrong (!= 4U)
#endif

#ifndef FIM_AR_RELEASE_MINOR_VERSION /* configuration check */
#error FIM_AR_RELEASE_MINOR_VERSION must be defined
#endif

/* minor version check */
#if (FIM_AR_RELEASE_MINOR_VERSION != 0U )
#error FIM_AR_RELEASE_MINOR_VERSION wrong (!= 0U)
#endif

#ifndef FIM_AR_RELEASE_REVISION_VERSION /* configuration check */
#error FIM_AR_RELEASE_REVISION_VERSION must be defined
#endif

/* revision version check */
#if (FIM_AR_RELEASE_REVISION_VERSION != 3U )
#error FIM_AR_RELEASE_REVISION_VERSION wrong (!= 3U)
#endif

/*------------------[AUTOSAR module version identification check]-----------*/

#ifndef FIM_SW_MAJOR_VERSION /* configuration check */
#error FIM_SW_MAJOR_VERSION must be defined
#endif

/* major version check */
#if (FIM_SW_MAJOR_VERSION != 2U)
#error FIM_SW_MAJOR_VERSION wrong (!= 2U)
#endif

#ifndef FIM_SW_MINOR_VERSION /* configuration check */
#error FIM_SW_MINOR_VERSION must be defined
#endif

/* minor version check */
#if (FIM_SW_MINOR_VERSION < 5U)
#error FIM_SW_MINOR_VERSION wrong (< 5U)
#endif

#ifndef FIM_SW_PATCH_VERSION /* configuration check */
#error FIM_SW_PATCH_VERSION must be defined
#endif

/* patch version check */
#if (FIM_SW_PATCH_VERSION < 3U)
#error FIM_SW_PATCH_VERSION wrong (< 3U)
#endif

/*------------------[inhibition masks]--------------------------------------*/
/* !LINKSTO FIM.FidStatus.BitDefinition,1 */

#if (defined FIM_LAST_FAILED_MASK)
#error FIM_LAST_FAILED_MASK already defined
#endif
/** \brief Last Failed requires testing bit 0 of extended event status */
#define FIM_LAST_FAILED_MASK                    0x01U

#if (defined FIM_NOT_TESTED_MASK)
#error FIM_NOT_TESTED_MASK already defined
#endif
/** \brief Not Tested requires testing bit 6 of extended event status */
#define FIM_NOT_TESTED_MASK                     0x40U

#if (defined FIM_TESTED_MASK)
#error FIM_TESTED_MASK already defined
#endif
/** \brief Tested requires testing bit 6 of extended event status */
#define FIM_TESTED_MASK                         0x40U

#if (defined FIM_TESTED_AND_FAILED_MASK)
#error FIM_TESTED_AND_FAILED_MASK already defined
#endif
/** \brief Tested and Failed requires testing bit 6 and bit 0 of extended
 ** event status */
#define FIM_TESTED_AND_FAILED_MASK              0x41U

#if (defined FIM_LAST_FAILED_RESULT)
#error FIM_LAST_FAILED_RESULT already defined
#endif
/** \brief Bit 0 of extended event status will be set for Last Failed */
#define FIM_LAST_FAILED_RESULT                  0x01U

#if (defined FIM_NOT_TESTED_RESULT)
#error FIM_NOT_TESTED_RESULT already defined
#endif
/** \brief Bit 6 of extended event status will be set for Not Tested */
#define FIM_NOT_TESTED_RESULT                   0x40U

#if (defined FIM_TESTED_RESULT)
#error FIM_TESTED_RESULT already defined
#endif
/** \brief Bit 6 of extended event status will be reset for Tested */
#define FIM_TESTED_RESULT                       0x00U

#if (defined FIM_TESTED_AND_FAILED_RESULT)
#error FIM_TESTED_AND_FAILED_RESULT already defined
#endif
/** \brief Bit 6 of extended event status will be reset for Tested
 ** and Bit 0 will be set for Failed */
#define FIM_TESTED_AND_FAILED_RESULT            0x01U


#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)

#if (defined FIM_LAST_UNCONFIRMED_MASK)
#error FIM_LAST_UNCONFIRMED_MASK already defined
#endif
/** \brief Last Unconfirmed requires testing bit 0 of SI30 event status */
#define FIM_LAST_UNCONFIRMED_MASK               0x01U

#if (defined FIM_LAST_UNCONFIRMED_RESULT)
#error FIM_LAST_UNCONFIRMED_RESULT already defined
#endif
/** \brief Bit 0 of SI30 event status will be set for Failed This Operation
 ** cycle */
#define FIM_LAST_UNCONFIRMED_RESULT             0x01U

#if (defined FIM_FAILED_THIS_OP_CYCLE_MASK)
#error FIM_FAILED_THIS_OP_CYCLE_MASK already defined
#endif
/** \brief Failed this operation cycle requires testing bit 1 of UDS event status */
#define FIM_FAILED_THIS_OP_CYCLE_MASK           0x02U

#if (defined FIM_FAILED_THIS_OP_CYCLE_RESULT)
#error FIM_FAILED_THIS_OP_CYCLE_RESULT already defined
#endif
/** \brief Bit 1 of UDS event status will be set for Failed This Operation
 ** cycle */
#define FIM_FAILED_THIS_OP_CYCLE_RESULT         0x02U

#if (defined FIM_UNCONFIRMED_THIS_OP_CYCLE_MASK)
#error FIM_UNCONFIRMED_THIS_OP_CYCLE_MASK already defined
#endif
/** \brief Unconfirmed This Operation Cycle requires testing bit 1 of SI30
 ** event status */
#define FIM_UNCONFIRMED_THIS_OP_CYCLE_MASK      0x02U

#if (defined FIM_UNCONFIRMED_THIS_OP_CYCLE_RESULT)
#error FIM_UNCONFIRMED_THIS_OP_CYCLE_RESULT already defined
#endif
/** \brief Bit 1 of SI30 event status will be set for Failed This Operation
 ** cycle */
#define FIM_UNCONFIRMED_THIS_OP_CYCLE_RESULT    0x02U

#endif /* FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION */


#if (defined FIM_MASK_COUNT)
#error FIM_MASK_COUNT already defined
#endif
/** \brief Count of inhibition masks */
#if (FIM_EXTENDED_LEVEL == FIM_NO_EXTENSION)
#define FIM_MASK_COUNT                          4U
#else
#define FIM_MASK_COUNT                          7U
#endif

#if (defined FIM_UDS_MASK_COUNT)
#error FIM_UDS_MASK_COUNT already defined
#endif
/** \brief Count of UDS inhibition masks */
#define FIM_UDS_MASK_COUNT                      5U

/*------------------[helper macros]-----------------------------------------*/

#if (FIM_CONFIG_ACCESS == FIM_CONFIG_ACCESS_EVENT)

#if (defined FIM_CONFIG_INDEX)
#error FIM_CONFIG_INDEX already defined
#endif
/** \brief Get start index from ::FiM_EvtConfigType */
#define FIM_CONFIG_INDEX(IDX)       FiM_EvtConfig[(IDX)].StartIndex

#if (defined FIM_CONFIG_EVENT_ID)
#error FIM_CONFIG_EVENT_ID already defined
#endif
/** \brief Get event id from ::FiM_EvtConfigType */
#define FIM_CONFIG_EVENT_ID(IDX)    FiM_EvtConfig[(IDX)].EventID

#if (defined FIM_CONFIG_FID)
#error FIM_CONFIG_FID already defined
#endif
/** \brief Get function id from ::FiM_EvtConfigDataType */
#define FIM_CONFIG_FID(IDX)         (FiM_FunctionIdType)(FiM_EvtConfigData[(IDX)] & FIM_EVENT_MASK)

#if (defined FIM_CONFIG_INHIB_MASK_IDX)
#error FIM_CONFIG_INHIB_MASK_IDX already defined
#endif
/** \brief Get inhibition mask from ::FiM_EvtConfigDataType */
#define FIM_CONFIG_INHIB_MASK_IDX(IDX)          \
    (uint8)((FiM_EvtConfigData[(IDX)] >> FIM_CONFIG_INHIBITION_MASK_OFFSET) & \
            FIM_CONFIG_INHIBITION_MASK)

#else /* FIM_CONFIG_ACCESS == FIM_CONFIG_ACCESS_EVENT */

#if (defined FIM_CONFIG_INDEX)
#error FIM_CONFIG_INDEX already defined
#endif
/** \brief Get start index from ::FiM_FidConfigStartIndexType */
#define FIM_CONFIG_INDEX(IDX)       FiM_FidConfigStartIndex[(IDX)]

#if (defined FIM_CONFIG_EVENT_ID)
#error FIM_CONFIG_EVENT_ID already defined
#endif
/** \brief Get event id from ::FiM_FidConfigDataType */
#define FIM_CONFIG_EVENT_ID(IDX)    (Dem_EventIdType)(FiM_FidConfigData[(IDX)] & FIM_EVENT_MASK)

#if (defined FIM_CONFIG_FID)
#error FIM_CONFIG_FID already defined
#endif
/** \brief Function Id */
#define FIM_CONFIG_FID(IDX)         (FiM_FunctionIdType)((IDX) + 1U)

#if (defined FIM_CONFIG_INHIB_MASK_IDX)
#error FIM_CONFIG_INHIB_MASK_IDX already defined
#endif
/** \brief Get inhibition mask from ::FiM_FidConfigDataType */
#define FIM_CONFIG_INHIB_MASK_IDX(IDX)          \
  (uint8)((FiM_FidConfigData[(IDX)] >> FIM_CONFIG_INHIBITION_MASK_OFFSET) & \
          FIM_CONFIG_INHIBITION_MASK)


#if (defined FIM_CONFIG_CONDITION_EVENTID)
#error FIM_CONFIG_CONDITION_EVENTID already defined
#endif
/** \brief Get Condition Event Id from ::FiM_ExtendedConfigType */
#define FIM_CONFIG_CONDITION_EVENTID(IDX)       \
  (Dem_EventIdType)((FiM_ExtendedConfiguration[(IDX)] >> FIM_EXT_CONFIG_CONDITION_EVENTID_OFFSET)& \
                    FIM_EXT_CONFIG_CONDITION_EVENTID_MASK)


#if (FIM_EXTENDED_LEVEL == FIM_EXTENSION_LVL2)

#if (defined FIM_CONFIG_FORCE_RELEASE_EVENTID)
#error FIM_CONFIG_FORCE_RELEASE_EVENTID already defined
#endif
/** \brief Get Force Release Event Id from ::FiM_FidExtendedCfgLvl2Type */
#define FIM_CONFIG_FORCE_RELEASE_EVENTID(IDX)   \
  FiM_ExtendedConfigurationLvl2[(IDX)].ForceReleaseEventId

#if (defined FIM_CONFIG_RECOVERY_EVENTID)
#error FIM_CONFIG_RECOVERY_EVENTID already defined
#endif
/** \brief Get Condition Event Id from ::FiM_FidExtendedCfgLvl2Type */
#define FIM_CONFIG_RECOVERY_EVENTID(IDX)        \
  FiM_ExtendedConfigurationLvl2[(IDX)].RecoveryEventId

#endif /* FIM_EXTENDED_LEVEL == FIM_EXTENSION_LVL2 */


#if (defined FIM_CONFIG_MESSAGEID)
#error FIM_CONFIG_MESSAGEID already defined
#endif
/** \brief Get Message Id from ::FiM_MessageIdType */
#define FIM_CONFIG_MESSAGEID(IDX)               \
  (FiM_MessageIdType)(FiM_MessageIdConfiguration[(IDX)])

#if (defined FIM_CONFIG_SYMPTOM)
#error FIM_CONFIG_SYMPTOM already defined
#endif
/** \brief Get Symptom Bit from ::FiM_ExtendedConfigType */
#define FIM_CONFIG_SYMPTOM(IDX)                 \
           (boolean)((((FiM_ExtendedConfiguration[(IDX)] >> FIM_EXT_CONFIG_SYMPTOM_OFFSET) & \
            FIM_EXT_CONFIG_SYMPTOM_MASK) != 0U) ? TRUE : FALSE)

#endif /* FIM_CONFIG_ACCESS == FIM_CONFIG_ACCESS_EVENT */

#if (defined FIM_EVENT_ID_INVALID)
#error FIM_EVENT_ID_INVALID already defined
#endif
/** \brief Symbolic name of invalid event ID (derived from Dem SWS) */
#define FIM_EVENT_ID_INVALID                    0U

#if (defined GET_MID_VALUE)
#error GET_MID_VALUE already defined
#endif
/** \brief To get the mid value for binary search */
#define GET_MID_VALUE(high, low)                (((low) + (high)) / 2)

#if (FIM_DEV_ERROR_DETECT == STD_ON)
#if (defined FIM_DET_REPORT_ERROR)
#error FIM_DET_REPORT_ERROR already defined
#endif
/** \brief Report FiM development error */
#define FIM_DET_REPORT_ERROR(ApiId, ErrorId)    \
  ((void)Det_ReportError(FIM_MODULE_ID, FIM_INSTANCE_ID, (ApiId), (ErrorId)))
#endif

#if (defined FIM_ENTER_EXCLUSIVE_AREA)
#error FIM_ENTER_EXCLUSIVE_AREA already defined
#endif
/* !LINKSTO dsn.FiM.SchMEnterCS,1 */
/** \brief Macro to enter the generic critical section */
#define FIM_ENTER_EXCLUSIVE_AREA SchM_Enter_FiM_SCHM_FIM_EXCLUSIVE_AREA_0

#if (defined FIM_EXIT_EXCLUSIVE_AREA)
#error FIM_EXIT_EXCLUSIVE_AREA already defined
#endif
/* !LINKSTO dsn.FiM.SchMLeaveCS,1 */
/** \brief Macro to leave the generic FiM critical section */
#define FIM_EXIT_EXCLUSIVE_AREA SchM_Exit_FiM_SCHM_FIM_EXCLUSIVE_AREA_0

/*==================[type definitions]======================================*/

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)
typedef struct
{
  boolean SymptomBit;
  FiM_MessageIdType MessageId;
  Dem_EventIdType ConditionEventId;
  boolean ConditionEventFailed;
  Dem_EventIdType ReleaseEventId;
  boolean ReleaseEventFailed;
  Dem_EventIdType RecoveryEventId;
  boolean RecoveryEventFailed;
} FiM_FidDataType;
#endif

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define FIM_START_SEC_CODE
#include <FiM_MemMap.h>

#if (FIM_MODE == FIM_MODE_POLLING_ASYNC)
/** \brief Handles FID permission and message **/
STATIC FUNC(void, FIM_CODE) FiM_HandleFID(FiM_FunctionIdType Fid);
#endif

/** \brief Clear inhibition status of all FIDs **/
STATIC FUNC(void, FIM_CODE) FiM_ClearInhibitionStatus(void);

#if (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_ON)

/** \brief Processes inhibition counter */
STATIC FUNC(void, FIM_CODE) FiM_ProcessInhibitionCounter(
  FiM_FunctionIdType Fid,
  Dem_EventIdType    EventId,
  uint8              EventStatusOld,
  uint8              EventStatusNew,
  uint8              InhMaskIdx);

/** \brief Determines inhibition status of all FIDs
 **
 ** This function loops through all Fids and calculated the permission.
 **/
STATIC FUNC(void, FIM_CODE) FiM_DetermineInhibition(void);

#if (FIM_CONFIG_ACCESS == FIM_CONFIG_ACCESS_EVENT)
/** \brief Gets the event-index of the tested and failed inhibition events.
 **
 ** This function gets the index of the event from the global array
 ** which contains only specific FIDs mapped to the event.
 **
 ** \param[in] EventId  Identification of an Event
 ** \param[out] EvtIdx  Index of Event Id
 **
 ** \return Result of the searching
 ** \retval E_OK     EvtIdx was found
 ** \retval E_NOT_OK no EvtIdx exists
 */
STATIC FUNC(Std_ReturnType, FIM_CODE) FiM_EventSearch(
  Dem_EventIdType                                EventId,
  P2VAR(FiM_IndexType, AUTOMATIC, FIM_APPL_DATA) EvtIdx);
#endif /* FIM_CONFIG_ACCESS == FIM_CONFIG_ACCESS_EVENT */

#endif /* (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_ON) */

#if ( (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_OFF) || \
      (FIM_MODE == FIM_MODE_POLLING_SYNC) )
/** \brief Gets the permission of a FID.
 **
 ** This function calculates the permission of a FID by looping through all
 ** associated events and check their extended status.
 **
 ** \param[in] FID  Function Id
 **
 ** \return boolean
 ** \retval TRUE  FID has permission
 ** \retval FALSE FID has no permission
 */
STATIC FUNC(boolean, FIM_CODE) FiM_CalculateFIDPermission(
  FiM_FunctionIdType Fid);
#endif

/** \brief Calculate permission of an Fid link
 **
 ** This function gets the status of an event and checks the permission.
 **
 ** \param[in] Fid          Function Id
 ** \param[in] EventId      Event Id
 ** \param[in] InhMaskIdx   Index of Event Id
 ** \param[OUT] Permission  Permission of inhibition
 **
 ** \return Result    Result of operation
 ** \retval E_OK      Operation successful
 ** \retval E_NOT_OK  Operation successful
 */
STATIC FUNC(Std_ReturnType, FIM_CODE) FiM_CalculateFidLinkPermission(
  FiM_FunctionIdType                        Fid,
  Dem_EventIdType                           EventId,
  uint8                                     InhMaskIdx,
  CONSTP2VAR(boolean, AUTOMATIC, AUTOMATIC) Permission);

#if (FIM_MODE == FIM_MODE_POLLING_ASYNC)

/** \brief Returns the permission of an inhibition for a Fid.
 **
 ** \param[in] Fid      Function Id
 **
 ** \return Permission  Permission of Fid
 ** \retval TRUE        Has permission to run
 ** \retval FALSE       Has no permission to run
 */
STATIC FUNC(boolean, FIM_CODE) FiM_GetFidPermissionFlag(FiM_FunctionIdType Fid);

/** \brief Sets the permission of an inhibition.
 **
 ** \param[in] Fid         Function Id
 ** \param[in] Permission  Permission to be set
 */
STATIC FUNC(void, FIM_CODE) FiM_SetFidPermissionFlag(
  FiM_FunctionIdType Fid,
  boolean            Permission);

#endif

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)

/** \brief Notify Dem if necessary.
 **
 ** Function notify Dem depending on condition event, symptom bit and message id
 **
 ** \param[in] EventId  Event Id
 */
STATIC FUNC(void, FIM_CODE) FiM_SymptomAndNotification(
  Dem_EventIdType EventId);

#if (FIM_EXTENDED_LEVEL == FIM_EXTENSION_LVL2)

/** \brief Checks system recovery.
 **
 ** \param[in] Fid        Function Id
 ** \param[in] EventId    Event Id
 ** \param[IN] InhMaskIdx Inhibition mask index
 **/
STATIC FUNC(void, FIM_CODE) FiM_Recovery(
  FiM_FunctionIdType Fid,
  Dem_EventIdType    EventId,
  uint8              InhMaskIdx);

#endif

/** \brief Function sets global data for the Fid.
 **
 ** \param[in] Fid           Function Id
 */
STATIC FUNC(void, FIM_CODE) FiM_SetFidData(FiM_FunctionIdType Fid);

#endif

#define FIM_STOP_SEC_CODE
#include <FiM_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

#define FIM_START_SEC_CONST_UNSPECIFIED
#include <FiM_MemMap.h>

/** \brief Array of inhibition masks */
/* Deviation MISRAC2012-1 */
STATIC CONST(Dem_EventStatusExtendedType, FIM_CONST)
  FiM_InhMask[FIM_MASK_COUNT] =
{
  FIM_LAST_FAILED_MASK,
  FIM_NOT_TESTED_MASK,
  FIM_TESTED_MASK,
  FIM_TESTED_AND_FAILED_MASK,
#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)
  FIM_FAILED_THIS_OP_CYCLE_MASK,
  FIM_LAST_UNCONFIRMED_MASK,
  FIM_UNCONFIRMED_THIS_OP_CYCLE_MASK
#endif
};

/** \brief Array of expected result after masking */
/* Deviation MISRAC2012-1 */
STATIC CONST(Dem_EventStatusExtendedType, FIM_CONST)
  FiM_InhResult[FIM_MASK_COUNT] =
{
  FIM_LAST_FAILED_RESULT,
  FIM_NOT_TESTED_RESULT,
  FIM_TESTED_RESULT,
  FIM_TESTED_AND_FAILED_RESULT,
#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)
  FIM_FAILED_THIS_OP_CYCLE_RESULT,
  FIM_LAST_UNCONFIRMED_RESULT,
  FIM_UNCONFIRMED_THIS_OP_CYCLE_RESULT
#endif
};

#define FIM_STOP_SEC_CONST_UNSPECIFIED
#include <FiM_MemMap.h>

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

#define FIM_START_SEC_VAR_INIT_8
#include <FiM_MemMap.h>

#if (FIM_MODE == FIM_MODE_POLLING_ASYNC) || \
    (FIM_DEV_ERROR_DETECT == STD_ON)

/** \brief Initialization status of the FiM module */
STATIC VAR(boolean, FIM_VAR) FiM_Initialized = FALSE;

#endif

#define FIM_STOP_SEC_VAR_INIT_8
#include <FiM_MemMap.h>

#define FIM_START_SEC_VAR_CLEARED_8
#include <FiM_MemMap.h>

#if (FIM_MODE == FIM_MODE_TRIGGERED)

/* !LINKSTO FIM065_Implicit2,1 */
/** \brief Inhibition counter of FiM FIDs */
STATIC VAR(uint8, FIM_VAR) FiM_FidInhibitCounter[FIM_FID_NUM];

#endif

#if (FIM_MODE == FIM_MODE_POLLING_ASYNC)

/* !LINKSTO FIM.EB.MeasurementSupport.ExternalAccess,1 */
/** \brief SI30 Inhibition flag of FiM FIDs
 **
 ** This variable holds the FID status of the SI30 events, one bit per FID.
 **/
FIM_STATIC VAR(uint8, FIM_VAR) FiM_FidInhibitionFlag[(FIM_FID_NUM / 8U) + 1U];

#endif

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)

/** \brief Message status of FiM FIDs */
FIM_STATIC VAR(uint8, FIM_VAR) FiM_MessageFlag[FIM_MESSAGE_MAX];
STATIC VAR(boolean, FIM_VAR) FiM_FidMessageFlag[FIM_FID_NUM];
STATIC VAR(boolean, FIM_VAR) FiM_MessageHandling;

/** \brief Fid inhibition status */
/* Deviation MISRAC2012-1 */
FIM_STATIC VAR(boolean, FIM_VAR) FiM_FidInhibitedSinceInit[FIM_FID_NUM];

#endif

#define FIM_STOP_SEC_VAR_CLEARED_8
#include <FiM_MemMap.h>

#define FIM_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <FiM_MemMap.h>

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)

STATIC FiM_FidDataType FiM_FidData;

#endif

#define FIM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <FiM_MemMap.h>

#if (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_OFF)
#if ( (FIM_EXT_MAX_HANDLED_FID_EVENT_LINKS_PER_SCHEDULING != 0U) && \
      (FIM_MODE == FIM_MODE_POLLING_ASYNC) )

#define FIM_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <FiM_MemMap.h>

/** \brief Start FID of mainfunction FID processing
 **
 ** This variable is only used if a configured maximum number of FID-Event
 ** connections should be processed during one mainfunction cycle.
 **/
STATIC VAR(FiM_IndexType, FIM_VAR) FiM_FidStart;

#define FIM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <FiM_MemMap.h>

#elif (FIM_MODE == FIM_MODE_POLLING_ASYNC)

#define FIM_START_SEC_CONST_UNSPECIFIED
#include <FiM_MemMap.h>

/** \brief Start FID of mainfunction FID processing */
STATIC CONST(FiM_IndexType, FIM_CONST) FiM_FidStart = 1U;

#define FIM_STOP_SEC_CONST_UNSPECIFIED
#include <FiM_MemMap.h>

#endif /* FIM_EXT_MAX_HANDLED_FID_EVENT_LINKS_PER_SCHEDULING && FIM_MODE */
#endif /* (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_OFF) */

/*==================[external function definitions]=========================*/

#define FIM_START_SEC_CODE
#include <FiM_MemMap.h>

/*------------------[FiM_GetVersionInfo]------------------------------------*/
#if (FIM_VERSION_INFO_API == STD_ON)
FUNC(void, FIM_CODE) FiM_GetVersionInfo(
  P2VAR(Std_VersionInfoType, AUTOMATIC, FIM_APPL_DATA) VersionInfoPtr)
{
  DBG_FIM_GETVERSIONINFO_ENTRY(VersionInfoPtr);

#if (FIM_DEV_ERROR_DETECT == STD_ON)
  if (NULL_PTR == VersionInfoPtr)
  {
    FIM_DET_REPORT_ERROR(FIM_SID_GET_VERSION_INFO, FIM_E_INVALID_POINTER);
  }
  else
#endif
  {
    VersionInfoPtr->vendorID         = FIM_VENDOR_ID;
    VersionInfoPtr->moduleID         = FIM_MODULE_ID;
    VersionInfoPtr->sw_major_version = FIM_SW_MAJOR_VERSION;
    VersionInfoPtr->sw_minor_version = FIM_SW_MINOR_VERSION;
    VersionInfoPtr->sw_patch_version = FIM_SW_PATCH_VERSION;
  }

  DBG_FIM_GETVERSIONINFO_EXIT(VersionInfoPtr);
}
#endif /* FIM_VERSION_INFO_API == STD_ON */

/*------------------[FiM_Init]----------------------------------------------*/
FUNC(void, FIM_CODE) FiM_Init(
  P2CONST(FiM_ConfigType, AUTOMATIC, FIM_APPL_CONST) FiMConfigPtr)
{
  DBG_FIM_INIT_ENTRY(FiMConfigPtr);

  TS_PARAM_UNUSED(FiMConfigPtr);

#if (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_ON)
  /* initialize inhibition counters */
  FiM_DetermineInhibition();
#else
  FiM_ClearInhibitionStatus();
#endif

#if (FIM_MODE == FIM_MODE_POLLING_ASYNC)
  {
    /* Handle FID after inhibition status is cleared */
    FiM_FunctionIdType Fid;

    /* Initialize all FIDs */
    for (Fid = 1U; Fid < FIM_FID_NUM; Fid++)
    {
      FiM_HandleFID(Fid);
    }
  }
#endif

#if ( (FIM_EXT_MAX_HANDLED_FID_EVENT_LINKS_PER_SCHEDULING != 0U) && \
      (FIM_MODE == FIM_MODE_POLLING_ASYNC) && \
      (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_OFF) )
  FiM_FidStart = 1U;
#endif

#if (FIM_MODE == FIM_MODE_POLLING_ASYNC) || \
    (FIM_DEV_ERROR_DETECT == STD_ON)
  /* tag module as initialized */
  FiM_Initialized = TRUE;
#endif

  DBG_FIM_INIT_EXIT(FiMConfigPtr);
}

/*------------------[FiM_MainFunction]--------------------------------------*/
#if (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_OFF)
FUNC(void, FIM_CODE) FiM_MainFunction(void)
{
  DBG_FIM_MAINFUNCTION_ENTRY();

#if (FIM_MODE == FIM_MODE_POLLING_ASYNC)

  /* Verify initialization-status before performing any actions */
  if (TRUE == FiM_Initialized)
  {
#if (FIM_EXT_MAX_HANDLED_FID_EVENT_LINKS_PER_SCHEDULING != 0U)
    uint32 ProcessConnections = 0U;
#endif
    FiM_IndexType Fid;

    /* Loop through all FIDs */
    for (Fid = FiM_FidStart; Fid < FIM_FID_NUM; Fid++)
    {
#if (FIM_EXT_MAX_HANDLED_FID_EVENT_LINKS_PER_SCHEDULING != 0U)
      const FiM_IndexType EventIdxStart = FIM_CONFIG_INDEX(Fid - 1U);
      const FiM_IndexType EventIdxMax = FIM_CONFIG_INDEX(Fid);

      /* Add number of FID-Event connections processed this cycle */
      ProcessConnections += (uint8)(EventIdxMax - EventIdxStart);

      if (ProcessConnections > FIM_EXT_MAX_HANDLED_FID_EVENT_LINKS_PER_SCHEDULING)
      {
        /* Save start index for next mainfunction schedule */
        FiM_FidStart = Fid;

        /* Number of FID-Event connections processed during one mainfunction cycle is reached */
        break;
      }
      else
#endif
      {
        FiM_HandleFID(Fid);
      }
    }

#if (FIM_EXT_MAX_HANDLED_FID_EVENT_LINKS_PER_SCHEDULING != 0U)
    if (Fid == FIM_FID_NUM)
    {
      /* All connections are processed -> start next time from the beginning */
      FiM_FidStart = 1U;
    }
#endif
  }

#endif /* FIM_MODE == FIM_MODE_POLLING_ASYNC */

  DBG_FIM_MAINFUNCTION_EXIT();
}
#endif

/*------------------[FiM_GetFunctionPermission]-----------------------------*/
/* Deviation MISRAC2012-2 */
FUNC(Std_ReturnType, FIM_CODE) FiM_GetFunctionPermission(
  FiM_FunctionIdType                       FID,
  P2VAR(boolean, AUTOMATIC, FIM_APPL_DATA) Permission)
{
  Std_ReturnType RetVal = E_NOT_OK;

  DBG_FIM_GETFUNCTIONPERMISSION_ENTRY(FID, Permission);

#if (FIM_DEV_ERROR_DETECT == STD_ON)
  if (NULL_PTR == Permission)
  {
    FIM_DET_REPORT_ERROR(
      FIM_SID_GET_FUNCTION_PERMISSION, FIM_E_INVALID_POINTER);
  }
  else if (FALSE == FiM_Initialized)
  {
    FIM_DET_REPORT_ERROR(
      FIM_SID_GET_FUNCTION_PERMISSION, FIM_E_WRONG_PERMISSION_REQ);
    *Permission = FALSE;
  }
  else if ((FID >= FIM_FID_NUM) || (0U == FID))
  {
    FIM_DET_REPORT_ERROR(
      FIM_SID_GET_FUNCTION_PERMISSION, FIM_E_FID_OUT_OF_RANGE);
    *Permission = FALSE;
  }
  else
#endif
  {
    /* Determine if the FID has permission to run */
    boolean FidPermission;

#if (FIM_MODE == FIM_MODE_POLLING_SYNC)

    /* !LINKSTO dsn.FiM.VCC.FidCalculation.GetPermission,1 */
    /* Calculate Fid permission synchronous */
    FidPermission = FiM_CalculateFIDPermission(FID);

#elif (FIM_MODE == FIM_MODE_POLLING_ASYNC)

    /* !LINKSTO dsn.FiM.VCC.FidCalculation.GetPermission,1 */
    /* Get Fid permission flag */
    FidPermission = FiM_GetFidPermissionFlag(FID);

#elif (FIM_MODE == FIM_MODE_TRIGGERED)

    uint16 FidInhibit;

    /* Enter the critical section */
    FIM_ENTER_EXCLUSIVE_AREA();

    /* !LINKSTO dsn.FiM.VCC.FidCalculation.GetPermission,1 */
    FidInhibit = FiM_FidInhibitCounter[FID];

    /* Exit the critical section */
    FIM_EXIT_EXCLUSIVE_AREA();

    /* Set FID permission */
    if (FidInhibit == 0U)
    {
      FidPermission = TRUE;
    }
    else
    {
      FidPermission = FALSE;
    }

#endif

    /* Return FID permission */
    *Permission = FidPermission;

    RetVal = E_OK;
  }

  DBG_FIM_GETFUNCTIONPERMISSION_EXIT(RetVal, FID, Permission);
  return RetVal;
}

/*------------------[FiM_DemTriggerOnEventStatus]---------------------------*/
#if (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_ON)
FUNC(void, FIM_CODE) FiM_DemTriggerOnEventStatus(
  Dem_EventIdType EventId,
  uint8           EventStatusOld,
  uint8           EventStatusNew)
{
  DBG_FIM_DEMTRIGGERONEVENTSTATUS_ENTRY(
    EventId, EventStatusOld, EventStatusNew);

#if (FIM_DEV_ERROR_DETECT == STD_ON)
  if (FALSE == FiM_Initialized)
  {
    FIM_DET_REPORT_ERROR(
      FIM_SID_DEM_TRIGGER_ON_EVENT, FIM_E_WRONG_TRIGGER_ON_EVENT);
  }
  /* if the event Id is not existing, raise DET error */
  else if ((FIM_MAX_DEM_EVENT_ID < EventId) ||
           (FIM_EVENT_ID_INVALID == EventId))
  {
    FIM_DET_REPORT_ERROR(
      FIM_SID_DEM_TRIGGER_ON_EVENT, FIM_E_EVENTID_OUT_OF_RANGE);
  }
  else
#endif
  {
    FiM_IndexType EventIdx;
    FiM_IndexType FidStartIdx = 0U;

#if (FIM_CONFIG_ACCESS == FIM_CONFIG_ACCESS_EVENT)

    /* invoke search algorithm to get the event-index */
    if (E_OK == FiM_EventSearch(EventId, &FidStartIdx))
    {
      const FiM_IndexType EventIdxStart = FIM_CONFIG_INDEX(FidStartIdx);
      const FiM_IndexType EventIdxMax = FIM_CONFIG_INDEX(FidStartIdx + 1U);

      /* loop through all FIDs for corresponding event */
      for (EventIdx = EventIdxStart; EventIdx < EventIdxMax; EventIdx++)
      {
        const uint8 InhMaskIdx = FIM_CONFIG_INHIB_MASK_IDX(EventIdx);
        const FiM_FunctionIdType Fid = FIM_CONFIG_FID(EventIdx);

        FiM_ProcessInhibitionCounter(Fid, EventId, EventStatusOld,
                                     EventStatusNew, InhMaskIdx);
      }
    }

#else

    /* loop through all FIDs because fixed data is disabled */
    for (FidStartIdx = 0U; FidStartIdx < (FIM_FID_STARTINDEX_NUM - 1U); FidStartIdx++)
    {
      const FiM_FunctionIdType Fid = FidStartIdx + 1U;
      const FiM_IndexType EventIdxStart = FIM_CONFIG_INDEX(FidStartIdx);
      const FiM_IndexType EventIdxMax = FIM_CONFIG_INDEX(FidStartIdx + 1U);

      /* loop through all events associated with this FID */
      for (EventIdx = EventIdxStart; EventIdx < EventIdxMax; EventIdx++)
      {
        const Dem_EventIdType EventIdCfg = FIM_CONFIG_EVENT_ID(EventIdx);

        if (EventId == EventIdCfg)
        {
          const uint8 InhMaskIdx = FIM_CONFIG_INHIB_MASK_IDX(EventIdx);

          FiM_ProcessInhibitionCounter(Fid, EventId, EventStatusOld,
                                       EventStatusNew, InhMaskIdx);
        }
      }
    }

#endif
  }

  DBG_FIM_DEMTRIGGERONEVENTSTATUS_EXIT(
    EventId, EventStatusOld, EventStatusNew);
}
#endif /* FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_ON */

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)
/*------------------[FiM_DemTriggerOnUnconfirmed]---------------------------*/
/* !LINKSTO VCC-FIM-003:Req39v1,1 */
FUNC(void, FIM_CODE) FiM_DemTriggerOnUnconfirmed(Dem_EventIdType EventId)
{
  DBG_FIM_DEMTRIGGERONUNCONFIRMED_ENTRY(EventId);

#if (FIM_DEV_ERROR_DETECT == STD_ON)
  if (FALSE == FiM_Initialized)
  {
    FIM_DET_REPORT_ERROR(FIM_SID_DEM_TRIGGER_ON_UNCONFIRMED, FIM_E_UNINIT);
  }
  /* if the event Id is not existing, raise DET error */
  else if ((FIM_MAX_DEM_EVENT_ID < EventId) ||
           (FIM_EVENT_ID_INVALID == EventId))
  {
    FIM_DET_REPORT_ERROR(
      FIM_SID_DEM_TRIGGER_ON_UNCONFIRMED, FIM_E_EVENTID_OUT_OF_RANGE);
  }
  else
#endif
  {
    uint16_least Idx;

    /* Deviation TASKING-1 */
    for (Idx = 0U; Idx < FIM_EXT_MAX_HIGH_PRIO_EVENT_TO_FID_LINKS; Idx++)
    {
      /* !LINKSTO dsn.FiM.VCC.HighPriorityInhibitionHandling,1 */
      if (FiM_HighPrioEventId[Idx] == EventId)
      {
        /* The connected Fid must be inhibit immediately */
        FiM_SetFidPermissionFlag(FiM_HighPrioFid[Idx], FALSE);
      }
    }
  }

  DBG_FIM_DEMTRIGGERONUNCONFIRMED_EXIT(EventId);
}

#if (FIM_MESSAGE_MAX > 1)
/* Call this function only if more FIM Ids are configured */
/*------------------[FiM_GetMessageStatus]----------------------------------*/
/* !LINKSTO VCC-FIM-003:Req40v1,1, VCC-FIM-003:Req17v1,1 */
FUNC(Std_ReturnType, FIM_CODE) FiM_GetMessageStatus(
  FiM_MessageIdType                        MessageId,
  P2VAR(boolean, AUTOMATIC, FIM_APPL_DATA) Status)
{
  Std_ReturnType RetVal;

  DBG_FIM_GETMESSAGESTATUS_ENTRY(MessageId, Status);

#if (FIM_DEV_ERROR_DETECT == STD_ON)
  if (FALSE == FiM_Initialized)
  {
    FIM_DET_REPORT_ERROR(FIM_SID_GET_MESSAGE_STATUS, FIM_E_UNINIT);
    RetVal = E_NOT_OK;
  }
  else if ((FIM_MESSAGE_MAX <= MessageId) || (FIM_MESSAGE_INVALID == MessageId))
  {
    FIM_DET_REPORT_ERROR(FIM_SID_GET_MESSAGE_STATUS, FIM_E_MESSAGEID_OUT_OF_RANGE);
    RetVal = E_NOT_OK;
  }
  else if (Status == NULL_PTR)
  {
    FIM_DET_REPORT_ERROR(FIM_SID_GET_MESSAGE_STATUS, FIM_E_INVALID_POINTER);
    RetVal = E_NOT_OK;
  }
  else
#endif
  {
    *Status = (FiM_MessageFlag[MessageId] == 0U) ? FALSE : TRUE;

    RetVal = E_OK;
  }

  DBG_FIM_GETMESSAGESTATUS_EXIT(RetVal, MessageId, Status);
  return RetVal;
}
#endif /* FIM_MESSAGE_MAX > 1 */
#endif /* FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION */

/*------------------[FiM_DemInit]-------------------------------------------*/
FUNC(void, FIM_CODE) FiM_DemInit(void)
{
  DBG_FIM_DEMINIT_ENTRY();

#if (FIM_DEV_ERROR_DETECT == STD_ON)
  if (FALSE == FiM_Initialized)
  {
    FIM_DET_REPORT_ERROR(FIM_SID_DEM_INIT, FIM_E_WRONG_TRIGGER_ON_EVENT);
  }
  else
#endif
  {
#if (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_ON)
    /* initialize inhibition counters */
    FiM_DetermineInhibition();
#else
    FiM_ClearInhibitionStatus();
#endif
#if ( (FIM_EXT_MAX_HANDLED_FID_EVENT_LINKS_PER_SCHEDULING != 0U) && \
      (FIM_MODE == FIM_MODE_POLLING_ASYNC) && \
      (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_OFF) )
    FiM_FidStart = 1U;
#endif
  }

  DBG_FIM_DEMINIT_EXIT();
}

/*==================[internal function definitions]=========================*/

#if (FIM_MODE == FIM_MODE_POLLING_ASYNC)
STATIC FUNC(void, FIM_CODE) FiM_HandleFID(FiM_FunctionIdType Fid)
{
  const boolean PermissionOld = FiM_GetFidPermissionFlag(Fid);
  boolean Permission;

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)
  /* Set working data for this FID */
  FiM_SetFidData(Fid);

  FiM_MessageHandling = FALSE;
#endif

  /* !LINKSTO dsn.FiM.VCC.FidCalculation.MainFunction,1 */
  /* Calculate permission for all associated events */
  Permission = FiM_CalculateFIDPermission(Fid);

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)
  /* !LINKSTO VCC-FIM-004:Req12v2,1 */
  if (FiM_MessageHandling != FiM_FidMessageFlag[Fid])
  {
    FiM_FidMessageFlag[Fid] = FiM_MessageHandling;

    if (FiM_MessageHandling == TRUE)
    {
      FiM_MessageFlag[FiM_FidData.MessageId]++;
    }
    else
    {
      FiM_MessageFlag[FiM_FidData.MessageId]--;
    }
  }
#endif

#if (FIM_EXTENDED_LEVEL == FIM_EXTENSION_LVL2)
  if (Permission == FALSE)
  {
    if (FiM_FidData.ReleaseEventFailed == TRUE)
    {
      /* !LINKSTO VCC-FIM-003:Req23v1,1 */
      Permission = TRUE;
    }
    else
    {
      FiM_FidInhibitedSinceInit[Fid] = TRUE;
    }
  }
#endif /* FIM_EXTENDED_LEVEL == FIM_EXTENSION_LVL2 */

  /* Set permission only if it has changed */
  if (Permission != PermissionOld)
  {
    /* Set Fid permission */
    FiM_SetFidPermissionFlag(Fid, Permission);
  }
}
#endif

STATIC FUNC(void, FIM_CODE) FiM_ClearInhibitionStatus(void)
{
  /* Enter the critical section */
  FIM_ENTER_EXCLUSIVE_AREA();

#if (FIM_MODE == FIM_MODE_TRIGGERED)
  /* clear all inhibition counter */
  TS_MemSet(FiM_FidInhibitCounter, 0U, (uint16)(sizeof(FiM_FidInhibitCounter)));
#endif

#if (FIM_MODE == FIM_MODE_POLLING_ASYNC)
  /* clear all high SI30 inhibition flags */
  TS_MemSet(FiM_FidInhibitionFlag, 0U, (uint16)(sizeof(FiM_FidInhibitionFlag)));
#endif

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)
  TS_MemSet(FiM_MessageFlag, 0U, (uint16)(sizeof(FiM_MessageFlag)));
  TS_MemSet(FiM_FidMessageFlag, FALSE, (uint16)(sizeof(FiM_FidMessageFlag)));
  TS_MemSet(FiM_FidInhibitedSinceInit, FALSE, (uint16)(sizeof(FiM_FidInhibitedSinceInit)));
#endif

  /* Exit the critical section */
  FIM_EXIT_EXCLUSIVE_AREA();

}

#if (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_ON)
STATIC FUNC(void, FIM_CODE) FiM_ProcessInhibitionCounter(
  FiM_FunctionIdType Fid,
  Dem_EventIdType    EventId,
  uint8              EventStatusOld,
  uint8              EventStatusNew,
  uint8              InhMaskIdx)
{
  const uint8 EventStatusChange = EventStatusOld ^ EventStatusNew;

#if (FIM_EXTENDED_LEVEL == FIM_NO_EXTENSION)
  TS_PARAM_UNUSED(EventId);
#endif

  /* !LINKSTO dsn.FiM.VCC.FidCalculation.TriggerOnEventStatus,1 */
  /* Check if the required bits are changed */
  if ( (InhMaskIdx < FIM_UDS_MASK_COUNT) &&
       ((EventStatusChange & FiM_InhMask[InhMaskIdx]) != 0U) )
  {
    /* Check if the Event Status matches the inhibition relation */
    if (((EventStatusOld & FiM_InhMask[InhMaskIdx]) != FiM_InhResult[InhMaskIdx]) &&
        ((EventStatusNew & FiM_InhMask[InhMaskIdx]) == FiM_InhResult[InhMaskIdx]))
    {
      /* Enter the critical section */
      FIM_ENTER_EXCLUSIVE_AREA();

      FiM_FidInhibitCounter[Fid]++;

      /* Exit the critical section */
      FIM_EXIT_EXCLUSIVE_AREA();
    }
    else if (((EventStatusOld & FiM_InhMask[InhMaskIdx]) == FiM_InhResult[InhMaskIdx]) &&
             ((EventStatusNew & FiM_InhMask[InhMaskIdx]) != FiM_InhResult[InhMaskIdx]) )
    {
      /* Enter the critical section */
      FIM_ENTER_EXCLUSIVE_AREA();

      if (0U != FiM_FidInhibitCounter[Fid])
      {
        FiM_FidInhibitCounter[Fid]--;
      }

      /* Exit the critical section */
      FIM_EXIT_EXCLUSIVE_AREA();
    }
    else
    {
      /* Dummy else to avoid Misra warning */
    }
  }
}

STATIC FUNC(void, FIM_CODE) FiM_DetermineInhibition(void)
{
  FiM_IndexType FidStartIdx;
  FiM_IndexType EventIdx;

  FiM_ClearInhibitionStatus();

#if (FIM_CONFIG_ACCESS == FIM_CONFIG_ACCESS_EVENT)

  /* Loop through all the events */
  /* Deviation TASKING-1 */
  for (FidStartIdx = 0U; FidStartIdx < (FIM_EVT_STARTINDEX_NUM - 1U); FidStartIdx++)
  {
    const FiM_IndexType EventIdxStart = FIM_CONFIG_INDEX(FidStartIdx);
    const FiM_IndexType EventIdxMax = FIM_CONFIG_INDEX(FidStartIdx + 1U);
    const Dem_EventIdType EventId = FIM_CONFIG_EVENT_ID(FidStartIdx);

    /* Loop through all FIDs for corresponding event */
    for (EventIdx = EventIdxStart; EventIdx < EventIdxMax; EventIdx++)
    {
      const uint8 InhMaskIdx = FIM_CONFIG_INHIB_MASK_IDX(EventIdx);
      const FiM_FunctionIdType Fid = FIM_CONFIG_FID(EventIdx);
      boolean Permission = TRUE;

      const Std_ReturnType Result = FiM_CalculateFidLinkPermission(Fid,
                                                                   EventId,
                                                                   InhMaskIdx,
                                                                   &Permission);

      if ( (Result == E_OK) && (Permission == FALSE) )
      {
        /* Enter the critical section */
        FIM_ENTER_EXCLUSIVE_AREA();

        FiM_FidInhibitCounter[Fid]++;

        /* Exit the critical section */
        FIM_EXIT_EXCLUSIVE_AREA();
      }
    }
  }

#else

  /* Loop through all FIDs for corresponding event */
  for (FidStartIdx = 0U; FidStartIdx < (FIM_FID_STARTINDEX_NUM - 1U); FidStartIdx++)
  {
    const FiM_IndexType EventIdxStart = FIM_CONFIG_INDEX(FidStartIdx);
    const FiM_IndexType EventIdxMax = FIM_CONFIG_INDEX(FidStartIdx + 1U);

    /* Loop through all the events */
    for (EventIdx = EventIdxStart; EventIdx < EventIdxMax; EventIdx++)
    {
      const Dem_EventIdType EventId = FIM_CONFIG_EVENT_ID(EventIdx);
      const uint8 InhMaskIdx = FIM_CONFIG_INHIB_MASK_IDX(EventIdx);
      const FiM_FunctionIdType Fid = FIM_CONFIG_FID(FidStartIdx);
      boolean Permission = TRUE;

      const Std_ReturnType Result = FiM_CalculateFidLinkPermission(Fid,
                                                                   EventId,
                                                                   InhMaskIdx,
                                                                   &Permission);

      if ( (Result == E_OK) && (Permission == FALSE) )
      {
        /* Enter the critical section */
        FIM_ENTER_EXCLUSIVE_AREA();

        FiM_FidInhibitCounter[Fid]++;

        /* Exit the critical section */
        FIM_EXIT_EXCLUSIVE_AREA();
      }
    }
  }

#endif
}

#if (FIM_CONFIG_ACCESS == FIM_CONFIG_ACCESS_EVENT)
STATIC FUNC(Std_ReturnType, FIM_CODE) FiM_EventSearch(
  Dem_EventIdType                                EventId,
  P2VAR(FiM_IndexType, AUTOMATIC, FIM_APPL_DATA) EvtIdx)
{
  /* variable low, high, mid types are signed, because the variable high can get negative value for
   * the case when EventId is not configured to any FID and is smaller than the smallest EventId
   * configured in FiM */
  sint32_least low = 0;
  /* highest index is used to calculate the amount of associated FIDs,
   * therefore the last entry is not included in this search */
  sint32_least high = (sint32_least)(FIM_EVT_STARTINDEX_NUM - 2U);
  sint32_least mid = low;
  Std_ReturnType RetVal;

  /* binary searching begins */
  while ((low <= high) && (EventId != FIM_CONFIG_EVENT_ID(mid)))
  {
    mid = (sint32_least)GET_MID_VALUE(high, low);

    if (EventId < FIM_CONFIG_EVENT_ID(mid))
    {
      high = mid - 1;
    }
    else
    {
      low = mid + 1;
    }
  }

  if (EventId == FIM_CONFIG_EVENT_ID(mid))
  {
    RetVal = E_OK;
    *EvtIdx = (FiM_IndexType)mid;
  }
  else
  {
    RetVal = E_NOT_OK;
  }
  return RetVal;
}
#endif /* (FIM_CONFIG_ACCESS == FIM_CONFIG_ACCESS_EVENT) */

#endif /* (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_ON) */

#if ( (FIM_EVENT_UPDATE_TRIGGERED_BY_DEM == STD_OFF) || \
      (FIM_MODE == FIM_MODE_POLLING_SYNC) )
STATIC FUNC(boolean, FIM_CODE) FiM_CalculateFIDPermission(
  FiM_FunctionIdType Fid)
{
  const FiM_IndexType EventIdxStart = FIM_CONFIG_INDEX(Fid - 1U);
  const FiM_IndexType EventIdxMax = FIM_CONFIG_INDEX(Fid);
  /* Initially set the permission for the FID to permit;
   * Reason: initialization based on algorithm optimization */
  boolean Permission = TRUE;
  FiM_IndexType EventIdx;

  /* Loop through each assigned event */
  for (EventIdx = EventIdxStart; EventIdx < EventIdxMax; EventIdx++)
  {
    const Dem_EventIdType EventId = FIM_CONFIG_EVENT_ID(EventIdx);
    const uint8 InhMaskIdx = FIM_CONFIG_INHIB_MASK_IDX(EventIdx);
    boolean InhibitionPermission = TRUE;

    const Std_ReturnType Result = FiM_CalculateFidLinkPermission(
                                                      Fid,
                                                      EventId,
                                                      InhMaskIdx,
                                                      &InhibitionPermission);

    if ( (Result == E_OK) && (InhibitionPermission == FALSE) )
    {
      Permission = FALSE;

#if (FIM_EXTENDED_LEVEL == FIM_NO_EXTENSION)
      /* No need to calculate all remaining inhibition masks.
       * If FiM is configured with extension, all FIDs need to be calculated in
       * order to handle messages. */
      break;
#endif
    }
  }
  return Permission;
}
#endif

STATIC FUNC(Std_ReturnType, FIM_CODE) FiM_CalculateFidLinkPermission(
   FiM_FunctionIdType                       Fid,
   Dem_EventIdType                          EventId,
   uint8                                    InhMaskIdx,
  CONSTP2VAR(boolean, AUTOMATIC, AUTOMATIC) Permission)
{
  Std_ReturnType Result;
  Dem_EventStatusExtendedType EventStatus;
  boolean InhibitionPermission = TRUE;

#if (FIM_EXTENDED_LEVEL != FIM_EXTENSION_LVL2)
  TS_PARAM_UNUSED(Fid);
#endif

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)
  /* Decide if the extended SI30 status is required */
  if (InhMaskIdx >= FIM_UDS_MASK_COUNT)
  {
    /* Get the current extended SI30 event status of the event */
    Result = Dem_GetSI30Status(EventId, &EventStatus);
  }
  else
#endif
  {
    /* Get the current extended event status of the event */
    Result = Dem_GetEventStatus(EventId, &EventStatus);
  }

  if (E_OK == Result)
  {
    /* Check if the event status matches the inhibition relation */
    if ((EventStatus & FiM_InhMask[InhMaskIdx]) == FiM_InhResult[InhMaskIdx])
    {
      InhibitionPermission = FALSE;
    }

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)
    if (InhibitionPermission == FALSE)
    {
      /* !LINKSTO VCC-FIM-004:Req16v2,1, VCC-FIM-004:Req25v2,1, VCC-FIM-004:Req44v2,1 */
      FiM_SymptomAndNotification(EventId);
    }
#if (FIM_EXTENDED_LEVEL == FIM_EXTENSION_LVL2)
    else
    {
      FiM_Recovery(Fid, EventId, InhMaskIdx);
    }
#endif
#endif

    *Permission = InhibitionPermission;
  }
  /* else: in case of negative return value the inhibition connection shall
   * not be considered, see ASR 4.2.1 - SWS_Fim_00097 */

  return Result;
}

#if (FIM_MODE == FIM_MODE_POLLING_ASYNC)
STATIC FUNC(boolean, FIM_CODE) FiM_GetFidPermissionFlag(FiM_FunctionIdType Fid)
{
  const uint8 FidByteIdx = Fid / 8U;
  const uint8 FidBitIdx = Fid % 8U;
  CONSTP2VAR(uint8, AUTOMATIC, FIM_VAR) FidFlags = &FiM_FidInhibitionFlag[FidByteIdx];
  boolean Permission;

  if (TS_IsBitSet(FidFlags, FidBitIdx, uint8))
  {
    Permission = FALSE;
  }
  else
  {
    Permission = TRUE;
  }
  return Permission;
}

STATIC FUNC(void, FIM_CODE) FiM_SetFidPermissionFlag(
  FiM_FunctionIdType Fid,
  boolean            Permission)
{
  const uint8 FidByteIdx = Fid / 8U;
  const uint8 FidBitIdx = Fid % 8U;
  CONSTP2VAR(uint8, AUTOMATIC, FIM_VAR) FidFlags = &FiM_FidInhibitionFlag[FidByteIdx];

  if (Permission == FALSE)
  {
    TS_AtomicSetBit_8(FidFlags, FidBitIdx);
  }
  else
  {
    TS_AtomicClearBit_8(FidFlags, FidBitIdx);
  }
}
#endif

#if (FIM_EXTENDED_LEVEL != FIM_NO_EXTENSION)

STATIC FUNC(void, FIM_CODE) FiM_SymptomAndNotification(
  Dem_EventIdType EventId)
{
  boolean EvaluateMessage;

  /* !LINKSTO VCC-FIM-004:Req14v2,1 */
  if (FiM_FidData.ConditionEventId == FIM_EVENT_ID_INVALID)
  {
    /* !LINKSTO VCC-FIM-004:Req15v2,1 */
    EvaluateMessage = TRUE;
  }
  else
  {
    /* !LINKSTO VCC-FIM-004:Req41v2,1 */
    EvaluateMessage = FiM_FidData.ConditionEventFailed;
  }

  if (EvaluateMessage == TRUE)
  {
    /* !LINKSTO VCC-FIM-004:Req47v2,1 */
    if (FiM_FidData.SymptomBit == TRUE)
    {
      /* !LINKSTO VCC-FIM-003:Req65v1,1 */
      (void)Dem_SetSI30Symptom(EventId);
    }

    /* !LINKSTO VCC-FIM-004:Req43v2,1 */
    if (FiM_FidData.MessageId != FIM_MESSAGE_INVALID)
    {
      /* !LINKSTO VCC-FIM-003:Req46v1,1 */
      (void)Dem_SetSI30Notification(EventId);

      FiM_MessageHandling = TRUE;
    }
  }
}

#if (FIM_EXTENDED_LEVEL == FIM_EXTENSION_LVL2)
STATIC FUNC(void, FIM_CODE) FiM_Recovery(
  FiM_FunctionIdType Fid,
  Dem_EventIdType    EventId,
  uint8              InhMaskIdx)
{

  /* Condition event check is an optimization:
   * Only in case condition event is not calibrated or set to failed, an
   * action is performed in FiM_SymptomAndNotification() */
  if ( (FiM_FidData.ConditionEventId == FIM_EVENT_ID_INVALID) ||
       (FiM_FidData.ConditionEventFailed == TRUE) )
  {
    if ( (FiM_FidData.RecoveryEventFailed == TRUE) &&
         (FiM_FidInhibitedSinceInit[Fid] == TRUE) )
    {
      Std_ReturnType Result;
      uint8 InhibitionStatus = 0U;

      /* !LINKSTO VCC-FIM-004:Req48v2,1, VCC-FIM-004:Req49v2,1 */

      if ( (InhMaskIdx < FIM_UDS_MASK_COUNT) &&
           (FiM_InhMask[InhMaskIdx] == FIM_LAST_FAILED_MASK) )
      {
        Dem_EventStatusExtendedType EvtStatus;

        Result = Dem_GetEventStatus(EventId, &EvtStatus);

        InhibitionStatus = (uint8)(EvtStatus & DEM_UDS_STATUS_TFTOC);
      }
      else if ( (InhMaskIdx >= FIM_UDS_MASK_COUNT) &&
                (FiM_InhMask[InhMaskIdx] == FIM_LAST_UNCONFIRMED_MASK) )
      {
        uint8 EvtStatus;

        Result = Dem_GetSI30Status(EventId, &EvtStatus);

        InhibitionStatus = (uint8)(EvtStatus & DEM_SI30_STATUS_UNCONFIRMEDDTC_TOC);
      }
      else
      {
        Result = E_NOT_OK;
      }

      if ( (Result == E_OK) && (InhibitionStatus != 0U) )
      {
        /* !LINKSTO VCC-FIM-004:Req14v2,1, VCC-FIM-004:Req44v2,1 */
        FiM_SymptomAndNotification(EventId);
      }
    }
  }
}
#endif

STATIC FUNC(void, FIM_CODE) FiM_SetFidData(FiM_FunctionIdType Fid)
{
  const FiM_IndexType FidIndex = Fid - 1U;

  /* Set global condition event */
  FiM_FidData.ConditionEventId = FIM_CONFIG_CONDITION_EVENTID(FidIndex);
  /* !LINKSTO VCC-FIM-004:Req50v2,1 */
  FiM_FidData.ConditionEventFailed = FALSE;

  if (FiM_FidData.ConditionEventId != FIM_EVENT_ID_INVALID)
  {
    /* !LINKSTO VCC-FIM-004:Req41v2,1 */
    /* Get event failed status of condition event */
    (void)Dem_GetEventFailed(FiM_FidData.ConditionEventId, &FiM_FidData.ConditionEventFailed);
  }

  /* Symptom bit is set to FALSE in case if not configured during generation */
  /* !LINKSTO VCC-FIM-004:Req26v2,1 */
  FiM_FidData.SymptomBit = FIM_CONFIG_SYMPTOM(FidIndex);
  FiM_FidData.MessageId = FIM_CONFIG_MESSAGEID(FidIndex);

  FiM_FidData.ReleaseEventFailed = FALSE;
  /* !LINKSTO VCC-FIM-004:Req51v2,1 */
  FiM_FidData.RecoveryEventFailed = FALSE;

#if (FIM_EXTENDED_LEVEL == FIM_EXTENSION_LVL2)
  /* Set global release event */
  FiM_FidData.ReleaseEventId = FIM_CONFIG_FORCE_RELEASE_EVENTID(FidIndex);

  if (FiM_FidData.ReleaseEventId != FIM_EVENT_ID_INVALID)
  {
    /* !LINKSTO VCC-FIM-003:Req23v1,1 */
    /* Get event failed status of release event */
    (void)Dem_GetEventFailed(FiM_FidData.ReleaseEventId, &FiM_FidData.ReleaseEventFailed);
  }

  /* Set global recovery event */
  FiM_FidData.RecoveryEventId = FIM_CONFIG_RECOVERY_EVENTID(FidIndex);

  if (FiM_FidData.RecoveryEventId != FIM_EVENT_ID_INVALID)
  {
    /* !LINKSTO VCC-FIM-004:Req24v2,1 */
    /* Get event failed status of recovery event */
    (void)Dem_GetEventFailed(FiM_FidData.RecoveryEventId, &FiM_FidData.RecoveryEventFailed);
  }
#endif /* FIM_EXTENDED_LEVEL == FIM_EXTENSION_LVL2 */
}

#endif

#define FIM_STOP_SEC_CODE
#include <FiM_MemMap.h>

/*==================[end of file]===========================================*/
