"""
 Copyright (C) Elektrobit Automotive GmbH
 All rights exclusively reserved for Elektrobit Automotive GmbH,
 unless expressly agreed to otherwise.
"""

import os
from lxml import etree
import argparse
from graphviz import Digraph
from collections import OrderedDict

from .imports import *

__nodes = {}
__connections = {}
__clusters = OrderedDict()
__all_name_elements = {}
__legend_cluster = None

__parser = argparse.ArgumentParser()
# Add default options
__parser.add_argument("-i", "--input", required=True, help="Provide path to the Rte model file")
__parser.add_argument("-o", "--output", required=True, help="Output folder where the graph needs to be generated")


def get_model_root():
    """
    :return: the root node of the Rte xml model
    """ 
    tree = etree.parse(__parser.parse_args().input)
    elements = tree.findall('//*[@id]')
    global __all_name_elements
    __all_name_elements = {elements[i].get("id") : elements[i] for i in range(0, len(elements))}
    return tree.getroot()


def new_cluster(id, label, color = "#FFFFFF"):
    """
    Create a new cluster with the given arguments
    :param id: id of the cluster
    :param label: label to added in the generated graph
    :param color: color to be generated in the graph
    :return: newly created cluster
    """
    return Cluster(id, label, color)


def get_or_create_cluster(id, label, color = "#FFFFFF"):
    """
    Gets a cluster with the given id if it already exist, 
    else creates a new one.
    :param id: id of the cluster
    :param label: label to added in the generated graph
    :param color: color to be generated in the graph
    :return: an already existing cluster with this id or the new created one
    """
    if id in __clusters.keys():
        return __clusters[id]
    __clusters[id] = new_cluster(id, label, color)
    return __clusters[id]


def get_or_create_node(cluster, xmlelement, properties, shape = None, color = None, additionaltext = None, fontcolor = BLACK):
    """
    Gets a Node for the given xml element if already exist,
    else creates a new Node and uses the passed property names 
    as label in the diagram
    :param cluster: cluster to add the node to
    :param xmlelement: xml element that contains info to create this node
    :param properties: info from xml to add the node
    :param shape: shape of the node
    :param color: color of the node
    :param additionaltext: text to be added after the properties
    :param fontcolor: color of the text of the node
    :return: either the already existing node or the newly created one
    """ 
    return Node.get_or_create_node(__nodes, cluster, xmlelement, properties, shape, color, additionaltext, fontcolor)


def get_or_create_node_with_customized_id(customizedid, cluster, xmlelement=None, properties={}, shape = None, color = None, additionaltext = None, fontcolor = None):
    """
    Gets a Node for the given customizedid if already exist,
    else creates a new Node
    :param customizedid: custom id of the node 
    :param cluster: cluster to add the node to
    :param xmlelement: xml element that contains info to create this node
    :param properties: info from xml to add the node
    :param shape: shape of the node
    :param color: color of the node
    :param additionaltext: text to be added after the properties
    :param fontcolor: color of the text of the node
    :return: either the already existing node or the newly created one
    """
    return Node.get_or_create_node_with_customized_id(customizedid, __nodes, cluster, xmlelement, properties, shape, color, additionaltext, fontcolor)


def connect(src, dest, cluster, label = None, color = BLACK, style = None):
    """
    Creates connection between the 2 given nodes.
    :param src: source node of the connection
    :param dest: destination node of the connection
    :param cluster: cluster that will contain this connection
    :param label: label to be added on the connection (edge)
    :param color: color of the connection (edge)
    :param style: style of the connection (edge)
    """
    connection = Connection(src, dest, label if(label is not None) else "", color, style = style)
    if (src.id + '_' + dest.id + '_' + cluster.id) not in __connections:
        __connections[src.id + '_' + dest.id + '_' + cluster.id] = connection
        cluster.add_connection(connection)


def generate_graph(name, filename, compound='true', rankdir="LR", ranksep="0.2", bgcolor="#F0F0FF", fontcolor="#0000A0", fontsize="13"):
    """
    generates the graph for all the clusters in a single svg.
    :param name: name of the graph element (added as a comment in the generated graph file)
    :param filename: the file name to be generated
    :param compound: if true to allow edges between different clusters
    :param rankdir: set the direction of the graph layout
    :param ranksep: This is the minimum vertical distance between the bottom of the nodes 
    in one rank and the tops of nodes in the next
    :param bgcolor: background color of the generated graph
    :param fontcolor: the color used for text
    :param fontsize: font size used for text
    """
    global __legend_cluster
    maingraph = Digraph(comment=name)
    maingraph.attr(compound=compound, rankdir=rankdir, ranksep=ranksep, bgcolor=bgcolor, fontcolor=fontcolor, fontsize=fontsize, label=name)
    __legend_cluster.generate(maingraph) # Adds the legend

    for cluster in __clusters.values():
        if cluster is not __legend_cluster:
            cluster.generate(maingraph)

    ## Need the dot to be added to the enviroment variable to be able to generate the svg directly from the python script
    ## so the default should be the dot and then generate the svg from the merged make file
    maingraph.format = 'svg'
    maingraph.render(os.path.join(__parser.parse_args().output, filename), view=False)


def generate_graph_per_cluster(name, fileName, compound='true', rankdir="LR", ranksep="0.2", bgcolor="#F0F0FF", fontcolor="#0000A0", fontsize="13"):
    """
    generates a graph(svg) for each main cluster
    :param name: name of the graph element (added as a comment in the generated graph file)
    :param filename: the file name to be generated
    :param compound: if true to allow edges between different clusters
    :param rankdir: set the direction of the graph layout
    :param ranksep: This is the minimum vertical distance between the bottom of the nodes 
    in one rank and the tops of nodes in the next
    :param bgcolor: background color of the generated graph
    :param fontcolor: the color used for text
    :param fontsize: font size used for text
    """
    global __legend_cluster
    for cluster in __clusters.values():
        if cluster is not __legend_cluster:
            maingraph = Digraph(comment=cluster.label)
            maingraph.attr(compound=compound, rankdir=rankdir, ranksep=ranksep, bgcolor=bgcolor, fontcolor=fontcolor, fontsize=fontsize, label=cluster.label)
            __legend_cluster.generate(maingraph) # Adds the legend
            cluster.generate(maingraph) # Add the cluster
            maingraph.format = 'svg'
            maingraph.render(os.path.join(__parser.parse_args().output, fileName + "-" + cluster.label), view=False)


def reset():
    """
    resets all the created clusters, connections and nodes
    """
    __nodes.clear()
    __connections.clear()
    __clusters.clear()


def get_element_by_id(elementid):
    """
    get xml element by its id
    :param elementid: the id of the xml element to return
    :return: the element that have this id and None otherwise
    """
    return __all_name_elements[elementid] if elementid in __all_name_elements else None


def add_legend(name, color, shape, fontcolor):
    """
    Add legend to the generated graph. This is helpful when 
    there are multiple shapes/colors in a graph and can be used
    to identify each one of them.
    :param name: name of the legend (task, runnable,...etc)
    :param color: color of the legend node
    :param shape: shape of the legend node
    :param fontcolor: the color of the font for the legend node
    """
    global __legend_cluster
    if __legend_cluster == None:
        __legend_cluster = new_cluster('-1', 'Legend for shapes in the diagram')
        __clusters['-1'] = __legend_cluster
    if len(__legend_cluster._nodes) > 0:
        last_node = __legend_cluster._get_last_added_node()
    legend_node = Node.get_or_create_node_with_customized_id(name + '_legend_node', __nodes, __legend_cluster, shape=shape, color=color, additionaltext=name, fontcolor=fontcolor)
    if len(__legend_cluster._nodes) > 1:
        connect(legend_node, last_node, __legend_cluster, style="invis")
    __legend_cluster.add_node(legend_node)


def add_option(short_text, long_text, is_required=False, help='', argument_required_for_option=False):
    """
    Adds the options to be processed from the commandline arguments.
    Note: The default options <-i/--input> and <-o/--output> are
    automically added.
    :param short_text: short text for the option. for eg: -h
    :param long_text: long text for the option. for eg: --help
    :param is_required: If the option is mandatory
    :param help: Help text for the user
    :param argument_required_for_option : If an argument is required for this option.
    """
    __parser.add_argument(short_text, long_text, required=is_required, help=help, action=('store_true' if argument_required_for_option is False else None))


def process_args():
    """
    Returns the parsed arguments
    """
    return __parser.parse_args()
