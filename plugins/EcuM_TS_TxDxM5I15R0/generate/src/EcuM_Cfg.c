/**
 * \file
 *
 * \brief AUTOSAR EcuM
 *
 * This file contains the implementation of the AUTOSAR
 * module EcuM.
 *
 * \version 5.15.7
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2021 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
[!AUTOSPACING!][!//
/* !LINKSTO EcuM.Config.EcuMMainFunctionPeriod, 1 */
[!VAR "EcuMPeriodMainFunction"="EcuMGeneral/EcuMMainFunctionPeriod"!][!//

[!VAR "NrComMChannel" = "num:i(count(node:refs(as:modconf('EcuM')[1]/EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMWakeupSource/*/EcuMComMChannelRef)))"!]
[!VAR "NrComMPNC" = "num:i(count(node:refs(as:modconf('EcuM')[1]/EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMWakeupSource/*/EcuMComMPNCRef)))"!]
[!VAR "CROSSCORECOMMWAKEUP" = "as:modconf('EcuM')[1]/EcuMGeneral/EcuMCrossCoreComMWakeup = 'true'"!]

[!VAR "MULTICORE_ENABLED" = "node:exists(as:modconf('Os')[1]/OsOS/OsNumberOfCores) and node:value(as:modconf('Os')/OsOS/OsNumberOfCores) > 1 and node:value(as:modconf('EcuM')/EcuMGeneral/EcuMEnableMulticore) = 'true'"!]
[!IF "$MULTICORE_ENABLED"!]
[!VAR "MULTICORE_NUM_CORES" = "node:value(as:modconf('Os')[1]/OsOS/OsNumberOfCores)"!]
[!ELSE!][!//
[!VAR "MULTICORE_NUM_CORES" = "1"!]
[!ENDIF!]

[!IF "node:exists(as:modconf('EcuM')/EcuMGeneral/EcuMMasterCoreId)"!][!//
[!VAR "ECUM_MASTER_CORE_ID" = "node:value(as:modconf('EcuM')/EcuMGeneral/EcuMMasterCoreId)"!][!//
[!ELSE!][!//
[!VAR "ECUM_MASTER_CORE_ID" = "'0'"!][!//
[!ENDIF!][!//

[!VAR "START_INITIAL_CORE" = "node:exists(as:modconf('EcuM')/EcuMGeneral/EcuMStartInitialCore) and node:value(as:modconf('EcuM')/EcuMGeneral/EcuMStartInitialCore) = 'true'"!]

[!VAR "EcuM_Stored_Shutdown_Operations" = "node:value(as:modconf('EcuM')/EcuMFlexGeneral/EcuMStoredShutdownOperations)"!]
/*==================[inclusions]============================================*/

#include <Mcu.h>          /* MCU module types                  */
/* Macro for preventing redundant declarations of EcuM_MainFunction(),
 * since the function prototype is also generated by the SchM. */
#define ECUM_INTERNAL_USE
#include <EcuM.h>
#include <EcuM_Int.h>     /* EcuM private header               */
#include <EcuM_Cfg.h>
#include <SchM_EcuM.h>           /* SchM API for EcuM */
[!IF "$MULTICORE_ENABLED"!]
[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
  [!IF "$Index != $ECUM_MASTER_CORE_ID"!]
#include <SchM_EcuM_1_Core_[!"num:i($Index)"!].h>
  [!ENDIF!]
[!ENDFOR!]
[!ENDIF!]

[!VAR "ModuleList"="' Mcu '"!]
[!LOOP "(EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMDriverInitListZero/EcuMDriverInitItem/*) | (EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMDriverInitListOne/EcuMDriverInitItem/*) | (EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMDriverRestartList/EcuMDriverInitItem/*)"!][!//
[!/*
    Check VendorApiInfix is enabled for this module, If enabled, then add
    header file <EcuMModuleID>_<VendorId>_<VendorApiInfix>.h.
    Check if module header file was specified by the user, else
    include ModuleId.h
    Only generate unique include directives, check if module ID/module header Id
    was not encontered before
*/!][!//
[!IF "node:exists(./EcuMEnableVendorApiInfix) and (./EcuMEnableVendorApiInfix) = 'true' and node:empty(./EcuMModuleHeaderFile)"!][!//
[!VAR "ModuleRef" = "as:path(as:ref(../../../../EcuMFlexConfiguration/EcuMFlexModuleConfigurationRef/*[starts-with(node:value(.),concat('ASPath:/',node:value(node:current()/EcuMModuleID),'/'))]))"!][!//
[!VAR "VendorID"= "node:value(as:ref($ModuleRef)/../../CommonPublishedInformation/VendorId)"!][!//
[!VAR "VendorApiInfx"= "node:value(as:ref($ModuleRef)/../../CommonPublishedInformation/VendorApiInfix)"!][!//
[!VAR "ModuleId"="name(as:ref($ModuleRef)/../../.)"!][!//
#include <[!"$ModuleId"!]_[!"$VendorID"!]_[!"$VendorApiInfx"!].h>
[!ELSE!][!//
[!IF "node:empty(./EcuMModuleHeaderFile)"!][!//
  [!IF "not(contains($ModuleList,concat(' ',./EcuMModuleID,' ')))"!][!//
#include <[!"./EcuMModuleID"!].h>
    [!VAR "ModuleList"="concat($ModuleList,' ',./EcuMModuleID,' ')"!]
  [!ENDIF!][!//
[!ELSE!][!//
  [!IF "not(contains($ModuleList,concat(' ',./EcuMModuleHeaderFile,' ')))"!][!//
#include <[!"./EcuMModuleHeaderFile"!].h>
    [!VAR "ModuleList"="concat($ModuleList,' ',./EcuMModuleHeaderFile,' ')"!][!//
  [!ENDIF!][!//
[!ENDIF!][!//
[!ENDIF!][!//
[!ENDLOOP!][!//

[!/*
****************************************************************************
* MACRO for generating the body of a function initializing the driver
* module of a driver initialization list
****************************************************************************
*/!][!//
[!MACRO "InitializeDriver","DriverListRef","PbConfigMember"!][!//
    switch (id)
    {
[!LOOP "as:ref($DriverListRef)/EcuMDriverInitItem/*"!][!//
      case [!"@index"!]:
      {
        /* *** Call service [!"EcuMModuleService"!] of module [!"EcuMModuleID"!] *** */
[!VAR "RefSubString"="concat('/',EcuMModuleID,'/',EcuMModuleID,'/')"!][!//
[!IF "node:exists(./EcuMEnableVendorApiInfix) and ./EcuMEnableVendorApiInfix = 'true'"!][!//
[!VAR "RefSubString"="concat('/',EcuMModuleID,'/')"!][!//
[!VAR "ModuleRef" = "as:path(as:ref(../../../../EcuMFlexConfiguration/EcuMFlexModuleConfigurationRef/*[starts-with(node:value(.),concat('ASPath:/',node:value(node:current()/EcuMModuleID),'/'))]))"!][!//
[!VAR "VendorID"= "node:value(as:ref($ModuleRef)/../../CommonPublishedInformation/VendorId)"!][!//
[!VAR "VendorApiInfx"= "node:value(as:ref($ModuleRef)/../../CommonPublishedInformation/VendorApiInfix)"!][!//
[!VAR "ModuleId"="name(as:ref($ModuleRef)/../../.)"!][!//
        [!"$ModuleId"!]_[!"$VendorID"!]_[!"$VendorApiInfx"!]_[!"EcuMModuleService"!]([!//
[!ELSE!][!//
        [!"EcuMModuleID"!]_[!"EcuMModuleService"!]([!//
[!ENDIF!][!//
[!IF "node:exists(EcuMModuleInitConfigStr) and (string-length(EcuMModuleInitConfigStr) > 0)"!][!//
[!/* Generate function argument even for non-Init services. For user provided
   * modules the name of the init function may not be equal to 'Init', Studio
   * displays a warning in this case. */!][!//
[!"EcuMModuleInitConfigStr"!][!//
[!ELSEIF "((EcuMModuleService = 'Init') or (EcuMModuleService = 'PreInit')) and (count(../../../../EcuMFlexConfiguration/EcuMFlexModuleConfigurationRef/*[contains(.,$RefSubString)]) > 0)"!][!//
&[!"name(as:ref(../../../../EcuMFlexConfiguration/EcuMFlexModuleConfigurationRef/*[contains(.,$RefSubString)]))"!][!//
[!ELSE!][!//
[!/* generate no function argument */!][!//
[!ENDIF!]
);
        break;
      }
  [!ENDLOOP!][!//
      default:
      {
        /* No driver configured. */
        break;
      }
    }
[!ENDMACRO!][!//

[!SELECT "EcuMConfiguration/*[1]/EcuMCommonConfiguration"!][!//

/*------------------[MultiCore variables]-----------------------------------------------*/

[!VAR "MULTICORE_ENABLED" = "node:exists(as:modconf('Os')[1]/OsOS/OsNumberOfCores) and node:value(as:modconf('Os')/OsOS/OsNumberOfCores) > 1 and node:value(as:modconf('EcuM')/EcuMGeneral/EcuMEnableMulticore) = 'true'"!]
[!IF "$MULTICORE_ENABLED"!]
[!VAR "MULTICORE_NUM_CORES" = "node:value(as:modconf('Os')[1]/OsOS/OsNumberOfCores)"!]
[!ELSE!][!//
[!VAR "MULTICORE_NUM_CORES" = "1"!]
[!ENDIF!]

#if(defined ECUM_GET_CORE_ID)
#error ECUM_GET_CORE_ID already defined
#endif
#if (ECUM_MULTICORE_ENABLED == TRUE)
/** \brief Returns the core ID that is currently active. */
#define ECUM_GET_CORE_ID() GetCoreID()
#else
#define ECUM_GET_CORE_ID() 0U
#endif /* (ECUM_MULTICORE_ENABLED == TRUE) */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_[!"num:i($Index)"!] (void);
STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_[!"num:i($Index)"!] (void);
[!ENDFOR!]

[!IF "node:exists(EcuMDriverInitListOne)"!]
STATIC FUNC(void, ECUM_CODE) EcuM_DriverInitListOneCall(uint8 id);
[!ENDIF!]
[!IF "node:exists(EcuMDriverRestartList)"!]
STATIC FUNC(void, ECUM_CODE) EcuM_DriverRestartListCall(uint8 id);
[!ENDIF!]

#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

/*==================[external constants]====================================*/
#define ECUM_START_SEC_CONST_8
#include <EcuM_MemMap.h>

/* Wake-up Source ID mapping */
CONST(uint8, ECUM_CONST) EcuM_WksMapping[ECUM_WKS_ID_MAXVAL + 1U] =
{
[!VAR "Index" = "0"!]
[!FOR "i" = "0" TO "num:max(EcuMWakeupSource/*/EcuMWakeupSourceId)"!]
  [!IF "node:exists(EcuMWakeupSource/*[EcuMWakeupSourceId = num:i($i)])"!]
  [!"num:i($Index)"!]U,
  [!VAR "Index" = "$Index + 1"!]
  [!ELSE!]
  ECUM_WKS_INVALID_ID,
  [!ENDIF!]
[!ENDFOR!]
};

[!IF "($MULTICORE_ENABLED = 'true') and ($CROSSCORECOMMWAKEUP = 'true')"!]
[!IF "$NrComMChannel > 0"!]
CONST(uint8, ECUM_CONST) EcuM_ComM_Channel_Translation[ECUM_COMM_CHANNELS_NUMBER] = 
{
[!LOOP "node:order(node:refs(as:modconf('EcuM')[1]/EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMWakeupSource/*/EcuMComMChannelRef), 'ComMChannelId')"!]
 [!"ComMChannelId"!],
[!ENDLOOP!]

};
[!ENDIF!]

[!IF "$NrComMPNC > 0"!]
CONST(uint8, ECUM_CONST) EcuM_ComM_Pnc_Translation[ECUM_COMM_PNC_NUMBER] = 
{
[!LOOP "node:order(node:refs(as:modconf('EcuM')[1]/EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMWakeupSource/*/EcuMComMPNCRef), 'ComMPncId')"!]
  [!"ComMPncId"!],
[!ENDLOOP!]
};
[!ENDIF!]
[!ENDIF!]
#define ECUM_STOP_SEC_CONST_8
#include <EcuM_MemMap.h>


#define ECUM_START_SEC_CONST_16
#include <EcuM_MemMap.h>

/* !LINKSTO EcuM4004,1 */
/* timeout for wakeup source */
CONST(uint16, ECUM_CONST) EcuM_WksValTimeout[ECUM_WKSCONFIGNUM] =
{
[!LOOP "node:order(EcuMWakeupSource/*, 'EcuMWakeupSourceId')"!]
  [!"num:i(EcuMValidationTimeout div $EcuMPeriodMainFunction)"!]U, /* Timeout for wakeup source [!"name(.)"!] */
[!ENDLOOP!]
};

#define ECUM_STOP_SEC_CONST_16
#include <EcuM_MemMap.h>

#define ECUM_START_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>


/*------------------[Wakeup Sources]----------------------------------------*/

/* configurations of Wakeup Sources */
CONST(EcuM_WksConfigType, ECUM_CONST) EcuM_WksConfigList[ECUM_WKSCONFIGNUM] =
{
/* !LINKSTO EcuM2166,1 */
[!LOOP "node:order(EcuMWakeupSource/*, 'EcuMWakeupSourceId')"!]
  /* [!"name(.)"!] */
  {
  [!IF "node:refexists(EcuMComMPNCRef)"!]
    [!"num:i(as:ref(EcuMComMPNCRef)/ComMPncId)"!]U,   /* ComM PNC Id */
  [!ELSE!]
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
  [!ENDIF!]
  [!IF "node:refexists(EcuMComMChannelRef)"!]
    [!"num:i(as:ref(EcuMComMChannelRef)/ComMChannelId)"!]U,   /* ComM Channel Id */
  [!ELSE!]
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
  [!ENDIF!]
  [!IF "node:refexists(EcuMResetReasonRef)"!]
    [!"name(as:ref(EcuMResetReasonRef)/McuResetReason/..)"!],   /* Reset Reason */
  [!ELSE!]
    MCU_RESET_UNDEFINED,   /* No valid Reset Reason */
  [!ENDIF!]
    [!"num:i(EcuMWakeupSourceId)"!]U   /* Wakeup Source Id */
  },
[!ENDLOOP!]
};

/*------------------[Sleep Modes]-------------------------------------------*/
CONST(EcuM_SleepModeConfigType, ECUM_CONST) EcuM_SleepModeConfigList[ECUM_SLEEPMODECONFIGNUM] =
{

[!LOOP "node:order(EcuMSleepMode/*,'node:value(EcuMSleepModeId)')"!][!//
  {
[!INDENT "4"!][!//
    [!//An xdm check ensures that the reference is valid for EcuMSleepModeMcuModeRef.
    ECUM_[!"name(.)"!]_WKUP_MASK, /* Wakeup event mask of sleep mode [!"name(.)"!] */
    /* Sleep mode: [!"name(.)"!], ID: [!"EcuMSleepModeId"!] */
#if (defined [!//
    McuConf_[!"node:name(node:dtos(as:ref(./EcuMSleepModeMcuModeRef)))"!]_[!"as:name(as:ref(EcuMSleepModeMcuModeRef))"!])
    McuConf_[!"node:name(node:dtos(as:ref(./EcuMSleepModeMcuModeRef)))"!]_[!"as:name(as:ref(EcuMSleepModeMcuModeRef))"!],
#else
    [!"as:name(as:ref(EcuMSleepModeMcuModeRef))"!],
#endif
    [!IF "EcuMSleepModeSuspend = 'true'"!]TRUE[!ELSE!]FALSE[!ENDIF!] /* Suspend flag */
    [!ENDINDENT!]
  },
[!ENDLOOP!]

};

/*------------------[Errors reporting to Dem]-------------------------------------------*/

[!IF "../../../EcuMGeneral/EcuMIncludeDem = 'true'"!][!//
  [!IF "../../../ReportToDem/EcuMRamChkFailedReportToDem = 'DEM'"!][!//
CONST(Dem_EventIdType, ECUM_CONST) EcuM_DemErrRamChkFailed =
  [!"num:i(as:ref(EcuMDemEventParameterRefs/ECUM_E_RAM_CHECK_FAILED)/DemEventId)"!]U;[!//
  /* Error for Ram check failure */
  [!ENDIF!][!//

  [!IF "node:exists(../../../EcuMConfiguration/*[1]/EcuMFixedConfiguration) = 'true'"!][!//
    [!IF "node:exists(EcuMDemEventParameterRefs/ECUM_E_ALL_RUN_REQUESTS_KILLED)"!][!//
CONST(Dem_EventIdType, ECUM_CONST) EcuM_DemErrAllRUNRequestsKilled =
  [!"num:i(as:ref(EcuMDemEventParameterRefs/ECUM_E_ALL_RUN_REQUESTS_KILLED)/DemEventId)"!]U;[!//
    [!ENDIF!][!//
  [!ENDIF!][!//
[!ELSE!][!//
  /* Errors cannot be reported to DEM since DEM is not includded */
[!ENDIF!][!//
[!ENDSELECT!][!//

#define ECUM_STOP_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>

#define ECUM_START_SEC_CONST_8
#include <EcuM_MemMap.h>

/*------------------[EcuMShutdownCause]-------------------------------------------*/

#if (ECUM_DEV_ERROR_DETECT == STD_ON)
/* Array holding the configured values of Shutdown Causes */
CONST(EcuM_ShutdownCauseType, ECUM_CONST)
   EcuM_ValidShutdownCause[ECUM_SHUTDOWNCAUSECONFIGNUM] =
{
[!SELECT "EcuMConfiguration/*[1]/EcuMFlexConfiguration"!][!//
[!LOOP "EcuMShutdownCause/*"!][!//
  EcuMConf_[!"name(..)"!]_[!"name(.)"!],
[!ENDLOOP!][!//
[!ENDSELECT!]
};
#endif

#define ECUM_STOP_SEC_CONST_8
#include <EcuM_MemMap.h> 

#define ECUM_START_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>
/** \brief The initial core context for a single core. */
CONST(EcuM_CoreContextType, ECUM_CONST) EcuM_InitialContext =
{
  {
    /* WAKEUP STATUS */
    ECUM_WKSMASKALL,  /* Disabled */
    0U, /* None */
    0U, /* Pending */
    0U, /* Validated */
    0U, /* Expired */
    0U, /* Started */
    0U, /* Stopped */
  },
  {
    /* WAKEUP INDICATION */
    0U, /* Disabled */
    0U, /* Expired */
    0U, /* None */
    0U, /* Pending */
    0U, /* Validated */
  },
  0U, /* WAKEUP SOURCE VALIDATION COUNTER */
  0U, /* EcuM State */
  0U,  /* EcuM Sleep Mode */
[!IF "($MULTICORE_ENABLED = 'true') and ($CROSSCORECOMMWAKEUP = 'true')"!]
[!IF "$NrComMChannel > 0"!]
  {
    /* ComMChannelCall */
    [!FOR "Index" = "1" TO "num:i((($NrComMChannel - 1) div 8) + 1)"!]
    0,
    [!ENDFOR!]
  },
[!ENDIF!]
[!IF "$NrComMPNC > 0"!]
  {
    /* ComMPNCCall */
    [!FOR "Index" = "1" TO "num:i((($NrComMPNC - 1) div 8) + 1)"!]
    0,
    [!ENDFOR!]
  }
[!ENDIF!]
[!ENDIF!]
};

[!IF "($MULTICORE_ENABLED = 'true') and ($CROSSCORECOMMWAKEUP = 'true')"!]
[!IF "$NrComMChannel > 0"!]
/** \brief The SchM function pointer list for Channels. */
CONST(EcuM_ComMWakeupType, ECUM_CONST) EcuM_ComM_Channel_WakeupList[ECUM_COMM_CHANNELS_NUMBER] =
{
[!LOOP "node:order(node:refs(as:modconf('EcuM')[1]/EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMWakeupSource/*/EcuMComMChannelRef), 'ComMChannelId')"!]
  {
    {
[!FOR "Index" = "0" TO "node:value(as:modconf('Os')[1]/OsOS/OsNumberOfCores) - 1"!]
  [!IF "$Index = $ECUM_MASTER_CORE_ID"!]
      SchM_Call_EcuM_RequiredCSEntry_ComM_EcuM_WakeUpIndication_[!"node:name(.)"!]_Core_[!"$Index"!],
  [!ELSE!]
      SchM_Call_EcuM_1_Core_[!"num:i($Index)"!]_RequiredCSEntry_ComM_EcuM_WakeUpIndication_[!"node:name(.)"!]_Core_[!"$Index"!],
  [!ENDIF!]
[!ENDFOR!]  
    }
  },  
[!ENDLOOP!]
};
[!ENDIF!]

[!IF "$NrComMPNC > 0"!]
/** \brief The SchM function pointer list for Pncs. */
CONST(EcuM_ComMPNCWakeupType, ECUM_CONST) EcuM_ComM_PNC_WakeupList[ECUM_COMM_PNC_NUMBER] =
{
[!LOOP "node:order(node:refs(as:modconf('EcuM')[1]/EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMWakeupSource/*/EcuMComMPNCRef), 'ComMPncId')"!]
  {
    {
[!FOR "Index" = "0" TO "node:value(as:modconf('Os')[1]/OsOS/OsNumberOfCores) - 1"!]
  [!IF "$Index = $ECUM_MASTER_CORE_ID"!]
      SchM_Call_EcuM_RequiredCSEntry_ComM_EcuM_PNCWakeUpIndication_[!"node:name(.)"!]_Core_[!"$Index"!],
  [!ELSE!]
      SchM_Call_EcuM_1_Core_[!"num:i($Index)"!]_RequiredCSEntry_ComM_EcuM_PNCWakeUpIndication_[!"node:name(.)"!]_Core_[!"$Index"!],
  [!ENDIF!]
[!ENDFOR!]  
    }
  },  
[!ENDLOOP!]
};
[!ENDIF!]
[!ENDIF!]

#define ECUM_STOP_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>
/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*------------[EcuM Multi-Core internal data]---------------*/

/* !LINKSTO EcuM.Impl.MemoryMapping.InstanceData,1 */
[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
  [!IF "$Index = $ECUM_MASTER_CORE_ID"!]
#define ECUM_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_MemMap.h>

/** \brief The EcuM core specific context data.
 **
 ** This variable holds the core-specific run time data of the EcuM
 ** master core. */
STATIC VAR(EcuM_CoreContextType, ECUM_VAR) EcuM_Core[!"num:i($Index)"!]_Context;

#define ECUM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_MemMap.h>

  [!ELSE!]
#define ECUM_1_Core_[!"num:i($Index)"!]_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_1_Core_[!"num:i($Index)"!]_MemMap.h>

/** \brief The EcuM core specific context data.
 **
 ** This variable holds the core-specific run time data of each EcuM
 ** slave core. */
STATIC VAR(EcuM_CoreContextType, ECUM_VAR) EcuM_Core[!"num:i($Index)"!]_Context;

#define ECUM_1_Core_[!"num:i($Index)"!]_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_1_Core_[!"num:i($Index)"!]_MemMap.h>

  [!ENDIF!]
[!ENDFOR!][!//

#define ECUM_START_SEC_INTERNAL_VAR_POWER_ON_INIT_UNSPECIFIED
#include <EcuM_MemMap.h>

VAR(EcuM_ShutdownInfoType, ECUM_VAR_POWER_ON_INIT)
  EcuM_ShutdownInfo[ECUM_STORED_SHUTDOWN_OPERATIONS] = {
  [!FOR "Index" = "0" TO "$EcuM_Stored_Shutdown_Operations - 1"!]
    [!IF "$Index != ($EcuM_Stored_Shutdown_Operations - 1)"!]
    {0U, 0U, 0U, 0U},
    [!ELSE!]
    {0U, 0U, 0U, 0U}
    [!ENDIF!]
  [!ENDFOR!]
  };

#define ECUM_STOP_SEC_INTERNAL_VAR_POWER_ON_INIT_UNSPECIFIED
#include <EcuM_MemMap.h>

/*==================[external function definitions]=========================*/
#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>
/*------------------[Callouts from STARTUP state]---------------------------*/

[!IF "node:exists(EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMDriverInitListZero)"!][!//
/* Configured Initialization List Zero items */
FUNC(void, ECUM_CODE) EcuM_DefaultInitListZero(void)
{
[!LOOP "EcuMConfiguration/*[1]/EcuMCommonConfiguration/EcuMDriverInitListZero/EcuMDriverInitItem/*"!][!//
  /* *** Call service [!"EcuMModuleService"!] of module [!"EcuMModuleID"!] *** */
[!VAR "RefSubString"="concat('/',EcuMModuleID,'/',EcuMModuleID,'/')"!][!//
[!IF "node:exists(./EcuMEnableVendorApiInfix) and ./EcuMEnableVendorApiInfix = 'true'"!][!//
[!VAR "RefSubString"="concat('/',EcuMModuleID,'/')"!][!//
[!VAR "ModuleRef" = "as:path(as:ref(../../../../EcuMFlexConfiguration/EcuMFlexModuleConfigurationRef/*[starts-with(node:value(.),concat('ASPath:/',node:value(node:current()/EcuMModuleID),'/'))]))"!][!//
[!VAR "VendorID"= "node:value(as:ref($ModuleRef)/../../CommonPublishedInformation/VendorId)"!][!//
[!VAR "VendorApiInfx"= "node:value(as:ref($ModuleRef)/../../CommonPublishedInformation/VendorApiInfix)"!][!//
[!VAR "ModuleId"="name(as:ref($ModuleRef)/../../.)"!][!//
  [!"$ModuleId"!]_[!"$VendorID"!]_[!"$VendorApiInfx"!]_[!"EcuMModuleService"!]([!//
[!ELSE!][!//
  [!"EcuMModuleID"!]_[!"EcuMModuleService"!]([!//
[!ENDIF!][!//
[!IF "node:exists(EcuMModuleInitConfigStr) and (string-length(EcuMModuleInitConfigStr) > 0)"!][!//
[!/* Generate function argument even for non-Init services. For user provided
   * modules the name of the init function may not be equal to 'Init', Studio
   * displays a warning in this case. */!][!//
[!"EcuMModuleInitConfigStr"!][!//
[!ELSEIF "((EcuMModuleService = 'Init') or (EcuMModuleService = 'PreInit')) and (count(../../../../EcuMFlexConfiguration/EcuMFlexModuleConfigurationRef/*[contains(.,$RefSubString)]) > 0)"!][!//
&[!"name(as:ref(../../../../EcuMFlexConfiguration/EcuMFlexModuleConfigurationRef/*[contains(.,$RefSubString)]))"!][!//
[!ELSE!][!//
[!/* generate no function argument */!][!//
[!ENDIF!][!//
);
[!ENDLOOP!][!//
}
[!ELSE!][!//
/* No content for EcuM_AL_DriverInitZero() configured */
[!ENDIF!][!//

[!SELECT "EcuMConfiguration/*[1]/EcuMCommonConfiguration"!][!//

[!IF "node:exists(EcuMDriverInitListOne)"!][!//
/* Configured Initialization List One items */
FUNC(void, ECUM_CODE) EcuM_DefaultInitListOne(void)
{
  uint8 i;

  for (i = 0; i < ECUM_NUM_DRIVERS_INIT_LIST_ONE; i++ )
  {
    EcuM_DriverInitListOneCall(ECUM_DRIVER_INIT_LIST_ONE(i));
  }
}
[!ENDIF!][!//

/*------------------[Callouts from SLEEP state]--------------------------*/
[!IF "node:exists(EcuMDriverRestartList)"!][!//
/* Configured Driver Restart List items */
FUNC(void, ECUM_CODE) EcuM_DefaultRestartList(void)
{
  uint8 i;

  for (i = 0; i < ECUM_NUM_DRIVERS_RESTART_LIST; i++ )
  {
    EcuM_DriverRestartListCall(ECUM_DRIVER_RESTART_LIST(i));
  }
}
[!ENDIF!][!//
[!ENDSELECT!][!//
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>
/*==================[internal function definitions]=========================*/

/*------------[EcuM Multi-Core internal function definitions]---------------*/

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

FUNC(void, ECUM_CODE) EcuM_EnterExclusiveArea(void)
{
[!IF "$MULTICORE_ENABLED"!]
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
    case [!"num:i($Index)"!]:
    {
      EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_[!"num:i($Index)"!]();
      break;
    }
[!ENDFOR!]
    default:
    {
      /* ERROR */
      break;
    }
  }
[!ELSE!]
  EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_0();
[!ENDIF!]
}

FUNC(void, ECUM_CODE) EcuM_ExitExclusiveArea(void)
{
[!IF "$MULTICORE_ENABLED"!]
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
    case [!"num:i($Index)"!]:
    {
      EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_[!"num:i($Index)"!]();
      break;
    }
[!ENDFOR!]
    default:
    {
      /* ERROR */
      break;
    }
  }
[!ELSE!]
  EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_0();
[!ENDIF!]
}

[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_[!"num:i($Index)"!] (void)
{
  /* SchM function has no return value */
  [!IF "$Index != $ECUM_MASTER_CORE_ID"!]
  SchM_Enter_EcuM_1_Core_[!"num:i($Index)"!]_SCHM_ECUM_EXCLUSIVE_AREA_[!"num:i($Index)"!]();
  [!ELSE!]
  SchM_Enter_EcuM_SCHM_ECUM_EXCLUSIVE_AREA_[!"num:i($Index)"!]();
  [!ENDIF!]
}

STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_[!"num:i($Index)"!] (void)
{
  /* SchM function has no return value */
  [!IF "$Index != $ECUM_MASTER_CORE_ID"!]
  SchM_Exit_EcuM_1_Core_[!"num:i($Index)"!]_SCHM_ECUM_EXCLUSIVE_AREA_[!"num:i($Index)"!]();
  [!ELSE!]
  SchM_Exit_EcuM_SCHM_ECUM_EXCLUSIVE_AREA_[!"num:i($Index)"!]();
  [!ENDIF!]
}

[!ENDFOR!]

#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

#if (ECUM_MULTICORE_ENABLED == TRUE)

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

FUNC(void, ECUM_CODE) EcuM_GetResourceScheduler(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
    case [!"num:i($Index)"!]:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)GetResource(RES_SCHEDULER);
#else
      (void)GetResource(RES_SCHEDULER_[!"num:i($Index)"!]);
#endif
      break;
    }
[!ENDFOR!]
    default:
    {
      break;
    }
  }
}

FUNC(void, ECUM_CODE) EcuM_ReleaseResourceScheduler(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
    case [!"num:i($Index)"!]:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)ReleaseResource(RES_SCHEDULER);
#else
      (void)ReleaseResource(RES_SCHEDULER_[!"num:i($Index)"!]);
#endif
      break;
    }
[!ENDFOR!]
    default:
    {
      /* ERROR */
      break;
    }
  }
}

FUNC(Std_ReturnType, ECUM_CODE) EcuM_Send_SlaveCoreReadyPort(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  Std_ReturnType ret = E_NOT_OK;
  Std_ReturnType schMSendResult;

  if (ECUM_CORE_ID_MASTER != coreID)
  {
      switch(coreID)
      {
[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
  [!IF "$Index != $ECUM_MASTER_CORE_ID"!]
        case [!"num:i($Index)"!]:
        {
          schMSendResult = SchM_Send_EcuM_1_Core_[!"num:i($Index)"!]_EcuM_SlaveCoreReadyPort(GetCoreID());
          ret = (schMSendResult == SCHM_E_OK) ? E_OK : E_NOT_OK;
          break;
        }
  [!ENDIF!]
[!ENDFOR!]
        default:
        {
          break;
        }
      }
  }

  return ret;
}

/* !LINKSTO EcuM.Impl.EcuM_MasterCoreSync,1 */
/* !LINKSTO EcuM.Impl.Source.SlaveMasterCoreSync,1 */
FUNC(Std_ReturnType, ECUM_CODE) EcuM_MasterCoreSync(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();
  EcuM_SyncActionType syncResult = ECUM_CONTINUE_SYNC;
  Std_ReturnType schMReceiveResult = E_NOT_OK;

  if (ECUM_CORE_ID_MASTER != coreID)
  {
    boolean EcuM_IsMasterReady = FALSE;
    do
    {
      switch(coreID)
      {
[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
   [!IF "$Index != $ECUM_MASTER_CORE_ID"!]
        case [!"num:i($Index)"!]:
        {
          schMReceiveResult = SchM_Receive_EcuM_1_Core_[!"num:i($Index)"!]_EcuM_MasterCoreSyncPort(&EcuM_IsMasterReady);
          break;
        }
   [!ENDIF!]
[!ENDFOR!]
        default:
        {
          break;
        }
      }
      if (TRUE == EcuM_IsMasterReady)
      {
        break;
      }
      /* !LINKSTO EcuM.Impl.EcuM_OnCoreSync,1 */
      syncResult = EcuM_OnCoreSync();
    } while (syncResult != ECUM_ABORT_SYNC);
  }

  return ((ECUM_CONTINUE_SYNC == syncResult) && (schMReceiveResult == SCHM_E_OK)) ? E_OK : E_NOT_OK;
}
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
  [!IF "$Index != $ECUM_MASTER_CORE_ID"!]
#define ECUM_1_Core_[!"num:i($Index)"!]_START_SEC_CODE
#include <EcuM_1_Core_[!"num:i($Index)"!]_MemMap.h>
FUNC(void, ECUM_1_Core_[!"num:i($Index)"!]_CODE) EcuM_1_Core_[!"num:i($Index)"!]_MainFunction(void)
{
   EcuM_MainFunction();
}
#define ECUM_1_Core_[!"num:i($Index)"!]_STOP_SEC_CODE
#include <EcuM_1_Core_[!"num:i($Index)"!]_MemMap.h>

  [!ENDIF!]
[!ENDFOR!]

#endif /* (ECUM_MULTICORE_ENABLED == TRUE) */

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>
/* !LINKSTO EcuM.Impl.EcuM_GetCoreInstance,1 */
FUNC_P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_CODE) EcuM_GetCoreInstance(void)
{
  P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_APPL_DATA) inst = NULL_PTR;

#if (ECUM_MULTICORE_ENABLED == TRUE)
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
    case [!"num:i($Index)"!]:
    {
      inst = &EcuM_Core[!"num:i($Index)"!]_Context;
      break;
    }
[!ENDFOR!]
    default:
    {
      /* No EcuM instance exists for core. */
      break;
    }
  }
#else
  inst = &EcuM_Core0_Context;
#endif

  return inst;
}

/* !LINKSTO EcuM.Impl.EcuM_GetMasterCoreInstance,1 */
FUNC_P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_CODE) EcuM_GetMasterCoreInstance(void)
{
  return &EcuM_Core[!"$ECUM_MASTER_CORE_ID"!]_Context;
}
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>


[!IF "$MULTICORE_ENABLED"!]
  [!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!]
    [!IF "$Index != $ECUM_MASTER_CORE_ID"!]
#define ECUM_1_Core_[!"num:i($Index)"!]_START_SEC_CODE
#include <EcuM_1_Core_[!"num:i($Index)"!]_MemMap.h>
FUNC(void, ECUM_1_Core_[!"num:i($Index)"!]_CODE) EcuM_1_Core_[!"num:i($Index)"!]_UpdateSleepMode(void)
{
  Std_ReturnType result;

  do
  {
    result = SchM_Receive_EcuM_1_Core_[!"num:i($Index)"!]_EcuM_GetSleepMode(&EcuM_GetCoreInstance()->SleepMode);
  } while (result != SCHM_E_NO_DATA);

}
#define ECUM_1_Core_[!"num:i($Index)"!]_STOP_SEC_CODE
#include <EcuM_1_Core_[!"num:i($Index)"!]_MemMap.h>

    [!ENDIF!]
  [!ENDFOR!]
#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>
FUNC(void, ECUM_CODE) EcuM_StartAllCores(void)
{
[!FOR "Index" = "0" TO "$MULTICORE_NUM_CORES - 1"!][!//
[!IF "$START_INITIAL_CORE = 'false'"!]
  if (OS_CORE_ID_[!"num:i($Index)"!] != ECUM_CORE_ID_INITIAL)
[!ENDIF!]
  {
    StatusType status;
    StartCore(OS_CORE_ID_[!"num:i($Index)"!], &status);
    if (status != E_OK)
    {
      /* !LINKSTO EcuM.Impl.StartedCoreStatus,1 */
      ECUM_DET_REPORT_ERROR(ECUM_SID_INIT, ECUM_E_UNSUCCESSFUL_CORE_START);
    }
  }
[!ENDFOR!]
}
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>
[!ENDIF!]

[!SELECT "EcuMConfiguration/*[1]/EcuMCommonConfiguration"!][!//
[!IF "node:exists(EcuMDriverInitListOne) or node:exists(EcuMDriverRestartList)"!][!//
#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

[!IF "node:exists(EcuMDriverInitListOne)"!][!//
STATIC FUNC(void, ECUM_CODE) EcuM_DriverInitListOneCall(uint8 id)
{
  [!CALL "InitializeDriver","DriverListRef"="as:path(EcuMDriverInitListOne)","PbConfigMember"="'DriverInitOneConfig'"!][!//
}
[!ENDIF!][!//

[!IF "node:exists(EcuMDriverRestartList)"!][!//
STATIC FUNC(void, ECUM_CODE) EcuM_DriverRestartListCall(uint8 id)
{
  [!CALL "InitializeDriver","DriverListRef"="as:path(EcuMDriverRestartList)","PbConfigMember"="'DriverRestartConfig'"!][!//
}
[!ENDIF!][!//

#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>
[!ENDIF!][!//
[!ENDSELECT!][!//

/*==================[end of file]===========================================*/

