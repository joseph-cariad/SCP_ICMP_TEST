/**
 * \file
 *
 * \brief AUTOSAR Dem
 *
 * This file contains the implementation of the AUTOSAR
 * module Dem.
 *
 * \version 6.4.1
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2021 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
#ifndef DEM_CFG_H
#define DEM_CFG_H

/* This file contains all target independent public configuration declarations
 * for the AUTOSAR module Dem. */

[!AUTOSPACING!]
[!INCLUDE "../../generate_common/Dem_Include.m"!]
[!//
/*==================[includes]==============================================*/
/* !LINKSTO dsn.Dem.IncludeStr,1 */

[!IF "DemGeneral/DemRteUsage = 'true'"!]
#include <Rte_Dem_Type.h>        /* types generated by RTE */
[!ENDIF!]
#include <Dem_IntErrId.h>        /* BSW Event ID symbols */
#include <Dem_IntEvtId.h>        /* SW-C Event ID symbols */

[!IF "count(DemGeneral/DemNvRamBlockId/*) > 0"!]
#include <NvM.h>           /* NvM symbols */
[!ENDIF!]

/*==================[type definitions]======================================*/

#ifndef RTE_TYPE_Dem_EventIdType
#define RTE_TYPE_Dem_EventIdType
/**  \brief Defines the Dem Event ID which is
 **  identification of an event by assigned EventId
 **  In case the Rte is available this type is defined in Rte_Type.h.
 **/
typedef uint16 Dem_EventIdType;
#endif

/*==================[macros]================================================*/
[!IF "node:exists(DemGeneral/DemGeneralOBD)"!][!//
#if (defined DEM_GENERAL_OBD)
#error DEM_GENERAL_OBD already defined
#endif
/** \brief Definition of DEM_GENERAL_OBD */
#define DEM_GENERAL_OBD STD_ON
[!ELSE!][!//
#if (defined DEM_GENERAL_OBD)
#error DEM_GENERAL_OBD already defined
#endif
/** \brief Definition of DEM_GENERAL_OBD */
#define DEM_GENERAL_OBD STD_OFF
[!ENDIF!]

[!IF "node:exists(DemGeneral/DemGeneralOBD/DemOBDEngineType) and (DemGeneral/DemGeneralOBD/DemOBDEngineType = 'DEM_IGNITION_COMPRESSION')"!][!//
#if (defined DEM_OBD_ENGINE_TYPE)
#error DEM_OBD_ENGINE_TYPE already defined
#endif
/** \brief Definition of DEM_OBD_ENGINE_TYPE */
#define DEM_OBD_ENGINE_TYPE DEM_IGNITION_COMPRESSION
[!ELSEIF "node:exists(DemGeneral/DemGeneralOBD/DemOBDEngineType) and (DemGeneral/DemGeneralOBD/DemOBDEngineType = 'DEM_IGNITION_SPARK')"!][!//
#if (defined DEM_OBD_ENGINE_TYPE)
#error DEM_OBD_ENGINE_TYPE already defined
#endif
/** \brief Definition of DEM_OBD_ENGINE_TYPE */
#define DEM_OBD_ENGINE_TYPE DEM_IGNITION_SPARK
[!ENDIF!]

#if (defined DEM_CFG_SIGNATURE)
#error DEM_CFG_SIGNATURE is already defined
#endif
/* !LINKSTO Dem.EB.Config.Id,1 */
/** \brief Sign a certain configuration with unique hash
 **/
#define DEM_CFG_SIGNATURE [!"asc:getConfigSignature(node:difference(as:modconf('Dem')[1]//
                            *[not(child::*) and(node:configclass() = 'PreCompile')],
                            as:modconf('Dem')[1]/DemConfigSet/*))"!]U

#if (defined DEM_NVRAM_CONFIG_SIGNATURE_USED)
#error DEM_NVRAM_CONFIG_SIGNATURE_USED is already defined
#endif

/* !LINKSTO Dem.NvDataSignature.Config.Used,1 */
/** \brief Switch, Indicating a support of reset of NVRAM memory based on signature value
 **/
[!IF "(not(node:exists(DemGeneral/DemNvDataConfigSignatureUsed))) or (DemGeneral/DemNvDataConfigSignatureUsed = 'false')"!]
  [!WS "0"!]#define DEM_NVRAM_CONFIG_SIGNATURE_USED    STD_OFF
[!ELSE!][!//
  [!WS "0"!]#define DEM_NVRAM_CONFIG_SIGNATURE_USED    STD_ON

#if (defined DEM_CONFIG_NVRAM_SIGNATURE)
#error DEM_CONFIG_NVRAM_SIGNATURE is already defined
#endif

/* !LINKSTO Dem.NvDataSignature.Calculation,1 */
/* !LINKSTO Dem.NvDataSignature.Config.CalcSet,1 */
/** \brief Signature value on a certain configuration parameters which affects Nv Data
 **/
[!IF "(DemGeneral/DemNvDataConfigSignatureCalcSet = 'DEM_NVM_SIGNATURE_ALL')"!]
#define DEM_CONFIG_NVRAM_SIGNATURE [!"asc:getConfigSignature(as:modconf('Dem')[1]//*)"!]U
[!ELSE!][!//
#define DEM_CONFIG_NVRAM_SIGNATURE [!"asc:getConfigSignature(as:modconf('Dem')[1]/DemGeneral/DemFreezeFrameCapture
| as:modconf('Dem')[1]/DemGeneral/DemExtendedDataCapture
| as:modconf('Dem')[1]/DemGeneral/DemNvRamBlockId/*/DemNvRamBlockIdRef
| as:modconf('Dem')[1]/DemGeneral/DemResetConfirmedBitOnOverflow
| as:modconf('Dem')[1]/DemGeneral/DemGetDTCByOccurrenceTimeSupport
| as:modconf('Dem')[1]/DemGeneral/DemMaxNumberEventEntryPrimary
| as:modconf('Dem')[1]/DemGeneral/DemMaxNumberEventEntrySecondary
| as:modconf('Dem')[1]/DemGeneral/DemMaxNumberEventEntryMirror
| as:modconf('Dem')[1]/DemGeneral/DemMaxNumberEventEntryPermanent
| as:modconf('Dem')[1]/DemGeneral/DemOperationCycleStatusStorage
| as:modconf('Dem')[1]/DemGeneral/DemIndicator/*
| as:modconf('Dem')[1]/DemGeneral/DemMaxNumberDevFreezeFrameAEntry
| as:modconf('Dem')[1]/DemGeneral/DemMaxNumberDevFreezeFrameBEntry
| as:modconf('Dem')[1]/DemGeneral/DemEventCombinationSupport
| as:modconf('Dem')[1]/DemGeneral/DemOBDSupport
| as:modconf('Dem')[1]/DemGeneral/DemOperationCycle/*[DemOperationCycleType = 'DEM_OPCYC_WARMUP']
| as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDCentralizedPID21Handling
| as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDCentralizedPID31Handling
| as:modconf('Dem')[1]/DemConfigSet/*/DemPidClass/*
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemEventId
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemExtendedDataClassRef
| node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemExtendedDataClassRef)/DemExtendedDataRecordClassRef/*
| node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemExtendedDataClassRef)/DemExtendedDataRecordClassRef/*)/DemDataElementClassRef/*
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemExtendedDataClassRef)/DemExtendedDataRecordClassRef/*)/DemDataElementClassRef/*)
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemExtendedDataClassRef)/DemExtendedDataRecordClassRef/*)/DemDataElementClassRef/*)/DemDataElementDataSize
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemExtendedDataClassRef)/DemExtendedDataRecordClassRef/*)/DemDataElementClassRef/*)/DemDataElementReadFnc
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemExtendedDataClassRef)/DemExtendedDataRecordClassRef/*)/DemDataElementClassRef/*)/DemDataElementUsePort
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemExtendedDataClassRef)/DemExtendedDataRecordClassRef/*)/DemDataElementClassRef/*)/DemInternalDataElement
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemFreezeFrameClassRef
| node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemFreezeFrameClassRef)/DemDidClassRef/*
| node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemFreezeFrameClassRef)/DemDidClassRef/*)/DemDidIdentifier
| node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemFreezeFrameClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemFreezeFrameClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemDataElementDataSize
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemFreezeFrameClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemDataElementReadFnc
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemFreezeFrameClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemDataElementUsePort
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemFreezeFrameClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemInternalDataElement
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameAClassRef
| node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameAClassRef)/DemDidClassRef/*
| node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameAClassRef)/DemDidClassRef/*)/DemDidIdentifier
| node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameAClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameAClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemDataElementDataSize
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameAClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemDataElementReadFnc
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameAClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemDataElementUsePort
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameAClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemInternalDataElement
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameBClassRef
| node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameBClassRef)/DemDidClassRef/*
| node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameBClassRef)/DemDidClassRef/*)/DemDidIdentifier
| node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameBClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameBClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemDataElementDataSize
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameBClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemDataElementReadFnc
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameBClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemDataElementUsePort
| node:refs(node:refs(node:refs(as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemDevFreezeFrameBClassRef)/DemDidClassRef/*)/DemDidDataElementClassRef/*)/DemInternalDataElement
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*[node:refexists(DemDTCClassRef)]/DemDTCClassRef
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*[node:exists(./DemEventClass/DemEventFailureCycleCounterThreshold)]/DemEventClass/DemEventFailureCycleCounterThreshold
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemEventClass/DemIndicatorAttribute/*
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemEventClass/DemEventAvailable
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*/DemEventClass/DemEventDestination
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*[node:exists(DemEvtCmbCommonParamMaster)]/DemEvtCmbCommonParamMaster
| as:modconf('Dem')[1]/DemConfigSet/*/DemEventParameter/*[DemEventClass/DemDebounceAlgorithmClass = 'DemDebounceCounterBased']/DemEventClass/DemDebounceAlgorithmClass/DemDebounceCounterStorage
)"!]U
[!ENDIF!]
[!ENDIF!]

/*------------------[RTE configuration]-------------------------------------*/

#if (defined DEM_INCLUDE_RTE)
#error DEM_INCLUDE_RTE already defined
#endif
/** \brief Switch, indicating if RTE is available and can be used from Dem */
[!IF "DemGeneral/DemRteUsage = 'true'"!]
  [!WS "0"!]#define DEM_INCLUDE_RTE              STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_INCLUDE_RTE              STD_OFF
[!ENDIF!]

#if (defined DEM_SERVICE_API_NONE)
#error DEM_SERVICE_API_NONE already defined
#endif
/** \brief Definition that no default service API is set */
#define DEM_SERVICE_API_NONE    0U

#if (defined DEM_SERVICE_API_ASR40)
#error DEM_SERVICE_API_ASR40 already defined
#endif
/** \brief Definition that AUTOSAR 4.0 service API is set as default */
#define DEM_SERVICE_API_ASR40   40U

#if (defined DEM_SERVICE_API_ASR42)
#error DEM_SERVICE_API_ASR42 already defined
#endif
/** \brief Definition that AUTOSAR 4.2 service API is set as default */
#define DEM_SERVICE_API_ASR42   42U

#if (defined DEM_ENABLE_ASR40_SERVICE_API)
#error DEM_ENABLE_ASR40_SERVICE_API already defined
#endif
/** \brief Definition whether AUTOSAR 4.0 service API is enabled */
[!IF "DemGeneral/DemRteUsage = 'true' and
      DemGeneral/DemServiceAPI/DemEnableASR40ServiceAPI = 'true'"!]
  [!WS "0"!]#define DEM_ENABLE_ASR40_SERVICE_API  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_ENABLE_ASR40_SERVICE_API  STD_OFF
[!ENDIF!]

#if (defined DEM_ENABLE_ASR42_SERVICE_API)
#error DEM_ENABLE_ASR42_SERVICE_API already defined
#endif
/** \brief Definition whether AUTOSAR 4.2 service API is enabled */
[!IF "DemGeneral/DemRteUsage = 'true' and
      DemGeneral/DemServiceAPI/DemEnableASR42ServiceAPI = 'true'"!]
  [!WS "0"!]#define DEM_ENABLE_ASR42_SERVICE_API  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_ENABLE_ASR42_SERVICE_API  STD_OFF
[!ENDIF!]

#if (defined DEM_ENABLE_ASR43_SERVICE_API)
#error DEM_ENABLE_ASR43_SERVICE_API already defined
#endif
/** \brief Definition whether AUTOSAR 4.3 service API is enabled */
[!IF "DemGeneral/DemRteUsage = 'true' and
      DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_43'"!]
  [!WS "0"!]#define DEM_ENABLE_ASR43_SERVICE_API  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_ENABLE_ASR43_SERVICE_API  STD_OFF
[!ENDIF!]

#if (defined DEM_DEFAULT_ASR_SERVICE_API)
#error DEM_DEFAULT_ASR_SERVICE_API already defined
#endif
/** \brief Definition of default service API
 ** AUTOSAR_40: service APIs are fully based on the AUTOSAR_40 specification.
 ** AUTOSAR_42: some parts of the service APIs are based on the AUTOSAR_42
 ** specification the remaning APIs are still based on the AUTOSAR_40
 ** specification.
 ** AUTOSAR_43: uses AUTOSAR_42 as base, see above, plus some service APIs
 ** based on AUTOSAR_43.
 **/
[!IF "DemGeneral/DemRteUsage = 'true'"!]
  [!IF "DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_40'"!]
    [!WS "0"!]#define DEM_DEFAULT_ASR_SERVICE_API DEM_SERVICE_API_ASR40
  [!ELSEIF "DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_42'"!]
    [!WS "0"!]#define DEM_DEFAULT_ASR_SERVICE_API DEM_SERVICE_API_ASR42
  [!ELSEIF "DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_43'"!]
    [!WS "0"!]#define DEM_DEFAULT_ASR_SERVICE_API DEM_SERVICE_API_ASR42
  [!ENDIF!]
[!ELSE!][!//
  [!WS "0"!]#define DEM_DEFAULT_ASR_SERVICE_API DEM_SERVICE_API_NONE
[!ENDIF!]

#if (defined DEM_USER_CTRL_WIR_SUPPORT)
#error DEM_USER_CTRL_WIR_SUPPORT already defined
#endif
/** \brief Switch, indicating if user controlled WIR-bit is enabled */
[!IF "DemGeneral/DemUserControlledWIRBitSupport = 'true'"!]
  [!WS "0"!]#define DEM_USER_CTRL_WIR_SUPPORT              STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_USER_CTRL_WIR_SUPPORT             STD_OFF
[!ENDIF!]

#if (defined DEM_DATA_ELEMENT_INTERFACE_WITH_EVENTID_SUPPORT)
#error DEM_DATA_ELEMENT_INTERFACE_WITH_EVENTID_SUPPORT already defined
#endif
/** \brief Switch, indicating if support for ReadData interface with
  * EventId parameter is enabled */
[!IF "count(DemGeneral/DemDataElementClass/*[(. = 'DemExternalCSDataElementClass') and (./DemDataElementInterfaceWithEventParameter = 'true')]) > 0"!]
  [!WS "0"!]#define DEM_DATA_ELEMENT_INTERFACE_WITH_EVENTID_SUPPORT   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_DATA_ELEMENT_INTERFACE_WITH_EVENTID_SUPPORT  STD_OFF
[!ENDIF!]

#if (defined DEM_SR_SUPPORT)
#error DEM_SR_SUPPORT already defined
#endif
/* !LINKSTO dsn.Dem.SRFunctionality.Support.Macro,1 */
/** \brief Switch, indicating if sender receiver interface is enabled */
[!IF "(DemGeneral/DemRteUsage = 'true') and ((count(DemGeneral/DemDataElementClass/*[. = 'DemExternalSRDataElementClass'])) > 0) "!]
  [!WS "0"!]#define DEM_SR_SUPPORT                         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_SR_SUPPORT                        STD_OFF
[!ENDIF!]

#if (DEM_SR_SUPPORT == STD_ON)
[!VAR "MaxSizeSRUint16" = "1"!]
[!VAR "MaxSizeSRUint32" = "1"!]
[!LOOP "DemGeneral/DemDataElementClass/*[. = 'DemExternalSRDataElementClass']"!]
  [!VAR "DataTypeSize" = "(substring-after(./DemDataElementDataType, 'UINT')) div 8"!]
  [!IF "$DataTypeSize = 2"!]
    [!VAR "ArraySize" = "num:integer((./DemDataElementDataSize + 1) div 2)"!]
    [!IF "$ArraySize > $MaxSizeSRUint16"!]
      [!VAR "MaxSizeSRUint16" = "$ArraySize"!]
    [!ENDIF!]
  [!ELSEIF "$DataTypeSize = 4"!]
    [!VAR "ArraySize" = "num:integer((./DemDataElementDataSize + 3) div 4)"!]
    [!IF "$ArraySize > $MaxSizeSRUint32"!]
      [!VAR "MaxSizeSRUint32" = "$ArraySize"!]
    [!ENDIF!]
  [!ENDIF!]
[!ENDLOOP!]

#if (defined DEM_MAX_SIZE_EXT_SR_UINT16)
#error DEM_MAX_SIZE_EXT_SR_UINT16 already defined
#endif
/** \brief Maximum array size for a UINT16 SR DataElement */
#define DEM_MAX_SIZE_EXT_SR_UINT16      [!"num:integer($MaxSizeSRUint16)"!]U

#if (defined DEM_MAX_SIZE_EXT_SR_UINT32)
#error DEM_MAX_SIZE_EXT_SR_UINT32 already defined
#endif
/** \brief Maximum array size for a UINT32 SR DataElement */
#define DEM_MAX_SIZE_EXT_SR_UINT32      [!"num:integer($MaxSizeSRUint32)"!]U
#endif /* (DEM_SR_SUPPORT == STD_ON) */

/*------------------[DTC configuration]-------------------------------------*/

#if (defined DEM_NO_DTC)
#error DEM_NO_DTC already defined
#endif
/** \brief No DTC (neither UDS, OBD nor J1939) configured for event */
#define DEM_NO_DTC                 0U

#if (defined DEM_NO_DTC_FUNCTIONAL_UNIT)
#error DEM_NO_DTC_FUNCTIONAL_UNIT already defined
#endif
/** \brief No DTC functional unit configured for event */
#define DEM_NO_DTC_FUNCTIONAL_UNIT 0U

/*------------------[General]-----------------------------------------------*/

#if (defined DEM_VERSION_INFO_API)
#error DEM_VERSION_INFO_API already defined
#endif
/** \brief Switch, indicating if Version Info is activated for Dem */
[!IF "DemGeneral/DemVersionInfoApi = 'true'"!]
  [!WS "0"!]#define DEM_VERSION_INFO_API                  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_VERSION_INFO_API                  STD_OFF
[!ENDIF!]

#if (defined DEM_CALIBRATION_SUPPORT)
#error DEM_CALIBRATION_SUPPORT already defined
#endif
/** \brief Switch for calibration support without event combination */
/* !LINKSTO dsn.Dem.Calibration.Support.Macro,1 */
[!IF "$CalibrationSupport = 'true'"!]
  [!WS "0"!]#define DEM_CALIBRATION_SUPPORT               STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_CALIBRATION_SUPPORT               STD_OFF
[!ENDIF!]

#if (defined DEM_CALIBRATION_WITHEVCOMB_SUPPORT)
#error DEM_CALIBRATION_WITHEVCOMB_SUPPORT already defined
#endif
/** \brief Switch for calibration support with event combination */
[!IF "$CalibrationWithEvCombSupport = 'true'"!]
  [!WS "0"!]#define DEM_CALIBRATION_WITHEVCOMB_SUPPORT STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_CALIBRATION_WITHEVCOMB_SUPPORT STD_OFF
[!ENDIF!]

#if (defined DEM_INDICATORCLASS_SUPPORT)
#error DEM_INDICATORCLASS_SUPPORT already defined
#endif
/** \brief Switch for indicator class support */
[!IF "$IndicatorClassSupport = 'true'"!]
  [!WS "0"!]#define DEM_INDICATORCLASS_SUPPORT STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_INDICATORCLASS_SUPPORT STD_OFF
[!ENDIF!]

[!IF "$CalibrationSupport = 'true'"!]
  [!VAR "ConsistentFFSize" = "'true'"!]
[!ELSE!][!//
  [!VAR "ConsistentFFSize" = "'false'"!]
[!ENDIF!]

#if (defined DEM_POSITIVE_RESPONSE_NO_FFCLASSES)
#error DEM_POSITIVE_RESPONSE_NO_FFCLASSES already defined
#endif
/** \brief Switch for positive response when event has no FF assigned
 ** (disabled through calibration) */
/* !LINKSTO dsn.Dem.Calibration.NoFFClass.PositiveResponse,1 */
[!IF "$CalibrationSupport = 'true'"!]
  [!WS "0"!]#define DEM_POSITIVE_RESPONSE_NO_FFCLASSES   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_POSITIVE_RESPONSE_NO_FFCLASSES   STD_OFF
[!ENDIF!]

#if (defined DEM_CONSISTENT_FF_SIZE_SUPPORT)
#error DEM_CONSISTENT_FF_SIZE_SUPPORT already defined
#endif
/** \brief Switch for consistent FF size */
/* !LINKSTO dsn.Dem.Storage.ConsistentFFSize.Support,1 */
#define DEM_CONSISTENT_FF_SIZE_SUPPORT   [!//
  [!IF "$ConsistentFFSize = 'true'"!]STD_ON[!ELSE!]STD_OFF[!ENDIF!]


[!INDENT "0"!]
  [!IF "$ConsistentFFSize = 'true'"!]
    [!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntryPrimary)"!]
      [!VAR "MaxFFSizePrimary" = "DemGeneral/DemMaxSizeFreezeFrameEntryPrimary"!]
    [!ELSE!][!//
      [!VAR "MaxFFSizePrimary" = "0"!]
    [!ENDIF!]
    #if (defined DEM_CONSISTENT_FF_SIZE_PRIMARY)
    #error DEM_CONSISTENT_FF_SIZE_PRIMARY already defined
    #endif
    /** \brief Consistent size of primary FFs */
    /* !LINKSTO dsn.Dem.Storage.ConsistentFFSize,1 */
    #define DEM_CONSISTENT_FF_SIZE_PRIMARY      [!"num:i($MaxFFSizePrimary)"!]U

    [!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntrySecondary)"!]
      [!VAR "MaxFFSizeSecondary" = "DemGeneral/DemMaxSizeFreezeFrameEntrySecondary"!]
    [!ELSE!][!//
      [!VAR "MaxFFSizeSecondary" = "0"!]
    [!ENDIF!]
    #if (defined DEM_CONSISTENT_FF_SIZE_SECONDARY)
    #error DEM_CONSISTENT_FF_SIZE_SECONDARY already defined
    #endif
    /** \brief Consistent size of primary FFs */
    /* !LINKSTO dsn.Dem.Storage.ConsistentFFSize,1 */
    #define DEM_CONSISTENT_FF_SIZE_SECONDARY    [!"num:i($MaxFFSizeSecondary)"!]U

    [!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntryMirror)"!]
      [!VAR "MaxFFSizeMirror" = "DemGeneral/DemMaxSizeFreezeFrameEntryMirror"!]
    [!ELSE!][!//
      [!VAR "MaxFFSizeMirror" = "0"!]
    [!ENDIF!]
    #if (defined DEM_CONSISTENT_FF_SIZE_MIRROR)
    #error DEM_CONSISTENT_FF_SIZE_MIRROR already defined
    #endif
    /** \brief Consistent size of mirror FFs */
    /* !LINKSTO dsn.Dem.Storage.ConsistentFFSize,1 */
    #define DEM_CONSISTENT_FF_SIZE_MIRROR       [!"num:i($MaxFFSizeMirror)"!]U

  [!ENDIF!]
[!ENDINDENT!]

#if (defined DEM_COMMON_OPERATION_CYCLE_SUPPORT)
#error DEM_COMMON_OPERATION_CYCLE_SUPPORT already defined
#endif
/** \brief Switch for common operation cycle support */
/* !LINKSTO dsn.Dem.CommonOperationCycle.Support.Macro,1 */
[!IF "($CommonOperationCycleEnabled = 'true') and ($CalibrationSupport = 'true')"!]
  [!WS "0"!]#define DEM_COMMON_OPERATION_CYCLE_SUPPORT    STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_COMMON_OPERATION_CYCLE_SUPPORT    STD_OFF
[!ENDIF!]

#if (defined DEM_AGINGALLOWED_CONVENIENT_CALIBRATION)
#error DEM_AGINGALLOWED_CONVENIENT_CALIBRATION already defined
#endif
/** \brief Switch to enable a convenient way of aging allowed calibration */
/* !LINKSTO dsn.Dem.Calibration.AgingAllowedConvenient.Macro,1 */
#define DEM_AGINGALLOWED_CONVENIENT_CALIBRATION     [!//
[!IF "(DemGeneral/DemAgingAllowedSeperateFlag = 'true') and ($CalibrationSupport = 'true')"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_AGING_REQUIRES_TESTED_CYCLE_SET_OPERATION_CYCLE_STATE)
#error DEM_AGING_REQUIRES_TESTED_CYCLE_SET_OPERATION_CYCLE_STATE already defined
#endif
/** \brief Switch, indicating whether Dem_SetOperationCycleState() will consider or not the untested cyles */
#define DEM_AGING_REQUIRES_TESTED_CYCLE_SET_OPERATION_CYCLE_STATE  [!//
[!IF "node:exists(DemGeneral/DemAgingRequiresTestedCycleSetOperationCycleState) and (DemGeneral/DemAgingRequiresTestedCycleSetOperationCycleState = 'true')"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_AGING_REQUIRES_TESTED_CYCLE_SET_AGING_CYCLE_STATE)
#error DEM_AGING_REQUIRES_TESTED_CYCLE_SET_AGING_CYCLE_STATE already defined
#endif
/** \brief Switch, indicating whether Dem_SetAgingCycleState() will consider or not the untested cyles */
#define DEM_AGING_REQUIRES_TESTED_CYCLE_SET_AGING_CYCLE_STATE      [!//
[!IF "node:exists(DemGeneral/DemAgingRequiresTestedCycleSetAgingCycleState) and (DemGeneral/DemAgingRequiresTestedCycleSetAgingCycleState = 'true')"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_AGING_BASED_ON_HEALING_COMPLETION_SUPPORT)
#error DEM_AGING_BASED_ON_HEALING_COMPLETION_SUPPORT already defined
#endif
/** \brief Switch, indicating whether aging process should start only after healing is finished */
#define DEM_AGING_BASED_ON_HEALING_COMPLETION_SUPPORT  [!//
[!IF "(count(DemConfigSet/*/DemEventParameter/*[DemEventClass/DemAgingAllowed = 'true']) > 0) and node:exists(DemGeneral/DemAgingBasedOnHealingCompletionSupport) and (node:value(DemGeneral/DemAgingBasedOnHealingCompletionSupport) = 'true')"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_CB_TRIG_ON_EVDAT_ASR403)
#error DEM_CB_TRIG_ON_EVDAT_ASR403 already defined
#endif
/** \brief Switch, indicating whether EventDataChanged callback triggering behavior
 ** will be done according to ASR4.0.3 or or to ASR4.2.1 */
/* !LINKSTO dsn.Dem.CallbackEventDataChangedASR403.Macro,1 */
[!IF "node:exists(DemGeneral/DemCallbackEventDataChangedASR403Behaviour) and (DemGeneral/DemCallbackEventDataChangedASR403Behaviour = 'true')"!]
  [!WS "0"!]#define DEM_CB_TRIG_ON_EVDAT_ASR403    STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_CB_TRIG_ON_EVDAT_ASR403    STD_OFF
[!ENDIF!]

#if (defined DEM_CB_EVST_CHANGED_OPCYC_START_SUPPORT)
#error DEM_CB_EVST_CHANGED_OPCYC_START_SUPPORT already defined
#endif
/** \brief Switch, indicating whether Dem_OpCycleProcessCycleStart() will trigger
 ** EventStatusChanged/DTCStatusChanged callback. */
/* !LINKSTO dsn.Dem.DemCallbackEventStatusChangedOpCycStartSupport.Macro,1 */
#define DEM_CB_EVST_CHANGED_OPCYC_START_SUPPORT  [!//
[!IF "node:exists(DemGeneral/DemCallbackEventStatusChangedOpCycStartSupport) and (DemGeneral/DemCallbackEventStatusChangedOpCycStartSupport = 'true')"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_NO_SUPPRESSION)
#error DEM_NO_SUPPRESSION already defined
#endif
#define DEM_NO_SUPPRESSION  0U

#if (defined DEM_DTC_SUPPRESSION)
#error DEM_DTC_SUPPRESSION already defined
#endif
#define DEM_DTC_SUPPRESSION  1U

#if (defined DEM_SUPPRESSION_SUPPORT)
#error DEM_SUPPRESSION_SUPPORT already defined
#endif
/** \brief Switch for DTC suppression support */
#define DEM_SUPPRESSION_SUPPORT           [!"DemGeneral/DemSuppressionSupport"!]

#if (defined DEM_NO_AVAILABILITY)
#error DEM_NO_AVAILABILITY already defined
#endif
#define DEM_NO_AVAILABILITY  0U

#if (defined DEM_EVENT_AVAILABILITY)
#error DEM_EVENT_AVAILABILITY already defined
#endif
#define DEM_EVENT_AVAILABILITY  1U

#if (defined DEM_AVAILABILITY_SUPPORT)
#error DEM_AVAILABILITY_SUPPORT already defined
#endif
/** \brief Switch for dynamic event availability support */
#define DEM_AVAILABILITY_SUPPORT          [!"DemGeneral/DemAvailabilitySupport"!]

#if (defined DEM_EVENT_DISABLING_SUPPORT)
#error DEM_EVENT_DISABLING_SUPPORT already defined
#endif
/** \brief Switch for DTC availability support */
[!IF "($CalibrationSupport = 'true') or ($AvailabilitySupport = 'true')"!]
  [!WS "0"!]#define DEM_EVENT_DISABLING_SUPPORT           STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_EVENT_DISABLING_SUPPORT           STD_OFF
[!ENDIF!]

#if (defined DEM_CLEAR_DTC_OF_DISABLED_EVENTS )
#error DEM_CLEAR_DTC_OF_DISABLED_EVENTS  already defined
#endif
/** \brief Switch to support clearing of DTCs for disabled events */
[!IF "node:exists(DemGeneral/DemClearDTCOfDisabledEvents) and (DemGeneral/DemClearDTCOfDisabledEvents = 'true')"!]
  [!WS "0"!]#define DEM_CLEAR_DTC_OF_DISABLED_EVENTS            STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_CLEAR_DTC_OF_DISABLED_EVENTS            STD_OFF
[!ENDIF!]

#if (defined DEM_MAX_NUM_CLEAR_EVENTS_PER_CYCLE )
#error DEM_MAX_NUM_CLEAR_EVENTS_PER_CYCLE  already defined
#endif
/** \brief Maximum number of events to be cleared per
 ** Dem_MainFunction() cycle on a ClearDTC request */
#define DEM_MAX_NUM_CLEAR_EVENTS_PER_CYCLE       [!"num:integer(DemGeneral/DemMaxNumberClearEventsPerCycle)"!]U

#if (defined DEM_EVENTCLASS_SUPPORT)
#error DEM_EVENTCLASS_SUPPORT already defined
#endif
/** \brief Switch for event class support */
[!IF "$EventClassSupport = 'true'"!]
  [!WS "0"!]#define DEM_EVENTCLASS_SUPPORT                STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_EVENTCLASS_SUPPORT                STD_OFF
[!ENDIF!]

#if (defined DEM_DTC_STATUS_AVAILABILITY_MASK)
#error DEM_DTC_STATUS_AVAILABILITY_MASK already defined
#endif
/** \brief DTC status availability mask */
#define DEM_DTC_STATUS_AVAILABILITY_MASK    [!"num:integer(DemGeneral/DemDtcStatusAvailabilityMask)"!]U

#if (defined DEM_STATUS_BIT_STORAGE_TF_PER_EVENT_SUPPORT)
#error DEM_STATUS_BIT_STORAGE_TF_PER_EVENT_SUPPORT already defined
#endif

[!VAR "NrOfTFStoragePerEventFlagsSetOnTrue" = "0"!][!//
[!VAR "NrOfTFStoragePerEventFlagsSetOnFalse" = "0"!][!//
[!VAR "NrOfEvents" = "0"!][!//
[!LOOP "node:order(DemConfigSet/*/DemEventParameter/*, 'DemEventId')"!][!//
  [!VAR "NrOfEvents" = "$NrOfEvents + 1"!][!//
  [!IF "(node:exists(DemStatusBitStorageTestFailedPerEvent))"!][!//
    [!INDENT "4"!]
    [!IF "DemStatusBitStorageTestFailedPerEvent = 'true'"!][!//
      [!VAR "NrOfTFStoragePerEventFlagsSetOnTrue" = "$NrOfTFStoragePerEventFlagsSetOnTrue + 1"!][!//
    [!ELSE!][!//
      [!VAR "NrOfTFStoragePerEventFlagsSetOnFalse" = "$NrOfTFStoragePerEventFlagsSetOnFalse + 1"!][!//
    [!ENDIF!]
    [!ENDINDENT!]
  [!ENDIF!]
[!ENDLOOP!]

/** \brief macro is enabled only when all the events
 ** do not have same value */
[!IF "( ( ($NrOfTFStoragePerEventFlagsSetOnTrue > '0')         and 
          ($NrOfTFStoragePerEventFlagsSetOnTrue < $NrOfEvents) and
          (DemGeneral/DemStatusBitStorageTestFailed = 'false')
        )
        or
        ( ($NrOfTFStoragePerEventFlagsSetOnFalse > '0')         and
          ($NrOfTFStoragePerEventFlagsSetOnFalse < $NrOfEvents) and
          (DemGeneral/DemStatusBitStorageTestFailed = 'true')
        )
      )"!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF_PER_EVENT_SUPPORT  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF_PER_EVENT_SUPPORT  STD_OFF
[!ENDIF!][!//

#if (defined DEM_STATUS_BIT_STORAGE_TF)
#error DEM_STATUS_BIT_STORAGE_TF already defined
#endif
/** \brief Switch, indicating if permanent storage of the
 ** "TestFailed" status bit is activated */
[!IF "($NrOfTFStoragePerEventFlagsSetOnTrue = $NrOfEvents)"!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF     STD_ON
[!ELSEIF "($NrOfTFStoragePerEventFlagsSetOnFalse = $NrOfEvents)"!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF     STD_OFF
[!ELSEIF "DemGeneral/DemStatusBitStorageTestFailed = 'true'"!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF     STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF     STD_OFF
[!ENDIF!][!//

#if (defined DEM_RESET_PENDING_BIT_ON_OVERFLOW_SUPPORT)
#error DEM_RESET_PENDING_BIT_ON_OVERFLOW_SUPPORT already defined
#endif
/** \brief Switch, indicating if the pending bit is reset or
 ** not while an event memory entry will be displaced */
[!IF "DemGeneral/DemResetPendingBitOnOverflow = 'true'"!]
  [!WS "0"!]#define DEM_RESET_PENDING_BIT_ON_OVERFLOW_SUPPORT     STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_RESET_PENDING_BIT_ON_OVERFLOW_SUPPORT     STD_OFF
[!ENDIF!]

#if (defined DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT)
#error DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT already defined
#endif
/** \brief Switch, indicating if the confirmed bit is reset or
 ** not while an event memory entry will be displaced */
[!IF "DemGeneral/DemResetConfirmedBitOnOverflow = 'true'"!]
  [!WS "0"!]#define DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT     STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT     STD_OFF
[!ENDIF!]

#if (defined DEM_UPDATE_OCCORDER_ON_EVENTENTRY_UPDATE)
#error DEM_UPDATE_OCCORDER_ON_EVENTENTRY_UPDATE already defined
#endif
/** \brief Switch, indicating whether the OccOrder shall be updated
 ** at every event entry update */
[!IF "DemGeneral/DemUpdateOccOrderOnEventEntryUpdate = 'false'"!]
  [!WS "0"!]#define DEM_UPDATE_OCCORDER_ON_EVENTENTRY_UPDATE    STD_OFF
[!ELSE!][!//
  [!WS "0"!]#define DEM_UPDATE_OCCORDER_ON_EVENTENTRY_UPDATE    STD_ON
[!ENDIF!]

#if (defined DEM_USE_PERMANENT_STORAGE)
#error DEM_USE_PERMANENT_STORAGE already defined
#endif
/** \brief Switch, indicating if Permanent storage of event
 ** memory entries in NvM is activated for
 ** Dem */
[!IF "count(DemGeneral/DemNvRamBlockId/*) > 0"!]
  [!WS "0"!]#define DEM_USE_PERMANENT_STORAGE             STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_USE_PERMANENT_STORAGE             STD_OFF
[!ENDIF!]

#if (defined DEM_OPCYC_NVSTORAGE)
#error DEM_OPCYC_NVSTORAGE already defined
#endif
/** \brief Switch, indicating if permanent storage of operation cycle entries
 ** to NVRAM is enabled */
[!IF "DemGeneral/DemOperationCycleStatusStorage = 'true'"!]
  [!WS "0"!]#define DEM_OPCYC_NVSTORAGE                   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OPCYC_NVSTORAGE                   STD_OFF
[!ENDIF!]

#if (defined DEM_OPCYCLESTATE)
#error DEM_OPCYCLESTATE already defined
#endif
/** \brief Macro to get the operation cycle states based on permanent storage
 ** of operation cycle entries to NVRAM */
[!IF "DemGeneral/DemOperationCycleStatusStorage = 'true'"!]
  [!WS "0"!]#define DEM_OPCYCLESTATE             Dem_NvData.OpCycleState
[!ELSE!][!//
  [!WS "0"!]#define DEM_OPCYCLESTATE             Dem_OpCycleState
[!ENDIF!]

/* !LINKSTO Dem.OperationCyclePermStorage.FDC,1 */
#if (defined DEM_NUM_DEBOUNCE_COUNTER_PERM)
#error DEM_NUM_DEBOUNCE_COUNTER_PERM already defined
#endif
/** \brief Number of counter debounced events with permanent debounce
 ** counter storage
 **/
[!VAR "NumPermFDCs" = "0"!]
[!LOOP "DemConfigSet/*/DemEventParameter/*[DemEventClass/DemDebounceAlgorithmClass = 'DemDebounceCounterBased']"!]
  [!IF "node:value(./DemEventClass/DemDebounceAlgorithmClass/DemDebounceCounterStorage) = 'true'"!]
    [!VAR "NumPermFDCs" = "$NumPermFDCs + 1"!][!//
  [!ENDIF!]
[!ENDLOOP!]
#define DEM_NUM_DEBOUNCE_COUNTER_PERM  [!"num:integer($NumPermFDCs)"!]U

/* !LINKSTO dsn.Dem.FDCTriggerDebounceAlgorithm,1 */
#if (defined DEM_USE_TRIGGER_DEBOUNCE_BEHAVIOR)
#error DEM_USE_TRIGGER_DEBOUNCE_BEHAVIOR already defined
#endif
/** \brief Macro to get the the support for freeze/reset for time-based and
 ** frequency-based debouncing and counter-based reset behavior via non-fulfilled enable
 ** conditions and disabled DTCSettings.
 ** STD_ON: If at least one event is configured with counter-based RESET behavior or
 ** time/frequency-based debouncing and DemDebounceBehavior is set to RESET/FREEZE.
 **/
#define DEM_USE_TRIGGER_DEBOUNCE_BEHAVIOR [!//
[!IF "count( DemConfigSet/*/DemEventParameter/*/DemEventClass/DemDebounceAlgorithmClass[
             (. = 'DemDebounceCounterBased' and ./DemDebounceBehavior != 'DEM_DEBOUNCE_FREEZE') or
             (. = 'DemDebounceTimeBase' and ./DemDebounceBehavior != 'DEM_DEBOUNCE_CONTINUE') or
             (. = 'DemDebounceFrequencyBased' and ./DemDebounceBehavior != 'DEM_DEBOUNCE_CONTINUE')] ) > 0"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_NVM_BLOCK_ID_INVALID)
#error DEM_NVM_BLOCK_ID_INVALID already defined
#endif
/** \brief NvM block Id does not exist as it is not configured */
#define DEM_NVM_BLOCK_ID_INVALID      0U

[!IF "count(DemGeneral/DemNvRamBlockId/*) > 0"!]
  [!INDENT "0"!]
    [!IF "(count(DemConfigSet/*/DemEventParameter/*[node:refexists(DemDTCClassRef) and as:ref(DemDTCClassRef)/DemImmediateNvStorage = 'true']) > 0) or
          (DemGeneral/DemImmediateStorageInternalEvents = 'true') or (DemGeneral/DemClearDTCBehavior != 'DEM_CLRRESP_VOLATILE')"!]
      [!SELECT "DemGeneral/DemNvRamBlockId/*[name(.)='DEM_NVM_BLOCK_ID_DEFAULT']"!]
        [!CALL "GET_NVM_BLOCK_ID"!][!//
      [!ENDSELECT!]

      [!SELECT "DemGeneral/DemNvRamBlockId/*[name(.)='DEM_NVM_BLOCK_ID_PRIMARY']"!]
        [!CALL "GET_NVM_BLOCK_ID"!][!//
      [!ENDSELECT!]


      [!IF "count(DemConfigSet/*/DemEventParameter/*/DemEventClass[DemEventDestination = 'DEM_DTC_ORIGIN_MIRROR_MEMORY']) > 0"!]
        [!SELECT "DemGeneral/DemNvRamBlockId/*[name(.)='DEM_NVM_BLOCK_ID_MIRROR']"!]
          [!CALL "GET_NVM_BLOCK_ID"!][!//
        [!ENDSELECT!]
      [!ELSE!]
        #if (defined DEM_NVM_BLOCK_ID_MIRROR)
        #error DEM_NVM_BLOCK_ID_MIRROR already defined
        #endif
        /** \brief Invalid block Id for Dem mirror block as
         ** no event using mirror memory is configured */
        #define DEM_NVM_BLOCK_ID_MIRROR    DEM_NVM_BLOCK_ID_INVALID
      [!ENDIF!]

      [!IF "count(DemConfigSet/*/DemEventParameter/*/DemEventClass[DemEventDestination = 'DEM_DTC_ORIGIN_SECONDARY_MEMORY']) > 0"!]
        [!SELECT "DemGeneral/DemNvRamBlockId/*[name(.)='DEM_NVM_BLOCK_ID_SECONDARY']"!]
          [!CALL "GET_NVM_BLOCK_ID"!][!//
        [!ENDSELECT!]
      [!ELSE!]
        #if (defined DEM_NVM_BLOCK_ID_SECONDARY)
        #error DEM_NVM_BLOCK_ID_SECONDARY already defined
        #endif
        /** \brief Invalid block Id for Dem secondary block as
         ** no event using secondary memory is configured */
          #define DEM_NVM_BLOCK_ID_SECONDARY DEM_NVM_BLOCK_ID_INVALID
        [!ENDIF!]
    [!ELSE!][!/* no immediate non-volatile storage usage */!][!//
      [!SELECT "DemGeneral/DemNvRamBlockId/*[name(.)='DEM_NVM_BLOCK_ID_DEFAULT']"!]
        [!CALL "GET_NVM_BLOCK_ID"!][!//
      [!ENDSELECT!]
    [!ENDIF!]
  [!ENDINDENT!]
[!ENDIF!]

[!INDENT "0"!]
  [!IF "count(DemGeneral/DemNvRamBlockId/*[name(.) = 'DEM_NVM_BLOCK_ID_PERMANENT']) > 0"!]
    [!SELECT "DemGeneral/DemNvRamBlockId/*[name(.)='DEM_NVM_BLOCK_ID_PERMANENT']"!]
      [!CALL "GET_NVM_BLOCK_ID"!][!//
    [!ENDSELECT!]
  [!ELSE!]
    #if (defined DEM_NVM_BLOCK_ID_PERMANENT)
    #error DEM_NVM_BLOCK_ID_PERMANENT already defined
    #endif
    /** \brief Invalid block Id for Dem permanent block as permanent memory is not configured */
    #define DEM_NVM_BLOCK_ID_PERMANENT DEM_NVM_BLOCK_ID_INVALID
  [!ENDIF!]
[!ENDINDENT!]

/** \brief Maximum number of events over all memory sources */
[!VAR "SupportedEventMemories" = "0"!]
[!VAR "MaximumNumberOfEventsInMemories" = "0"!]
[!/* check for primary origin */!][!//
[!IF "DemGeneral/DemMaxNumberEventEntryPrimary > 0"!]
  [!VAR "SupportedEventMemories" = "bit:bitset($SupportedEventMemories, 0)"!]
  [!VAR "MaximumNumberOfEventsInMemories" = "DemGeneral/DemMaxNumberEventEntryPrimary"!]
[!ENDIF!]
[!/* check for secondary origin */!][!//
[!IF "DemGeneral/DemMaxNumberEventEntrySecondary > 0"!]
  [!VAR "SupportedEventMemories" = "bit:bitset($SupportedEventMemories, 1)"!]
  [!IF "DemGeneral/DemMaxNumberEventEntrySecondary > $MaximumNumberOfEventsInMemories"!]
    [!VAR "MaximumNumberOfEventsInMemories" = "DemGeneral/DemMaxNumberEventEntrySecondary"!]
  [!ENDIF!]
[!ENDIF!]
[!/* check for mirror origin */!][!//
[!IF "DemGeneral/DemMaxNumberEventEntryMirror > 0"!]
  [!VAR "SupportedEventMemories" = "bit:bitset($SupportedEventMemories, 2)"!]
  [!IF "DemGeneral/DemMaxNumberEventEntryMirror > $MaximumNumberOfEventsInMemories"!]
    [!VAR "MaximumNumberOfEventsInMemories" = "DemGeneral/DemMaxNumberEventEntryMirror"!]
  [!ENDIF!]
[!ENDIF!]
[!IF "DemGeneral/DemMaxNumberEventEntryPermanent > 0"!]
  [!VAR "SupportedEventMemories" = "bit:bitset($SupportedEventMemories, 3)"!]
  [!/* the ordered reporting of DTCs is not applicable for permanent event memory */!][!//
[!ENDIF!]

#if (defined DEM_MAX_NUM_ORDERED_EVENT_IDS)
#error DEM_MAX_NUM_ORDERED_EVENT_IDS already defined
#endif
[!/* !LINKSTO dsn.Dem.ReportingOrderDTC.NumOrderedEventIds,2 */!][!//
/** \brief Array size for ordered output of filtered DTCs */
#define DEM_MAX_NUM_ORDERED_EVENT_IDS [!"num:integer($MaximumNumberOfEventsInMemories)"!]U

#if (defined DEM_TYPE_OF_ORIGIN_SUPPORTED)
#error DEM_TYPE_OF_ORIGIN_SUPPORTED already defined
#endif
/** \brief Supported origin types
 **
 ** This macro is only exported and not used internally.
 ** It is derived from ::DEM_MAX_NUMBER_EVENT_ENTRY_PRI,
 ** ::DEM_MAX_NUMBER_EVENT_ENTRY_SEC, ::DEM_MAX_NUMBER_EVENT_ENTRY_MIR, and
 ** ::DEM_MAX_NUMBER_EVENT_ENTRY_PER.
 **
 ** \note Macro name is still existing for compatibility reasons with AR2.1.
 **/
#define DEM_TYPE_OF_ORIGIN_SUPPORTED [!"num:integer($SupportedEventMemories)"!]U

#if (defined DEM_DEV_ERROR_DETECT)
#error DEM_DEV_ERROR_DETECT already defined
#endif
/* !LINKSTO Dem113,1 */
/** \brief Switch, indicating if development error detection is activated for
 ** Dem */
[!IF "DemGeneral/DemDevErrorDetect = 'true'"!]
  [!WS "0"!]#define DEM_DEV_ERROR_DETECT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_DEV_ERROR_DETECT         STD_OFF
[!ENDIF!]

#if (defined DEM_TYPE_OF_DTC_SUPPORTED)
#error DEM_TYPE_OF_DTC_SUPPORTED already defined
#endif
/** \brief Returned DTC translation format by Dem_GetTranslationType()
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_TYPE_OF_DTC_SUPPORTED    [!"DemGeneral/DemTypeOfDTCSupported"!]

#if (defined DEM_DCM_ENABLED)
#error DEM_DCM_ENABLED already defined
#endif
/** \brief Switch, indicating whether Dcm module should be a part of Dem */
[!IF "DemGeneral/DemDcmUsage = 'true'"!]
  [!WS "0"!]#define DEM_DCM_ENABLED              STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_DCM_ENABLED              STD_OFF
[!ENDIF!]

#if (defined DEM_GET_DTCBYOCCURRENCETIME_SUPPORT)
#error DEM_GET_DTCBYOCCURRENCETIME_SUPPORT already defined
#endif
/** \brief Switch, indicating the existence of the functionality provided
 **  by Dem_GetDTCByOccurrenceTime() and the existence of the function itself
 **  to the Dcm module.
 **/
[!IF "DemGeneral/DemGetDTCByOccurrenceTimeSupport = 'true'"!]
  [!WS "0"!]#define DEM_GET_DTCBYOCCURRENCETIME_SUPPORT      STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_GET_DTCBYOCCURRENCETIME_SUPPORT      STD_OFF
[!ENDIF!]

#if (defined DEM_STORE_INTERNAL_EVENTS)
#error DEM_STORE_INTERNAL_EVENTS already defined
#endif
/** \brief Switch, indicating whether DTC=0 means event storage disabled */
[!IF "DemGeneral/DemStoreInternalEvents = 'true'"!]
  [!WS "0"!]#define DEM_STORE_INTERNAL_EVENTS       STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_STORE_INTERNAL_EVENTS       STD_OFF
[!ENDIF!]

#if (defined DEM_TRIGGER_FIM_REPORTS)
#error DEM_TRIGGER_FIM_REPORTS already defined
#endif
/** \brief Switch, indicating if notification to FiM is activated for Dem */
[!IF "DemGeneral/DemTriggerFiMReports = 'true'"!]
  [!WS "0"!]#define DEM_TRIGGER_FIM_REPORTS      STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_TRIGGER_FIM_REPORTS      STD_OFF
[!ENDIF!]

#if (defined DEM_SUPPORT_FIM_ON_FDC_TRESHOLD)
#error DEM_SUPPORT_FIM_ON_FDC_TRESHOLD already defined
#endif
/** \brief Switch, indicating if FiM support for FDC threshold is activated for Dem */
[!IF "node:exists(DemGeneral/DemSupportFiMFDCThreshold) and (DemGeneral/DemSupportFiMFDCThreshold = 'true')"!]
  [!WS "0"!]#define DEM_SUPPORT_FIM_ON_FDC_TRESHOLD      STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_SUPPORT_FIM_ON_FDC_TRESHOLD      STD_OFF
[!ENDIF!]

#if (defined DEM_TRIGGER_DCM_REPORTS)
#error DEM_TRIGGER_DCM_REPORTS already defined
#endif
/** \brief Switch, indicating if notification to Dcm is activated for Dem */
[!IF "DemGeneral/DemTriggerDcmReports = 'true'"!]
  [!WS "0"!]#define DEM_TRIGGER_DCM_REPORTS      STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_TRIGGER_DCM_REPORTS      STD_OFF
[!ENDIF!]


#if (defined DEM_USE_DYNAMIC_DTCS)
#error DEM_USE_DYNAMIC_DTCS already defined
#endif
/** \brief Macro for Enabling/Disabling dynamic DTC fetching */
[!IF "node:exists(DemGeneral/DemCalloutDynamicDTCFnc)"!]
  [!WS "0"!]#define DEM_USE_DYNAMIC_DTCS   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_USE_DYNAMIC_DTCS   STD_OFF
[!ENDIF!]

#if (defined DEM_EVCOMB_DISABLED)
#error DEM_EVCOMB_DISABLED already defined
#endif
/** \brief Macro used when no event combination is supported. */
#define DEM_EVCOMB_DISABLED                  0x00U

#if (defined DEM_EVCOMB_TYPE1)
#error DEM_EVCOMB_TYPE1  already defined
#endif
/** \brief Event combination is available and combined DTCs are stored/updated
    in a single event memory entry. */
#define DEM_EVCOMB_TYPE1                     0x01U

#if (defined DEM_EVENT_COMBINATION_SUPPORT)
#error DEM_EVENT_COMBINATION_SUPPORT already defined
#endif
/** \brief Macro for Enabling/Disabling event combination support. */
#define DEM_EVENT_COMBINATION_SUPPORT   [!"DemGeneral/DemEventCombinationSupport"!]
[!//
[!CALL "CREATE_DTCCLASS_LIST_FROM_EVENTS"!][!//
[!IF "DemGeneral/DemEventCombinationSupport = 'DEM_EVCOMB_TYPE1'"!][!//
#if (defined DEM_NUMBER_OF_DTCS)
#error DEM_NUMBER_OF_DTCS already defined
#endif
[!/* !LINKSTO dsn.Dem.EventCombination.Encapsulation,1 */!]
/** \brief Define the number of DTCs available when event combination is activated. */
#define DEM_NUMBER_OF_DTCS   [!"num:integer($DemNbOfDTCClasses)"!]U

#if (defined DEM_NUM_CMB_EVENTS)
#error DEM_NUM_CMB_EVENTS already defined
#endif
/** \brief Define the number of combined events. */
#define DEM_NUM_CMB_EVENTS   [!"num:integer($DemNbOfCmbEvents)"!]U
[!ENDIF!][!//

#if (defined DEM_NUM_CMB_DTCS)
#error DEM_NUM_CMB_DTCS already defined
#endif
/** \brief Define the number of combined DTCs.
 **
 ** This define will be present always in order to know if events are combined.
 ** Could be that event combination is configured and no events are combined.
 **/
#define DEM_NUM_CMB_DTCS   [!"num:integer($DemNbOfCmbDTCs)"!]U

#if (defined DEM_IDENTICAL_OBD_DTC_AVAILABLE)
#error DEM_IDENTICAL_OBD_DTC_AVAILABLE already defined
#endif
/** \brief Switch, indicating if there exists events with identical OBD DTC */
[!VAR "ListObdDTCs" = "''"!][!//
[!VAR "IdentObdDTCs" = "'STD_OFF'"!][!//
[!LOOP "DemConfigSet/*/DemEventParameter/*[node:refvalid(DemDTCClassRef)]"!][!//
  [!IF "node:exists(as:ref(./DemDTCClassRef)/DemObdDTC) = 'true'"!][!//
    [!VAR "ObdDTC" = "num:integer(as:ref(./DemDTCClassRef)/DemObdDTC)"!][!//
    [!IF "not(contains($ListObdDTCs, concat(' ', $ObdDTC)))"!][!//
      [!VAR "ListObdDTCs" = "concat($ListObdDTCs, ' ', $ObdDTC)"!][!//
    [!ELSE!][!//
      [!VAR "IdentObdDTCs" = "'STD_ON'"!][!//
      [!BREAK!][!//
    [!ENDIF!][!//
  [!ENDIF!][!//
[!ENDLOOP!][!//
#define DEM_IDENTICAL_OBD_DTC_AVAILABLE  [!"$IdentObdDTCs"!]

#if (defined DEM_INIT_MONITOR_REENABLED_SUPPORT)
#error DEM_INIT_MONITOR_REENABLED_SUPPORT already defined
#endif
 /** \brief Macro for Enabling/Disabling support for InitMonitorReason DEM_INIT_MONITOR_REENABLED */
[!IF "DemGeneral/DemCallbackInitMForEReenabledSupport = 'true'"!]
  [!WS "0"!]#define DEM_INIT_MONITOR_REENABLED_SUPPORT   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_INIT_MONITOR_REENABLED_SUPPORT   STD_OFF
[!ENDIF!]

#if (defined DEM_MAX_NUM_INIT_MONITOR_PER_CYCLE)
#error DEM_MAX_NUM_INIT_MONITOR_PER_CYCLE already defined
#endif
/* !LINKSTO Dem.ControlDTCSetting.InitMonitorRE.Config,1 */
/** \brief Maximum number of CallbackInitMonitorForEvent calls per scheduling. */
#define DEM_MAX_NUM_INIT_MONITOR_PER_CYCLE    [!"num:integer(DemGeneral/DemMaxHandledInitMonitorReenabledPerScheduling)"!]U

#if (defined DEM_USE_EVENT_DISPLACEMENT)
#error DEM_USE_EVENT_DISPLACEMENT already defined
#endif
/** \brief Switch, indicating if event displacement support is activated for
 ** Dem */
[!IF "DemGeneral/DemEventDisplacementSupport = 'true'"!]
  [!WS "0"!]#define DEM_USE_EVENT_DISPLACEMENT   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_USE_EVENT_DISPLACEMENT   STD_OFF
[!ENDIF!]

[!/* !LINKSTO Dem.EventDisplacement.TNCTOC.Config,1 */!][!//
#if (defined DEM_EVENT_DISPLACEMENT_CRITERION_TNCTOC)
#error DEM_EVENT_DISPLACEMENT_CRITERION_TNCTOC already defined
#endif
/** \brief Switch, indicating if TNCTOC event displacement extension is
 ** activated */
[!IF "as:modconf('Dem')[1]/DemGeneral/DemEventDisplacementCriterionTNCTOC = 'true'"!]
  [!WS "0"!]#define DEM_EVENT_DISPLACEMENT_CRITERION_TNCTOC STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_EVENT_DISPLACEMENT_CRITERION_TNCTOC STD_OFF
[!ENDIF!]

[!/* !LINKSTO ECUC_Dem_00796,1 */!][!//
#if (defined DEM_OBD_EVENT_DISPLACEMENT)
#error DEM_OBD_EVENT_DISPLACEMENT already defined
#endif
/** \brief Switch, indicating if OBD event displacement behavior is
 ** activated */
[!IF "as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDEventDisplacement = 'true'"!]
  [!WS "0"!]#define DEM_OBD_EVENT_DISPLACEMENT STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_EVENT_DISPLACEMENT STD_OFF
[!ENDIF!]

[!/* !LINKSTO dsn.Dem.Displacement.DemUseAdvancedEventDisplacement,1 */!][!//
#if (defined DEM_USE_ADVANCED_EVENT_DISPLACEMENT)
#error DEM_USE_ADVANCED_EVENT_DISPLACEMENT already defined
#endif
[!/* !LINKSTO VCC_DEM_007_Req192v1,1, dsn.Dem.Displacement.Advanced,1 */!][!//
[!IF "(as:modconf('Dem')[1]/DemGeneral/DemExtendedDataCapture = 'DEM_TRIGGER_ON_FDC_THRESHOLD') and
      (as:modconf('Dem')[1]/DemGeneral/DemEventDisplacementStrategy = 'DEM_DISPLACEMENT_FULL') and
      (as:modconf('Dem')[1]/DemGeneral/DemEventDisplacementSupport = 'true') and
      num:integer(count(DemConfigSet/*/DemAdvDisplacementPassiveTableLine/*)) > 0"!]
  [!WS "0"!]/** \brief advanced displacement used **/
  [!WS "0"!]#define DEM_USE_ADVANCED_EVENT_DISPLACEMENT STD_ON
  [!/* generate defines for number of configured passive table lines */!]
  [!INDENT "0"!]
      [!/* !LINKSTO dsn.Dem.Displacement.DemNumOfPassiveTableLines,1 */!][!//
      /** \brief define the number of passive table lines **/
      #if (defined DEM_NUM_OF_PASSIVE_TABLE_LINES)
      #error DEM_NUM_OF_PASSIVE_TABLE_LINES already defined
      #endif
      #define DEM_NUM_OF_PASSIVE_TABLE_LINES [!"num:integer(count(DemConfigSet/*/DemAdvDisplacementPassiveTableLine/*))"!]U
  [!ENDINDENT!]
  [!/* generate defines for number of configured passive refs per line */!][!//
  [!/* !LINKSTO dsn.Dem.Displacement.DemNumOfPassiveEventRefs,1 */!]
  [!VAR "NumOfLines" = "0"!]
  [!VAR "NumOfPassiveRefs" = "0"!]
  [!WS "0"!]/** \brief define the number of passive event refs per passive table line **/[!//
  [!LOOP "DemConfigSet/*/DemAdvDisplacementPassiveTableLine/*"!]
    [!INDENT "0"!]

        #if (defined DEM_NUM_OF_PASSIVE_EVENT_REFS_LINE[!"num:integer($NumOfLines)"!])
        #error DEM_NUM_OF_PASSIVE_EVENT_REFS_LINE[!"num:integer($NumOfLines)"!] already defined
        #endif
        #define DEM_NUM_OF_PASSIVE_EVENT_REFS_LINE[!"num:integer($NumOfLines)"!] [!"num:integer(count(./DemPassiveEventRefs/*))"!]U
      [!VAR "NumOfLines" = "$NumOfLines + 1"!]
    [!ENDINDENT!]
  [!ENDLOOP!]

  [!INDENT "0"!]
  [!/* !LINKSTO dsn.Dem.Displacement.DemAdvDisplacementOcc1Limit.Macro,1 */!][!//
  /* number of DemAdvDisplacementOcc1Limit */
  #if (defined DEM_ADV_PASSIVE_OCC1_LIMIT)
  #error DEM_ADV_PASSIVE_OCC1_LIMIT already defined
  #endif
  #define DEM_ADV_PASSIVE_OCC1_LIMIT  [!"DemGeneral/DemAdvDisplacementOcc1Limit"!]U
  [!ENDINDENT!]
[!ELSE!][!//
     [!WS "0"!]/** \brief advanced displacement not used **/
     [!WS "0"!]#define DEM_USE_ADVANCED_EVENT_DISPLACEMENT STD_OFF
[!ENDIF!]

#if (defined DEM_DISPLACEMENT_NONE)
#error DEM_DISPLACEMENT_NONE already defined
#endif
/** \brief Event memory entry displacement is disabled */
#define DEM_DISPLACEMENT_NONE                  0x00U

#if (defined DEM_DISPLACEMENT_PRIO_OCC)
#error DEM_DISPLACEMENT_PRIO_OCC already defined
#endif
/** \brief Event memory entry displacement is enabled, by consideration of
 ** priority and occurrence (but without active/passive status) */
#define DEM_DISPLACEMENT_PRIO_OCC              0x01U

#if (defined DEM_DISPLACEMENT_FULL)
#error DEM_DISPLACEMENT_FULL already defined
#endif
/** \brief Event memory entry displacement is enabled, by consideration of
 ** priority active/passive status, and occurrence */
#define DEM_DISPLACEMENT_FULL                  0x02U

#if (defined DEM_EVENT_DISPLACEMENT_STRATEGY)
#error DEM_EVENT_DISPLACEMENT_STRATEGY already defined
#endif
/** \brief Switch, indicating which displacement strategy is followed */
#define DEM_EVENT_DISPLACEMENT_STRATEGY [!"DemGeneral/DemEventDisplacementStrategy"!]

#ifndef DEM_STATUS_BIT_AGING_AND_DISPLACEMENT
/** \brief The "TestFailedSinceLastClear" status bits are reset to 0, if
 ** aging or displacement applies (like done for the "ConfirmedDTC" status
 ** bits) */
#define DEM_STATUS_BIT_AGING_AND_DISPLACEMENT  0x00U
#endif

#ifndef DEM_STATUS_BIT_NORMAL
/** \brief The aging and displacement has no impact on the
 ** "TestFailedSinceLastClear" status bits */
#define DEM_STATUS_BIT_NORMAL                  0x01U
#endif

#if (defined DEM_STATUS_BIT_HANDLING_TESTFAILEDSINCELASTCLEAR)
#error DEM_STATUS_BIT_HANDLING_TESTFAILEDSINCELASTCLEAR already defined
#endif
/** \brief Switch, indicating if the aging and displacement mechanism shall be
 ** applied to the "TestFailedSinceLastClear" status bits */
#define DEM_STATUS_BIT_HANDLING_TESTFAILEDSINCELASTCLEAR \
  [!"DemGeneral/DemStatusBitHandlingTestFailedSinceLastClear"!]

#if (defined DEM_CLRRESP_VOLATILE)
#error DEM_CLRRESP_VOLATILE already defined
#endif
#define DEM_CLRRESP_VOLATILE            0U

#if (defined DEM_CLRRESP_NONVOLATILE_TRIGGER)
#error DEM_CLRRESP_NONVOLATILE_TRIGGER already defined
#endif
#define DEM_CLRRESP_NONVOLATILE_TRIGGER 1U

#if (defined DEM_CLRRESP_NONVOLATILE_FINISH)
#error DEM_CLRRESP_NONVOLATILE_FINISH already defined
#endif
#define DEM_CLRRESP_NONVOLATILE_FINISH  2U

#if (defined DEM_CLEAR_DTC_BEHAVIOR)
#error DEM_CLEAR_DTC_BEHAVIOR already defined
#endif
/** \brief Behaviour of ClearDTC */
#define DEM_CLEAR_DTC_BEHAVIOR  [!"DemGeneral/DemClearDTCBehavior"!]

#if (defined DEM_OBD_DEP_SEC_ECU)
#error DEM_OBD_DEP_SEC_ECU already defined
#endif
#define DEM_OBD_DEP_SEC_ECU      0U

#if (defined DEM_OBD_MASTER_ECU)
#error DEM_OBD_MASTER_ECU already defined
#endif
#define DEM_OBD_MASTER_ECU       1U

#if (defined DEM_OBD_NO_OBD_SUPPORT)
#error DEM_OBD_NO_OBD_SUPPORT already defined
#endif
#define DEM_OBD_NO_OBD_SUPPORT   2U

#if (defined DEM_OBD_PRIMARY_ECU)
#error DEM_OBD_PRIMARY_ECU already defined
#endif
#define DEM_OBD_PRIMARY_ECU      3U

/* !LINKSTO ECUC_Dem_00698_1,1 */
#if (defined DEM_OBD_Support_Kind)
#error DEM_OBD_Support_Kind already defined
#endif
/* !LINKSTO Dem_OBD_0080,1 */
/** \brief Switch defines OBD support and kind of OBD ECU */
[!IF "DemGeneral/DemOBDSupport = 'true'"!][!//
  [!WS "0"!]#define DEM_OBD_Support_Kind    [!"DemGeneral/DemOBDSupportKind"!]
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_Support_Kind    DEM_OBD_NO_OBD_SUPPORT
[!ENDIF!][!//

#if (defined DEM_NUM_FFPARTS)
#error DEM_NUM_FFPARTS already defined
#endif
/** \brief The Number of freeze frame parts of an event entry
 **   (common + individual or only individual) */
[!IF "(node:refexists(DemGeneral/DemCommonFFDataClassRef)) or
      ( (DemGeneral/DemDevFreezeFrameSupport = 'true') and
        (node:refexists(DemGeneral/DemCommonFFDataDevAClassRef)) )"!]
  [!WS "0"!]#define DEM_NUM_FFPARTS     2U
[!ELSE!][!//
  [!WS "0"!]#define DEM_NUM_FFPARTS     1U
[!ENDIF!]

[!IF "$CalibrationSupport = 'true'"!]
  [!WS "0"!]#define DEM_STATIC
[!ELSE!]
  [!WS "0"!]#define DEM_STATIC  STATIC
[!ENDIF!]

/* !LINKSTO dsn.Dem.ProjectSpecificCustomization.Macro,1 */
#if (defined DEM_PROJECT_SPECIFIC_CUSTOMIZATION_SUPPORT)
#error DEM_PROJECT_SPECIFIC_CUSTOMIZATION_SUPPORT already defined
#endif
/** \brief Switch for user defined APIs support */
[!IF "DemGeneral/DemIncludeProjectSpecificCustomizationSupport = 'true'"!]
  [!WS "0"!]#define DEM_PROJECT_SPECIFIC_CUSTOMIZATION_SUPPORT    STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_PROJECT_SPECIFIC_CUSTOMIZATION_SUPPORT    STD_OFF
[!ENDIF!]

/*-----------------------[Event burst reduction]----------------------------*/
/* !LINKSTO dsn.Dem.EventBurstReduction.MaxPassed,1 */
#if (defined DEM_MAX_HANDLED_PASSED_EVENTS_PER_SCHEDULING)
#error DEM_MAX_HANDLED_PASSED_EVENTS_PER_SCHEDULING already defined
#endif
/** \brief The number of passed events handled per Dem_MainFunction call */
[!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemMaxHandledPassedEventsPerScheduling)"!][!//
  [!WS "0"!]#define DEM_MAX_HANDLED_PASSED_EVENTS_PER_SCHEDULING [!"DemGeneral/DemMaxHandledPassedEventsPerScheduling"!]U
[!ELSE!][!//
  [!WS "0"!]#define DEM_MAX_HANDLED_PASSED_EVENTS_PER_SCHEDULING 255U
[!ENDIF!][!//

/* !LINKSTO dsn.Dem.EventBurstReduction.MaxFailed,1 */
#if (defined DEM_MAX_HANDLED_FAILED_EVENTS_PER_SCHEDULING)
#error DEM_MAX_HANDLED_FAILED_EVENTS_PER_SCHEDULING already defined
#endif
/** \brief The number of failed events handled per Dem_MainFunction call */
[!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemMaxHandledFailedEventsPerScheduling)"!][!//
  [!WS "0"!]#define DEM_MAX_HANDLED_FAILED_EVENTS_PER_SCHEDULING [!"DemGeneral/DemMaxHandledFailedEventsPerScheduling"!]U
[!ELSE!][!//
  [!WS "0"!]#define DEM_MAX_HANDLED_FAILED_EVENTS_PER_SCHEDULING 255U
[!ENDIF!][!//

[!IF "(node:exists(as:modconf('Dem')[1]/DemGeneral/DemMILIndicatorRef)) and
      (DemGeneral/DemOBDSupport = 'true') and
      (node:refvalid(as:modconf('Dem')[1]/DemGeneral/DemMILIndicatorRef))"!]
/*---------------------------[MIL configuration]----------------------------*/

/* !LINKSTO Dem_OBD_0004,1 */
#if (defined DEM_MIL_ID)
#error DEM_MIL_ID already defined
#endif
#define DEM_MIL_ID [!"as:ref(as:modconf('Dem')[1]/DemGeneral/DemMILIndicatorRef)/DemIndicatorID"!]
[!ENDIF!]

/* !LINKSTO Dem_OBD_0001,2 */
#if (defined DEM_OBD_Support)
#error DEM_OBD_Support already defined
#endif
 /** \brief Switch, indicating if OBD functionalities are enabled */
[!IF "DemGeneral/DemOBDSupport = 'true'"!]
  [!WS "0"!]#define DEM_OBD_Support         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_Support         STD_OFF
[!ENDIF!]

/*---------------------------[J1939 configuration]----------------------------*/

#if (defined DEM_J1939_SUPPORT)
#error DEM_J1939_SUPPORT already defined
#endif
 /** \brief Switch, indicating if J1939 functionalities are enabled */
[!IF "DemGeneral/DemJ1939Support = 'true'"!]
  [!WS "0"!]#define DEM_J1939_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_SUPPORT         STD_OFF
[!ENDIF!][!//


[!IF "(DemGeneral/DemJ1939Support = 'true')"!][!//

[!IF "(node:exists(as:modconf('Dem')[1]/DemGeneral/DemAmberWarningLampIndicatorRef)) and
   (node:refvalid(as:modconf('Dem')[1]/DemGeneral/DemAmberWarningLampIndicatorRef))"!]
 /** \brief Amber Warning Indicator Lamp ID */
#if (defined DEM_AWIL_ID)
#error DEM_AWIL_ID already defined
#endif
#define DEM_AWIL_ID [!"as:ref(as:modconf('Dem')[1]/DemGeneral/DemAmberWarningLampIndicatorRef)/DemIndicatorID"!]
[!ENDIF!][!//
[!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemProtectLampIndicatorRef) and
   node:refvalid(as:modconf('Dem')[1]/DemGeneral/DemProtectLampIndicatorRef)"!]

 /** \brief Protect Indicator Lamp ID */
#if (defined DEM_PIL_ID)
#error DEM_PIL_ID already defined
#endif
#define DEM_PIL_ID [!"as:ref(as:modconf('Dem')[1]/DemGeneral/DemProtectLampIndicatorRef)/DemIndicatorID"!]
[!ENDIF!][!//
[!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemRedStopLampIndicatorRef) and
   node:refvalid(as:modconf('Dem')[1]/DemGeneral/DemRedStopLampIndicatorRef)"!]

 /** \brief Red Stop Indicator Lamp ID */
#if (defined DEM_RSIL_ID)
#error DEM_RSIL_ID already defined
#endif
#define DEM_RSIL_ID [!"as:ref(as:modconf('Dem')[1]/DemGeneral/DemRedStopLampIndicatorRef)/DemIndicatorID"!]
[!ENDIF!][!//
[!ENDIF!][!//

#if (defined DEM_J1939_READING_DTC_SUPPORT)
#error DEM_J1939_READING_DTC_SUPPORT already defined
#endif
 /** \brief Switch, indicating if J1939 Reading DTC functionalities are enabled */
[!IF "DemGeneral/DemGeneralJ1939/DemJ1939ReadingDtcSupport = 'true'"!]
  [!WS "0"!]#define DEM_J1939_READING_DTC_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_READING_DTC_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_RATIO_SUPPORT)
#error DEM_J1939_RATIO_SUPPORT already defined
#endif
 /** \brief Switch, indicating if J1939 Ratio functionalities are enabled */
[!IF "DemGeneral/DemGeneralJ1939/DemJ1939RatioSupport = 'true'"!]
  [!WS "0"!]#define DEM_J1939_RATIO_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_RATIO_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_READINESS1_SUPPORT)
#error DEM_J1939_READINESS1_SUPPORT already defined
#endif
 /** \brief Switch, indicating if J1939 Readiness1 functionalities are enabled */
[!IF "DemGeneral/DemGeneralJ1939/DemJ1939Readiness1Support = 'true'"!]
  [!WS "0"!]#define DEM_J1939_READINESS1_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_READINESS1_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_READINESS2_SUPPORT)
#error DEM_J1939_READINESS2_SUPPORT already defined
#endif
 /** \brief Switch, indicating if J1939 Readiness2 functionalities are enabled */
[!IF "DemGeneral/DemGeneralJ1939/DemJ1939Readiness2Support = 'true'"!]
  [!WS "0"!]#define DEM_J1939_READINESS2_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_READINESS2_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_READINESS3_SUPPORT)
#error DEM_J1939_READINESS3_SUPPORT already defined
#endif
 /** \brief Switch, indicating if J1939 Readiness3 functionalities are enabled */
[!IF "DemGeneral/DemGeneralJ1939/DemJ1939Readiness3Support = 'true'"!]
  [!WS "0"!]#define DEM_J1939_READINESS3_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_READINESS3_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_CLEAR_DTC_SUPPORT)
#error DEM_J1939_CLEAR_DTC_SUPPORT already defined
#endif
 /** \brief Switch, indicating if J1939 Clear DTC functionalities are enabled */
[!IF "DemGeneral/DemGeneralJ1939/DemJ1939ClearDTCSupport = 'true'"!]
  [!WS "0"!]#define DEM_J1939_CLEAR_DTC_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_CLEAR_DTC_SUPPORT         STD_OFF
[!ENDIF!][!//


#if (defined DEM_J1939_FREEZEFRAME_SUPPORT)
#error DEM_J1939_FREEZEFRAME_SUPPORT already defined
#endif
/** \brief Macro for Enabling/Disabling J1939 freeze frames functionality */
[!IF "as:modconf('Dem')[1]/DemGeneral/DemGeneralJ1939/DemJ1939FreezeFrameSupport = 'true' "!]
  [!WS "0"!]#define DEM_J1939_FREEZEFRAME_SUPPORT   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_FREEZEFRAME_SUPPORT   STD_OFF
[!ENDIF!]
/*---------------------[IUMPR function support ]----------------------------*/
/* !LINKSTO Dem.Config.IumprFunctionsEnabled,1 */
#if (defined DEM_IUMPR_FUNCTIONS_ENABLED)
#error DEM_IUMPR_FUNCTIONS_ENABLED already defined
#endif
/* Switch, indicating whether IUMPR related functions are enabled. */
[!IF "DemGeneral/DemOBDIumprFunctionsEnabled = 'true'"!]
  [!WS "0"!]#define DEM_IUMPR_FUNCTIONS_ENABLED         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_IUMPR_FUNCTIONS_ENABLED         STD_OFF
[!ENDIF!]

#if (defined DEM_OBD_COMPLIANCY_ENABLED)
#error DEM_OBD_COMPLIANCY_ENABLED already defined
#endif
[!IF "node:exists(DemGeneral/DemGeneralOBD/DemOBDCompliancy)"!]
  [!WS "0"!]#define DEM_OBD_COMPLIANCY_ENABLED         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_COMPLIANCY_ENABLED         STD_OFF
[!ENDIF!]

/*---------------------[OBD centralized PID handling]-----------------------*/

#if (defined DEM_OBD_CENTRALIZED_PID31_HANDLING)
#error DEM_OBD_CENTRALIZED_PID31_HANDLING already defined
#endif
 /** \brief Switch, indicating if PID$31 is calculated Dem internally (if set to 'false')
  ** or returned as 0 always (if set to 'true')*/
[!IF "DemGeneral/DemGeneralOBD/DemOBDCentralizedPID31Handling = 'false'"!]
  [!WS "0"!]#define DEM_OBD_CENTRALIZED_PID31_HANDLING         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_CENTRALIZED_PID31_HANDLING         STD_OFF
[!ENDIF!]

#if (defined DEM_OBD_CENTRALIZED_PID21_HANDLING)
#error DEM_OBD_CENTRALIZED_PID21_HANDLING already defined
#endif
 /** \brief Switch, indicating if PID$21 is calculated Dem internally (if set to 'false')
  ** or returned as 0 always (if set to 'true')*/
[!IF "DemGeneral/DemGeneralOBD/DemOBDCentralizedPID21Handling = 'false'"!]
  [!WS "0"!]#define DEM_OBD_CENTRALIZED_PID21_HANDLING         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_CENTRALIZED_PID21_HANDLING         STD_OFF
[!ENDIF!]

[!VAR "NumOfBytesInOBDFF" = "0"!]
[!VAR "MaxDataElementOffsetInPID" = "0"!]
[!VAR "MaxNumOfBytesInPidClass" = "0"!]
[!IF "DemGeneral/DemOBDSupport = 'true'"!]
/*-----------------------[OBD PID identifier ]------------------------------*/
  [!LOOP "DemConfigSet/*/DemPidClass/*"!]
    [!INDENT "0"!]

      #if (defined DEM_OBDFF_PID_[!"name(.)"!])
      #error DEM_OBDFF_PID_[!"name(.)"!] already defined
      #endif
      /** \brief PID Identifier of [!"name(.)"!] */
      /* !LINKSTO dsn.Dem.OBD.DEM_OBDFF_PID_NameOfPid,1 */
      #define DEM_OBDFF_PID_[!"name(.)"!] [!"num:integer(DemPidIdentifier)"!]U
    [!ENDINDENT!]
  [!ENDLOOP!]

  [!INDENT "0"!]
    /*------------------[Size of OBD FF in bytes]----------------------------*/
      [!LOOP "DemConfigSet/*/DemPidClass/*"!]
        [!VAR "NumOfBytesInPidClass" = "0"!]
        [!VAR "DataElementOffsetInPID" = "0"!]
        [!LOOP "DemPidDataElement/*/DemPidDataElementClassRef"!]
          [!VAR "DataElementOffsetInPID" = "$NumOfBytesInPidClass"!]
          [!VAR "NumOfBytesInOBDFF" = "$NumOfBytesInOBDFF + as:ref(.)/DemDataElementDataSize"!]
          [!VAR "NumOfBytesInPidClass" = "$NumOfBytesInPidClass + as:ref(.)/DemDataElementDataSize"!]
        [!ENDLOOP!]
        [!IF "$MaxDataElementOffsetInPID < $DataElementOffsetInPID"!]
          [!VAR "MaxDataElementOffsetInPID" = "$DataElementOffsetInPID"!]
        [!ENDIF!]
        [!IF "$MaxNumOfBytesInPidClass < $NumOfBytesInPidClass"!]
          [!VAR "MaxNumOfBytesInPidClass" = "$NumOfBytesInPidClass"!]
        [!ENDIF!]
      [!ENDLOOP!]
      #if (defined DEM_SIZE_OBDFF_DATA)
      #error DEM_SIZE_OBDFF_DATA already defined
      #endif
      /* !LINKSTO dsn.Dem.OBD.DEM_SIZE_OBDFF_DATA,1 */
      #define DEM_SIZE_OBDFF_DATA [!"num:integer($NumOfBytesInOBDFF)"!]U

  [!ENDINDENT!]
[!ENDIF!]

#if (defined DEM_MAX_SIZE_PID_CLASS)
#error DEM_MAX_SIZE_PID_CLASS already defined
#endif
/** \brief Maximum size of a PID class.
 ** This value is derived from the size of the configured PID DataElements for each PID. */
#define DEM_MAX_SIZE_PID_CLASS    [!"num:i($MaxNumOfBytesInPidClass)"!]U

#if (defined DEM_MAX_INDEX_PID_CLASS)
#error DEM_MAX_INDEX_PID_CLASS already defined
#endif
/** \brief Maximum index of a PID class.
 ** This value is derived from the index of the configured PID DataElements for each PID. */
#define DEM_MAX_INDEX_PID_CLASS    [!"num:i($MaxDataElementOffsetInPID)"!]U

/*-----[Indexes to access PID0D and PID1F within data element class]--------*/

[!IF "(count(DemGeneral/DemDataElementClass/*[. != 'DemInternalDataElementClass'])) > 0"!]
  [!INDENT "0"!]
  [!VAR "OBDTimeRequired" = "'false'"!]
  [!VAR "VehicleSpeedRequired" = "'false'"!]
  [!VAR "NumberOfElements" = "(count(DemGeneral/DemDataElementClass/*[. != 'DemInternalDataElementClass']))"!]
  [!VAR "PID1F_DataIndex" = "$NumberOfElements"!]
  [!VAR "PID0D_DataIndex" = "$NumberOfElements"!]
  [!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDTimeSinceEngineStart)"!]
    [!VAR "OBDTimeRequired" = "'true'"!]
    [!VAR "OBDTimeReference" = "name(as:ref(as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDTimeSinceEngineStart))"!]
  [!ENDIF!]
  [!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDInputVehicleSpeed)"!]
    [!VAR "VehicleSpeedRequired" = "'true'"!]
    [!VAR "VehicleSpeedReference" = "name(as:ref(as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDInputVehicleSpeed))"!]
  [!ENDIF!]
  [!VAR "Index" = "0"!]
  [!IF "(count(DemGeneral/DemDataElementClass/*[. = 'DemExternalCSDataElementClass'])) > 0"!]
    [!IF "($OBDTimeRequired = 'true') or ($VehicleSpeedRequired = 'true')"!]
      [!LOOP "DemGeneral/DemDataElementClass/*[. = 'DemExternalCSDataElementClass']"!]
        [!IF "$VehicleSpeedRequired = 'true'"!]
          [!IF "name(.) = $VehicleSpeedReference"!]
            [!VAR "PID0D_DataIndex" = "num:integer($Index)"!]
            [!VAR "VehicleSpeedRequired" = "'false'"!]
            [!IF "$OBDTimeRequired = 'false'"!]
              [!BREAK!]
            [!ENDIF!]
          [!ENDIF!]
        [!ENDIF!]
        [!IF "$OBDTimeRequired = 'true'"!]
          [!IF "name(.) = $OBDTimeReference"!]
            [!VAR "PID1F_DataIndex" = "num:integer($Index)"!]
            [!VAR "OBDTimeRequired" = "'false'"!]
            [!IF "$VehicleSpeedRequired = 'false'"!]
              [!BREAK!]
            [!ENDIF!]
          [!ENDIF!]
        [!ENDIF!]
        [!VAR "Index" = "$Index + 1"!]
      [!ENDLOOP!]
    [!ENDIF!]
  [!ENDIF!]
  [!IF "(count(DemGeneral/DemDataElementClass/*[. = 'DemExternalSRDataElementClass'])) > 0"!]
    [!IF "($OBDTimeRequired = 'true') or ($VehicleSpeedRequired = 'true')"!]
      [!LOOP "DemGeneral/DemDataElementClass/*[. = 'DemExternalSRDataElementClass']"!]
        [!IF "$VehicleSpeedRequired = 'true'"!]
          [!IF "name(.) = $VehicleSpeedReference"!]
            [!VAR "PID0D_DataIndex" = "num:integer($Index)"!]
            [!VAR "VehicleSpeedRequired" = "'false'"!]
            [!IF "$OBDTimeRequired = 'false'"!]
              [!BREAK!]
            [!ENDIF!]
          [!ENDIF!]
        [!ENDIF!]
        [!IF "$OBDTimeRequired = 'true'"!]
          [!IF "name(.) = $OBDTimeReference"!]
            [!VAR "PID1F_DataIndex" = "num:integer($Index)"!]
            [!VAR "OBDTimeRequired" = "'false'"!]
            [!IF "$VehicleSpeedRequired = 'false'"!]
              [!BREAK!]
            [!ENDIF!]
          [!ENDIF!]
        [!ENDIF!]
        [!VAR "Index" = "$Index + 1"!]
      [!ENDLOOP!]
    [!ENDIF!]
  [!ENDIF!]
  [!IF "$PID0D_DataIndex != $NumberOfElements"!]
    #if (defined DEM_OBD_INDEX_PID0D)
    #error DEM_OBD_INDEX_PID0D already defined
    #endif
    [!WS "0"!]#define DEM_OBD_INDEX_PID0D [!"num:integer($PID0D_DataIndex)"!]U
  [!ENDIF!]

  [!IF "$PID1F_DataIndex != $NumberOfElements"!]
    #if (defined DEM_OBD_INDEX_PID1F)
    #error DEM_OBD_INDEX_PID1F already defined
    #endif
    [!WS "0"!]#define DEM_OBD_INDEX_PID1F [!"num:integer($PID1F_DataIndex)"!]U
  [!ENDIF!]
  [!ENDINDENT!]
[!ENDIF!]

#if (defined DEM_MAINCYCLE_TICKS_PER_SECOND)
#error DEM_MAINCYCLE_TICKS_PER_SECOND already defined
#endif
#define DEM_MAINCYCLE_TICKS_PER_SECOND [!"num:integer(1 div (DemGeneral/DemTaskTime))"!]U

/*------------------[Extended data configuration]---------------------------*/

/* Symbolic names of configured extended data record numbers */
[!LOOP "DemGeneral/DemExtendedDataRecordClass/*"!]
  [!INDENT "0"!]

    #if (defined DEM_EDS_NUM_[!"name(.)"!])
    #error DEM_EDS_NUM_[!"name(.)"!] already defined
    #endif
    /** \brief Symbolic name of extended data [!"name(.)"!] */
    #define DEM_EDS_NUM_[!"name(.)"!] [!"num:integer(DemExtendedDataRecordNumber)"!]U
  [!ENDINDENT!]
[!ENDLOOP!]

/* DEM_TRIGGER_<...> macros used for DEM_EXTENDED_DATA_CAPTURE are
 * defined in section 'Freeze frame configuration' */

#if (defined DEM_EXTENDED_DATA_CAPTURE)
#error DEM_EXTENDED_DATA_CAPTURE already defined
#endif
/** \brief Type of extended data capture trigger
 **
 ** This parameter defines the point in time, when the extended data
 ** collection is done for the initial event memory entry.
 **/
#define DEM_EXTENDED_DATA_CAPTURE     [!"DemGeneral/DemExtendedDataCapture"!]

#if (defined DEM_NUM_EVENT_PRIORITIES)
#error DEM_NUM_EVENT_PRIORITIES already defined
#endif
[!CALL "GET_NUMBER_OF_EVENT_PRIORITIES"!]
/** \brief Used for defining size of Dem_ExternalPrioValue array */
#define DEM_NUM_EVENT_PRIORITIES      [!"num:integer($NumberOfPriorities)"!]

/*------------------[Fault confirmation configurations]---------------------*/

#if (defined DEM_NUM_FAILURECYCLES)
#error DEM_NUM_FAILURECYCLES already defined
#endif
[!/* create unique list of all configured
 * failure cycle counter cycles and thresholds */!][!//
[!CALL "CREATE_FAILURE_COUNTER_CYCLE_LIST"!]
/** \brief Number of fault confirmation configurations */
#define DEM_NUM_FAILURECYCLES [!"num:integer($EventFailureClassIdx)"!]U

#if (defined DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT_FAULT_CONFIRMATION)
#error DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT_FAULT_CONFIRMATION already defined
#endif
/** \brief Switch, indicating support for fault confirmation without event memory entry */
[!IF "( (DemGeneral/DemResetConfirmedBitOnOverflow = 'false') and (num:integer($EventFailureClassIdx) > 0) )"!]
  [!WS "0"!]#define DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT_FAULT_CONFIRMATION     STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT_FAULT_CONFIRMATION     STD_OFF
[!ENDIF!]

#if (defined DEM_STATUS_COUNTER_SIZE)
#error DEM_STATUS_COUNTER_SIZE already defined
#endif
/** \brief Number of status counters in ::Dem_NvData
 ** per non-combined event with fault confirmation enabled */
[!VAR "StatusCounterSize" = "0"!]
[!IF "DemGeneral/DemResetConfirmedBitOnOverflow = 'false'"!]
  [!VAR "StatusCounterSize" = "count((DemConfigSet/*/DemEventParameter/*[not(node:exists(DemEvtCmbCommonParamMaster)) and node:exists(DemEventClass/DemEventFailureCycleCounterThreshold)]))"!]
[!ENDIF!]
#define DEM_STATUS_COUNTER_SIZE   [!"num:integer($StatusCounterSize)"!]U

/*------------------[Memory size configuration]-----------------------------*/

/* !LINKSTO dsn.Dem.ErrorQueueOpt,1 */
#if (defined DEM_BSW_ERROR_BUFFER_SIZE)
#error DEM_BSW_ERROR_BUFFER_SIZE already defined
#endif
/** \brief Maximal number of error-queue entries
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_BSW_ERROR_BUFFER_SIZE [!"num:integer(DemGeneral/DemBswErrorBufferSize)"!]U

[!//
[!/* Number of PIDs to be stored in OBD freeze frame */!][!//
[!VAR "NumOfPidInOBDFF" = "num:integer(count(as:modconf('Dem')[1]/DemConfigSet/*/DemPidClass/*))"!]
[!//
[!VAR "MaxFFSizePrimary" = "-1"!]
[!VAR "MaxFFSizeSecondary" = "-1"!]
[!VAR "MaxFFSizeMirror" = "-1"!]
[!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntryPrimary)"!]
  [!VAR "MaxFFSizePrimary" = "DemGeneral/DemMaxSizeFreezeFrameEntryPrimary"!]
[!ENDIF!]
[!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntrySecondary)"!]
  [!VAR "MaxFFSizeSecondary" = "DemGeneral/DemMaxSizeFreezeFrameEntrySecondary"!]
[!ENDIF!]
[!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntryMirror)"!]
  [!VAR "MaxFFSizeMirror" = "DemGeneral/DemMaxSizeFreezeFrameEntryMirror"!]
[!ENDIF!]
[!/* --- Size of common freeze frame */!][!//
[!VAR "CommonFFName" = "''"!]
[!VAR "CommonFFSize" = "0"!]
[!VAR "CommonFFNumDid" = "0"!]
[!IF "node:refexists(DemGeneral/DemCommonFFDataClassRef)"!]
  [!VAR "CommonFFName" = "name(as:ref(DemGeneral/DemCommonFFDataClassRef))"!]
  [!SELECT "node:ref(DemGeneral/DemCommonFFDataClassRef)"!]
    [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
  [!ENDSELECT!]
  [!VAR "CommonFFSize" = "$SizeOfFreezeFrameClass"!]
  [!VAR "CommonFFNumDid" = "$SizeOfFreezeFrameClassNumDid"!]
[!ENDIF!]
[!/* --- Size of common development freeze frame A (DevFF A) */!][!//
[!VAR "CommonDevFFASize" = "0"!]
[!VAR "CommonDevFFANumDid" = "0"!]
[!IF "(DemGeneral/DemDevFreezeFrameSupport = 'true') and
      (node:refexists(DemGeneral/DemCommonFFDataDevAClassRef))"!]
  [!SELECT "node:ref(DemGeneral/DemCommonFFDataDevAClassRef)"!]
    [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
  [!ENDSELECT!]
  [!VAR "CommonDevFFASize" = "$SizeOfFreezeFrameClass"!]
  [!VAR "CommonDevFFANumDid" = "$SizeOfFreezeFrameClassNumDid"!]
[!ENDIF!]
[!/* --- Create event lists with largest event related data */!][!//
[!VAR "ListPrm" = "''"!]
[!VAR "ListSec" = "''"!]
[!VAR "ListMir" = "''"!]
[!VAR "FFASizeLargest" = "0"!]
[!VAR "FFBSizeLargest" = "0"!]
[!IF "(node:exists(DemGeneral/DemMaxSizeDevFreezeFrameAEntry))"!]
  [!VAR "MaxSizeDevFFA" = "num:integer(DemGeneral/DemMaxSizeDevFreezeFrameAEntry)"!]
[!ENDIF!]
[!IF "(node:exists(DemGeneral/DemMaxSizeDevFreezeFrameBEntry))"!]
  [!VAR "MaxSizeDevFFB" = "num:integer(DemGeneral/DemMaxSizeDevFreezeFrameBEntry)"!]
[!ENDIF!]
[!VAR "NumberOfEventsSupportingAging" = "num:integer(count(DemConfigSet/*/DemEventParameter/*[DemEventClass/DemAgingAllowed = 'true']))"!]
[!LOOP "DemConfigSet/*/DemEventParameter/*[not(node:exists(DemEvtCmbCommonParamMaster)) or (DemEvtCmbCommonParamMaster = 'true')]"!]
  [!VAR "IntValSize" = "0"!]
  [!VAR "AgingSupport" = "'false'"!]
  [!IF "(./DemEventClass/DemAgingAllowed = 'true') or (($CalibrationSupport = 'true') and ($NumberOfEventsSupportingAging > 0))"!]
    [!VAR "AgingSupport" = "'true'"!]
  [!ENDIF!]
  [!IF "$AgingSupport = 'true'"!]
    [!VAR "IntValSize" = "$IntValSize + 1"!]
  [!ENDIF!]
  [!VAR "EDSize" = "0"!]
  [!IF "node:refexists(DemExtendedDataClassRef)"!]
    [!LOOP "as:ref(DemExtendedDataClassRef)/DemExtendedDataRecordClassRef/*"!]
      [!LOOP "as:ref(.)/DemDataElementClassRef/*"!]
[!/*      internal data elements will not be stored inside ED-area */!][!//
        [!IF "as:ref(.) != 'DemInternalDataElementClass'"!]
          [!VAR "EDSize" = "$EDSize + as:ref(.)/DemDataElementDataSize"!]
        [!ENDIF!]
      [!ENDLOOP!]
    [!ENDLOOP!]
  [!ENDIF!]
[!/* --- regular freeze frames */!][!//
  [!VAR "FFSize" = "0"!]
  [!VAR "NumDid" = "0"!]
  [!VAR "NumFFRecords" = "0"!]
  [!IF "node:refexists(DemFreezeFrameClassRef)"!]
    [!SELECT "node:ref(DemFreezeFrameClassRef)"!]
      [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
    [!ENDSELECT!]
    [!VAR "FFSize" = "$CommonFFSize + $SizeOfFreezeFrameClass"!]
    [!VAR "NumDid" = "$SizeOfFreezeFrameClassNumDid + $CommonFFNumDid"!]
    [!CALL "GET_NUM_FF_RECORDS"!]
  [!ELSEIF "node:exists(../../../../DemGeneral/DemCommonFFDataClassRef)"!]
    [!VAR "FFSize" = "$CommonFFSize"!]
    [!VAR "NumDid" = "$CommonFFNumDid"!]
    [!CALL "GET_NUM_FF_RECORDS"!]
  [!ENDIF!]
[!/* --- DevFFA */!][!//
  [!VAR "DevFFASize" = "0"!]
  [!VAR "DevFFANumDid" = "0"!][!//
  [!IF "../../../../DemGeneral/DemDevFreezeFrameSupport = 'true'"!]
    [!IF "node:refexists(DemDevFreezeFrameAClassRef)"!]
      [!SELECT "node:ref(DemDevFreezeFrameAClassRef)"!]
        [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
      [!ENDSELECT!]
      [!VAR "DevFFASize" = "$CommonDevFFASize + $SizeOfFreezeFrameClass"!]
      [!VAR "DevFFANumDid" = "$SizeOfFreezeFrameClassNumDid + $CommonDevFFANumDid"!]
    [!ELSEIF "node:exists(../../../../DemGeneral/DemCommonFFDataDevAClassRef)"!]
      [!VAR "DevFFASize" = "$CommonDevFFASize"!]
      [!VAR "DevFFANumDid" = "$CommonDevFFANumDid"!]
    [!ENDIF!]
    [!IF "$FFASizeLargest < $DevFFASize"!]
      [!VAR "FFASizeLargest" = "$DevFFASize"!]
    [!ENDIF!]
  [!ENDIF!]
[!//
[!/* --- DevFFB */!][!//
  [!VAR "DevFFBSize" = "0"!]
  [!VAR "DevFFBNumDid" = "0"!]
  [!IF "../../../../DemGeneral/DemDevFreezeFrameSupport = 'true'"!]
    [!IF "node:refexists(DemDevFreezeFrameBClassRef)"!]
      [!SELECT "node:ref(DemDevFreezeFrameBClassRef)"!]
        [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
      [!ENDSELECT!]
      [!VAR "DevFFBSize" = "$SizeOfFreezeFrameClass"!]
      [!VAR "DevFFBNumDid" = "$SizeOfFreezeFrameClassNumDid"!]
    [!ENDIF!]
    [!IF "$FFBSizeLargest < $DevFFBSize"!]
      [!VAR "FFBSizeLargest" = "$DevFFBSize"!]
    [!ENDIF!]
  [!ENDIF!]
[!//
  [!IF "$ConsistentFFSize = 'true'"!]
    [!IF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_PRIMARY_MEMORY'"!]
      [!VAR "MaxFFSize" = "$MaxFFSizePrimary"!]
    [!ELSEIF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_SECONDARY_MEMORY'"!]
      [!VAR "MaxFFSize" = "$MaxFFSizeSecondary"!]
    [!ELSEIF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_MIRROR_MEMORY'"!]
      [!VAR "MaxFFSize" = "$MaxFFSizeMirror"!]
    [!ELSE!][!//
      [!VAR "MaxFFSize" = "0"!]
    [!ENDIF!]
    [!IF "(node:exists(../../../../DemGeneral/DemMaxSizeDevFreezeFrameAEntry))"!]
      [!IF "($MaxSizeDevFFA) < ($FFASizeLargest)"!]
        [!ERROR!]The largest configured Development Freeze Frame A Class ([!"$FFASizeLargest"!] bytes) is greater than DemMaxSizeDevFreezeFrameAEntry ([!"$MaxSizeDevFFA"!] bytes)[!ENDERROR!]
      [!ELSE!]
        [!VAR "FFASizeLargest" = "$MaxSizeDevFFA"!]
      [!ENDIF!]
    [!ENDIF!]
    [!IF "(node:exists(../../../../DemGeneral/DemMaxSizeDevFreezeFrameBEntry))"!]
      [!IF "($MaxSizeDevFFB) < ($FFBSizeLargest)"!]
        [!ERROR!]The largest configured Development Freeze Frame B Class ([!"num:integer($FFBSizeLargest)"!] bytes) is greater than DemMaxSizeDevFreezeFrameBEntry ([!"$MaxSizeDevFFB"!] bytes)[!ENDERROR!]
      [!ELSE!]
        [!VAR "FFBSizeLargest" = "$MaxSizeDevFFB"!]
      [!ENDIF!]
    [!ENDIF!]
    [!IF "$FFSize > $MaxFFSize"!]
      [!IF "$MaxFFSize != -1"!]
        [!IF "node:refexists(DemFreezeFrameClassRef)"!]
          [!ERROR!]The size of freeze frame '[!"name(as:ref(DemFreezeFrameClassRef))"!]'[!IF "$CommonFFName != ''"!] including common freeze frame '[!"$CommonFFName"!]'[!ENDIF!] ([!"num:integer($FFSize)"!] bytes) is bigger than the maximal allowed size of [!"num:integer($MaxFFSize)"!] bytes. Increase maximal freeze frame size for [!"DemEventClass/DemEventDestination"!].[!ENDERROR!]
        [!ELSE!]
          [!ERROR!]The size of common freeze frame '[!"$CommonFFName"!]' ([!"num:integer($FFSize)"!] bytes) is bigger than the maximal allowed size of [!"num:integer($MaxFFSize)"!] bytes. Increase maximal freeze frame size for [!"DemEventClass/DemEventDestination"!].[!ENDERROR!]
        [!ENDIF!]
      [!ENDIF!]
    [!ELSE!]
[!/* Use configured maximum freeze frame size */!][!//
      [!VAR "FFSize" = "$MaxFFSize"!]
    [!ENDIF!]
  [!ENDIF!]
[!/* Check maximum SizeOfFreezeFrame in Dem_GetSizeOfFreezeFrameSelection */!]
  [!VAR "SizeOfRegularFreezeFrame" = "$FFSize + (2 * $NumDid) + 2"!]
  [!VAR "SizeOfDevFreezeFrameA" = "$DevFFASize + (2 * $DevFFANumDid) + 2"!]
  [!VAR "SizeOfDevFreezeFrameB" = "$DevFFBSize + (2 * $DevFFBNumDid) + 2"!]
  [!VAR "SizeOfOBDFreezeFrame" = "$NumOfBytesInOBDFF + (2 * $NumOfPidInOBDFF)"!]
  [!VAR "TotalSizeOfFreezeFrames" = "($SizeOfRegularFreezeFrame * $NumFFRecords) + $SizeOfDevFreezeFrameA + $SizeOfDevFreezeFrameB + $SizeOfOBDFreezeFrame"!]
[!/* !LINKSTO dsn.Dem.FreezeFrameSize.MaxSize,1 */!]
  [!IF "$TotalSizeOfFreezeFrames > 65535"!]
    [!ERROR!]In Dem_GetSizeOfFreezeFrameSelection() the SizeOfFreezeFrame could be 65535 as maximum. In the current configuration of event [!"name(.)"!] this size is exceeded! Please reduce the size of referred freeze frame classes, the number of freeze frame records, or disable some freeze frames kindes[!ENDERROR!]
  [!ENDIF!]
[!/* -- J1939 Freeze Frames --*/!][!//
[!VAR "J1939FFSize" = "0"!]
[!IF "node:refexists(DemJ1939FreezeFrameClassRef) and (as:modconf('Dem')[1]/DemGeneral/DemGeneralJ1939/DemJ1939FreezeFrameSupport = 'true')"!]
[!LOOP "as:ref(DemJ1939FreezeFrameClassRef)/DemSPNClassRef/*"!]
    [!IF "as:ref(as:ref(.)/DemSPNDataElementClassRef) != 'DemInternalDataElementClass'"!]
        [!VAR "J1939FFSize" = "$J1939FFSize + as:ref(as:ref(.)/DemSPNDataElementClassRef)/DemDataElementDataSize"!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDIF!]
[!/* Calculate Entry Size */!][!//
  [!VAR "EntrySize" = "num:integer($IntValSize + $EDSize + $NumFFRecords * $FFSize + $J1939FFSize)"!]
  [!IF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_PRIMARY_MEMORY'"!]
    [!VAR "ListPrm" = "concat($ListPrm, ' ', $EntrySize)"!]
  [!ENDIF!]
  [!IF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_SECONDARY_MEMORY'"!]
    [!VAR "ListSec" = "concat($ListSec, ' ', $EntrySize)"!]
  [!ENDIF!]
  [!IF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_MIRROR_MEMORY'"!]
    [!VAR "ListMir" = "concat($ListMir, ' ', $EntrySize)"!]
  [!ENDIF!]
  [!INDENT "0"!]
    /* [!"DemEventClass/DemEventDestination"!] - Event [!"name(.)"!][!//
    [!IF "DemEvtCmbCommonParamMaster = 'true'"!]
      [!WS!]- Combined DTC Master Configuration Event[!//
    [!ENDIF!]
    :
    [!WS "3"!][!//
    [!IF "$AgingSupport = 'true'"!]
      aging counter value [!//
    [!ELSE!]
      no internal values [!//
    [!ENDIF!]
    + [!//
    [!IF "node:refexists(DemExtendedDataClassRef)"!]
      [!"name(as:ref(DemExtendedDataClassRef))"!] [!//
    [!ELSE!]
      no extended data [!//
    [!ENDIF!]
    + [!//
    [!IF "node:refexists(DemFreezeFrameClassRef)"!]
      [!"num:integer($NumFFRecords)"!]
      [!WS "2"!] * ([!"name(as:ref(DemFreezeFrameClassRef))"!] + [!"$CommonFFName"!]) [!//
    [!ELSE!]
      no freeze frames [!//
    [!ENDIF!]
    = [!"$EntrySize"!] */
  [!ENDINDENT!]
[!ENDLOOP!]
/* entry data sizes (IntVal + ED + Num * FF) of prm memory:
[!WS "2"!][!"$ListPrm"!] */
/* entry data sizes (IntVal + ED + Num * FF) of sec memory:
[!WS "2"!][!"$ListSec"!] */
/* entry data sizes (IntVal + ED + Num * FF) of mir memory:
[!WS "2"!][!"$ListMir"!] */

#if (defined DEM_SIZE_GATE_ENTRY_DATA_PRIMARY)
#error DEM_SIZE_GATE_ENTRY_DATA_PRIMARY already defined
#endif
/** \brief Gate entry size for primary memory
 **
 ** If immediate storage is enabled for any of the events in primary memory
 ** then this size is maximum of the highest primary event memory size
 ** considering IntVal, extended data freeze frames, and J1939 Freeze frame.
 ** If maximum calculated size is 0, then default 1 is used.
 */
[!VAR "MaxEntrySize" = "1"!]
[!FOR "j" = "1" TO "count(text:split($ListPrm))"!]
  [!VAR "CurEntrySize" = "text:split($ListPrm)[position() = $j]"!]
  [!IF "$MaxEntrySize < $CurEntrySize"!]
    [!VAR "MaxEntrySize" = "$CurEntrySize"!]
  [!ENDIF!]
[!ENDFOR!]
#define DEM_SIZE_GATE_ENTRY_DATA_PRIMARY   [!"num:integer($MaxEntrySize)"!]U

#if (defined DEM_SIZE_GATE_ENTRY_DATA_SECONDARY)
#error DEM_SIZE_GATE_ENTRY_DATA_SECONDARY already defined
#endif
/** \brief Gate entry size for secondary memory
 **
 ** If immediate storage is enabled for any of the events in secondary memory
 ** then this size is maximum of the highest secondary event memory size
 ** considering IntVal, extended data and freeze frames.
 ** If maximum calculated size is 0, then default 1 is used.
 */
[!VAR "MaxEntrySize" = "1"!]
[!FOR "j" = "1" TO "count(text:split($ListSec))"!]
  [!VAR "CurEntrySize" = "text:split($ListSec)[position() = $j]"!]
  [!IF "$MaxEntrySize < $CurEntrySize"!]
    [!VAR "MaxEntrySize" = "$CurEntrySize"!]
  [!ENDIF!]
[!ENDFOR!]
#define DEM_SIZE_GATE_ENTRY_DATA_SECONDARY [!"num:integer($MaxEntrySize)"!]U

#if (defined DEM_SIZE_GATE_ENTRY_DATA_MIRROR)
#error DEM_SIZE_GATE_ENTRY_DATA_MIRROR already defined
#endif
/** \brief Gate entry size for mirror memory
 **
 ** If immediate storage is enabled for any of the events in mirror memory
 ** then this size is maximum of the highest mirror event memory size
 ** considering IntVal, extended data and freeze frames.
 ** If maximum calculated size is 0, then default 1 is used.
 */
[!VAR "MaxEntrySize" = "1"!]
[!FOR "j" = "1" TO "count(text:split($ListMir))"!]
  [!VAR "CurEntrySize" = "text:split($ListMir)[position() = $j]"!]
  [!IF "$MaxEntrySize < $CurEntrySize"!]
    [!VAR "MaxEntrySize" = "$CurEntrySize"!]
  [!ENDIF!]
[!ENDFOR!]
#define DEM_SIZE_GATE_ENTRY_DATA_MIRROR    [!"num:integer($MaxEntrySize)"!]U

#if (defined DEM_SIZE_GATE_ENTRY_DATA_PERMANENT)
#error DEM_SIZE_GATE_ENTRY_DATA_PERMANENT already defined
#endif
/** \brief Gate entry size for permanent memory
 **
 ** As this event memory type is not supported this shall be default 1.
 */
#define DEM_SIZE_GATE_ENTRY_DATA_PERMANENT 1U

#if (defined DEM_USE_IMMEDIATE_NV_STORAGE)
#error DEM_USE_IMMEDIATE_NV_STORAGE already defined
#endif
/** \brief Switch, indicating if Immediate storage of event memory entries in
 ** NvM is activated for Dem
 **
 ** This can be the case if any DTC is configured to be stored immediately, or
 ** if ClearDTC behavior is configured to non-volatile triggered or finished.
 */
#define DEM_USE_IMMEDIATE_NV_STORAGE  [!//
[!IF "(count(DemConfigSet/*/DemEventParameter/*[node:refexists(DemDTCClassRef) and as:ref(DemDTCClassRef)/DemImmediateNvStorage = 'true']) > 0) or
      (DemGeneral/DemImmediateStorageInternalEvents = 'true') or (contains(node:value(DemGeneral/DemClearDTCBehavior), 'NONVOLATILE'))"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_NV_STORAGE_EMPTY_EVMEM_ENTRIES)
#error DEM_NV_STORAGE_EMPTY_EVMEM_ENTRIES already defined
#endif
/* !LINKSTO Dem.NvStorageEmptyEvMemEntries.Config,1 */
/** \brief Switch, indicating if empty event memory entries will be
 ** initialized in NVRAM
 **
 ** If the restoration of an event memory entry from NvM was not successful,
 ** this switch controls (esp. for ::DEM_USE_IMMEDIATE_NV_STORAGE = ON) if
 ** this entry is initialized with default values during next shutdown.
 */
#define DEM_NV_STORAGE_EMPTY_EVMEM_ENTRIES  [!//
[!IF "not(node:exists(DemGeneral/DemNvStorageEmptyEventMemoryEntries)) or (node:value(DemGeneral/DemNvStorageEmptyEventMemoryEntries) = 'true')"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)

#if (defined DEM_IMMEDIATE_CLEARED)
#error DEM_IMMEDIATE_CLEARED already defined
#endif
/** \brief Immediate storage configuration value: store CLEARED entries */
#define DEM_IMMEDIATE_CLEARED 0U

#if (defined DEM_IMMEDIATE_CHANGED)
#error DEM_IMMEDIATE_CHANGED already defined
#endif
/** \brief Immediate storage configuration value: store ALL entries */
#define DEM_IMMEDIATE_CHANGED 1U

#if (defined DEM_IMMEDIATE_NV_STORAGE_TYPE)
#error DEM_IMMEDIATE_NV_STORAGE_TYPE already defined
#endif
/** \brief Immediate storage configuration */
#define DEM_IMMEDIATE_NV_STORAGE_TYPE  [!//
[!IF "((count(DemConfigSet/*/DemEventParameter/*[node:refexists(DemDTCClassRef) and as:ref(DemDTCClassRef)/DemImmediateNvStorage = 'true']) > 0) or
       (DemGeneral/DemImmediateStorageInternalEvents = 'true')) and
      (count(DemGeneral/DemNvRamBlockId/*) > 0)"!]
  DEM_IMMEDIATE_CHANGED
[!ELSE!][!//
  DEM_IMMEDIATE_CLEARED
[!ENDIF!]

#endif /* (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON) */

#if (defined DEM_IMMEDIATE_NV_STORAGE_LIMIT)
#error DEM_IMMEDIATE_NV_STORAGE_LIMIT already defined
#endif
/** \brief Immediate NvM storage limit
 **
 ** Defines the maximum number of occurrences, a specific event memory entry
 ** is allowed, to be stored in NVRAM immediately.
 ** Its value is set to 0 when the immediate storage limit feature is
 ** disabled by the user. In that case, there is no limit for the storage to
 ** NVRAM and whenever the entry gets updated, it can be stored immediately
 ** to NVRAM if immediate storage is enabled for it.
 **/
#define DEM_IMMEDIATE_NV_STORAGE_LIMIT   [!//
[!IF "node:exists(DemGeneral/DemImmediateNvStorageLimit)"!]
  [!"num:integer(DemGeneral/DemImmediateNvStorageLimit)"!]U
[!ELSE!][!//
  0U
[!ENDIF!]

#if (defined DEM_ZERO_END)
#error DEM_ZERO_END already defined
#endif
/** \brief Zero value to be added to each size, whose involved patterns could
 ** be none */
#define DEM_ZERO_END                  0U

#if (defined DEM_SIZE_ENTRY_DATA_PRIMARY)
#error DEM_SIZE_ENTRY_DATA_PRIMARY already defined
#endif
/** \brief Size of dynamic primary entry data
 **
 ** The N (primary memory entry number) maximal sizes are added.
 **
 ** \note The DEM_ZERO_END is not necessary here, because primary event memory
 **       is always > 0.
 **/
#define DEM_SIZE_ENTRY_DATA_PRIMARY   \
  ([!//
  [!FOR "i" = "1" TO "DemGeneral/DemMaxNumberEventEntryPrimary"!]
    [!VAR "MaxEntrySize" = "0"!]
    [!FOR "j" = "1" TO "count(text:split($ListPrm))"!]
      [!VAR "CurEntrySize" = "text:split($ListPrm)[position() = $j]"!]
      [!IF "$MaxEntrySize < $CurEntrySize"!]
        [!VAR "MaxEntrySize" = "$CurEntrySize"!]
      [!ENDIF!]
    [!ENDFOR!]
    [!INDENT "0"!]
      [!"num:integer($MaxEntrySize)"!]U[!//
      [!IF "$i < DemGeneral/DemMaxNumberEventEntryPrimary"!]
        [!WS!]+ [!//
      [!ENDIF!]
    [!ENDINDENT!]
    [!VAR "ListPrm" = "text:replace($ListPrm, $MaxEntrySize, '')"!]
  [!ENDFOR!]
  )
/* !LINKSTO dsn.Dem.Dem_EntryData.MaxSize,1 */
#if DEM_SIZE_ENTRY_DATA_PRIMARY > 0xFFFFU
#error The total size of the dynamic primary entry data exceed 65535 byte. \
  Please reduce size or remove Extended Data Recordes, Freeze Frame Classes, or \
  number of Freeze Frame Records to reduce the needed space.
#endif

#if (defined DEM_SIZE_ENTRY_DATA_SECONDARY)
#error DEM_SIZE_ENTRY_DATA_SECONDARY already defined
#endif
/** \brief Size of dynamic secondary entry data
 **
 ** The N (secondary memory entry number) maximal sizes are added.
 **/
#define DEM_SIZE_ENTRY_DATA_SECONDARY \
  ([!//
  [!FOR "i" = "1" TO "DemGeneral/DemMaxNumberEventEntrySecondary"!]
    [!VAR "MaxEntrySize" = "0"!]
    [!FOR "j" = "1" TO "count(text:split($ListSec))"!]
      [!VAR "CurEntrySize" = "text:split($ListSec)[position() = $j]"!]
      [!IF "$MaxEntrySize < $CurEntrySize"!]
        [!VAR "MaxEntrySize" = "$CurEntrySize"!]
      [!ENDIF!]
    [!ENDFOR!]
    [!WS "0"!][!"num:integer($MaxEntrySize)"!]U + [!//
    [!VAR "ListSec" = "text:replace($ListSec, $MaxEntrySize, '')"!]
  [!ENDFOR!]
  DEM_ZERO_END)
/* !LINKSTO dsn.Dem.Dem_EntryData.MaxSize,1 */
#if DEM_SIZE_ENTRY_DATA_SECONDARY > 0xFFFFU
#error The total size of the dynamic secondary entry data exceed 65535 byte. \
  Please reduce size or remove Extended Data Recordes, Freeze Frame Classes, or \
  number of Freeze Frame Records to reduce the needed space.
#endif

#if (defined DEM_SIZE_ENTRY_DATA_MIRROR)
#error DEM_SIZE_ENTRY_DATA_MIRROR already defined
#endif
/** \brief Size of dynamic mirror entry data
 **
 ** The N (mirror memory entry number) maximal sizes are added.
 **/
#define DEM_SIZE_ENTRY_DATA_MIRROR    \
  ([!//
  [!FOR "i" = "1" TO "DemGeneral/DemMaxNumberEventEntryMirror"!]
    [!VAR "MaxEntrySize" = "0"!]
    [!FOR "j" = "1" TO "count(text:split($ListMir))"!]
      [!VAR "CurEntrySize" = "text:split($ListMir)[position() = $j]"!]
      [!IF "$MaxEntrySize < $CurEntrySize"!]
        [!VAR "MaxEntrySize" = "$CurEntrySize"!]
      [!ENDIF!]
    [!ENDFOR!]
    [!WS "0"!][!"num:integer($MaxEntrySize)"!]U + [!//
    [!VAR "ListMir" = "text:replace($ListMir, $MaxEntrySize, '')"!]
  [!ENDFOR!]
  DEM_ZERO_END)
/* !LINKSTO dsn.Dem.Dem_EntryData.MaxSize,1 */
#if DEM_SIZE_ENTRY_DATA_MIRROR > 0xFFFFU
#error The total size of the dynamic mirror entry data exceed 65535 byte. \
  Please reduce size or remove Extended Data Recordes, Freeze Frame Classes, or \
  number of Freeze Frame Records to reduce the needed space.
#endif

#if (defined DEM_SIZE_ENTRY_DATA_PERMANENT)
#error DEM_SIZE_ENTRY_DATA_PERMANENT already defined
#endif
/** \brief Size of dynamic permanent entry data
 **
 ** The N (permanent memory entry number) maximal sizes are added.
 **/
#define DEM_SIZE_ENTRY_DATA_PERMANENT DEM_ZERO_END

/*---------------------[Common Freeze Frame]--------------------------------*/

#if (defined DEM_COMMON_FREEZEFRAMES_USED)
#error DEM_COMMON_FREEZEFRAMES_USED already defined
#endif
/** \brief Defines if any common freeze frame class is configured */
[!IF "(node:refexists(DemGeneral/DemCommonFFDataClassRef)) or
      ( (DemGeneral/DemDevFreezeFrameSupport = 'true') and
        (node:refexists(DemGeneral/DemCommonFFDataDevAClassRef)) )"!]
  [!WS "0"!]#define DEM_COMMON_FREEZEFRAMES_USED   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_COMMON_FREEZEFRAMES_USED   STD_OFF
[!ENDIF!]

/*------------------[Development Freeze Frame]------------------------------*/

/* !LINKSTO dsn.Dem.DevFF.Encapsulation,1 */
#if (defined DEM_DEV_FREEZE_FRAME_USED)
#error DEM_DEV_FREEZE_FRAME_USED already defined
#endif
/** \brief Switch, indicating if Development Freeze Frames are enabled */
[!IF "DemGeneral/DemDevFreezeFrameSupport = 'true'"!]
  [!WS "0"!]#define DEM_DEV_FREEZE_FRAME_USED   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_DEV_FREEZE_FRAME_USED   STD_OFF
[!ENDIF!]

#if (defined DEM_MAX_NUMBER_DEVFFA_ENTRY)
#error DEM_MAX_NUMBER_DEVFFA_ENTRY already defined
#endif
[!/* node does not exist if DemDevFreezeFrameSupport is disabled */!][!//
[!IF "(node:exists(DemGeneral/DemMaxNumberDevFreezeFrameAEntry))"!]
/** \brief Maximum number of development Freeze Frames A type entries
 **/
  [!WS "0"!]#define DEM_MAX_NUMBER_DEVFFA_ENTRY [!"num:integer(DemGeneral/DemMaxNumberDevFreezeFrameAEntry)"!]U
[!ELSE!][!//
  [!WS "0"!]#define DEM_MAX_NUMBER_DEVFFA_ENTRY 0U
[!ENDIF!]

#if (defined DEM_DEV_FFA_MAX_CLASS_SIZE)
#error DEM_DEV_FFA_MAX_CLASS_SIZE already defined
#endif
/** \brief Size of largest configured Development Freeze Frames A class
 ** including the Common Development Freeze Frame A part
 **/
/* !LINKSTO dsn.Dem.DevFF.DemMaxNumberDevFreezeFrameAEntry, 1 */
#define DEM_DEV_FFA_MAX_CLASS_SIZE [!"num:integer($FFASizeLargest)"!]U

#if (defined DEM_MAX_NUMBER_DEVFFB_ENTRY)
#error DEM_MAX_NUMBER_DEVFFB_ENTRY already defined
#endif
[!/* node does not exist if DemDevFreezeFrameSupport is disabled */!][!//
[!IF "(node:exists(DemGeneral/DemMaxNumberDevFreezeFrameBEntry))"!]
/** \brief Maximum number of development Freeze Frames B type entries
 **/
  [!WS "0"!]#define DEM_MAX_NUMBER_DEVFFB_ENTRY [!"num:integer(DemGeneral/DemMaxNumberDevFreezeFrameBEntry)"!]U
[!ELSE!][!//
  [!WS "0"!]#define DEM_MAX_NUMBER_DEVFFB_ENTRY 0U
[!ENDIF!]

#if (defined DEM_DEV_FFB_MAX_CLASS_SIZE)
#error DEM_DEV_FFB_MAX_CLASS_SIZE already defined
#endif
/** \brief Size of largest configured Development Freeze Frames B class
 **/
#define DEM_DEV_FFB_MAX_CLASS_SIZE [!"num:integer($FFBSizeLargest)"!]U

/*------------------[Freeze frame configuration]----------------------------*/

/* Symbolic names of configured freeze frame data IDs */
[!LOOP "DemGeneral/DemDidClass/*"!]
  [!INDENT "0"!]

    #if (defined DEM_FFS_DID_[!"name(.)"!])
    #error DEM_FFS_DID_[!"name(.)"!] already defined
    #endif
    [!IF "node:exists(DemDidIdentifier)"!]
      /** \brief Symbolic name of data ID [!"name(.)"!] */
      #define DEM_FFS_DID_[!"name(.)"!] [!"num:integer(DemDidIdentifier)"!]U
    [!ENDIF!]
  [!ENDINDENT!]
[!ENDLOOP!]

#if (defined DEM_FF_RECNUM_CALCULATED)
#error DEM_FF_RECNUM_CALCULATED already defined
#endif
/** \brief Freeze frame records will be numbered consecutive starting by 1 in
 ** their chronological order */
#define DEM_FF_RECNUM_CALCULATED     0x00U

#if (defined DEM_FF_RECNUM_CONFIGURED)
#error DEM_FF_RECNUM_CONFIGURED already defined
#endif
/** \brief Freeze frame records will be numbered based on the given
 ** configuration in their chronological order */
#define DEM_FF_RECNUM_CONFIGURED     0x01U

#if (defined DEM_FREEZE_FRAME_REC_NUMERATION_TYPE)
#error DEM_FREEZE_FRAME_REC_NUMERATION_TYPE already defined
#endif
/** \brief Type of assignment of freeze frame record numbers
 **
 ** This switch defines the type for assigning freeze frame record numbers for
 ** event-specific freeze frame records.
 **/
#define DEM_FREEZE_FRAME_REC_NUMERATION_TYPE  [!//
[!"DemGeneral/DemTypeOfFreezeFrameRecordNumeration"!]

#if (defined DEM_MAX_NUMBER_PRESTORED_FF)
#error DEM_MAX_NUMBER_PRESTORED_FF already defined
#endif
/** \brief Maximum number of available prestored freeze frames
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_MAX_NUMBER_PRESTORED_FF [!"$MaxNumPrestoredFF"!]U

#if (defined DEM_TRIGGER_EVENT_MEMORY_STORAGE)
#error DEM_TRIGGER_EVENT_MEMORY_STORAGE already defined
#endif
/** \brief Triggers the collection of freeze frame / extended data if the
 ** event is stored in the event memory */
#define DEM_TRIGGER_EVENT_MEMORY_STORAGE  0x00U

#if (defined DEM_TRIGGER_TESTFAILED)
#error DEM_TRIGGER_TESTFAILED already defined
#endif
/** \brief Triggers the collection of freeze frame / extended data if the
 ** UDS DTC status bit 0 (TestedFailed) changes from 0 to 1 */
#define DEM_TRIGGER_TESTFAILED            0x01U

#if (defined DEM_TRIGGER_ON_FDC_THRESHOLD)
#error DEM_TRIGGER_ON_FDC_THRESHOLD already defined
#endif
/** \brief Triggers the collection of freeze frame / extended data if the
 ** unconfirmedDTC threshold is reached */
#define DEM_TRIGGER_ON_FDC_THRESHOLD      0x02U

#if (defined DEM_FREEZE_FRAME_CAPTURE)
#error DEM_FREEZE_FRAME_CAPTURE already defined
#endif
/** \brief Type of freeze frame capture trigger
 **
 ** This parameter defines the point in time, when the freeze frame data
 ** collection is done for the initial event memory entry.
 **/
#define DEM_FREEZE_FRAME_CAPTURE          [!"DemGeneral/DemFreezeFrameCapture"!]

/*------------------[Client configuration]----------------------------------*/
/** \brief Provides symbolic names of configured Clients
 **
 ** Configured clients are prefixed with symbolic name DemConf_DemClient_
 **/
[!INDENT "0"!]
  [!LOOP "node:order(DemGeneral/DemClient/*, './DemClientId')"!]
#if (defined DemConf_DemClient_[!"name(.)"!])
#error DemConf_DemClient_[!"name(.)"!] is already defined
#endif
#define DemConf_DemClient_[!"name(.)"!][!//
    [!CALL "Indent", "Length" = "31 - string-length(name(.))"!] [!"num:integer(DemClientId)"!]U
  [!ENDLOOP!]
[!ENDINDENT!]
/*------------------[Multi-event triggering configuration]------------------*/
#if (defined DEM_MULTIEVENTTRIGGERING_ALT_NONE)
#error DEM_MULTIEVENTTRIGGERING_ALT_NONE already defined
#endif
/** \brief Type of multi-event triggering default behavior */
#define DEM_MULTIEVENTTRIGGERING_ALT_NONE  0x00U

#if (defined DEM_MULTIEVENTTRIGGERING_ALT_EXCLUSIVE_REPLACE)
#error DEM_MULTIEVENTTRIGGERING_ALT_EXCLUSIVE_REPLACE already defined
#endif
/** \brief Type of multi-event triggering exlusive replacement behavior */
#define DEM_MULTIEVENTTRIGGERING_ALT_EXCLUSIVE_REPLACE  0x01U

/*------------------[Events configuration]----------------------------------*/

#if (defined DEM_MAX_NUMBER_EVENT_ENTRY_PRI)
#error DEM_MAX_NUMBER_EVENT_ENTRY_PRI already defined
#endif
/** \brief Maximum number of events which can be stored in the primary memory
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_MAX_NUMBER_EVENT_ENTRY_PRI [!"num:integer(DemGeneral/DemMaxNumberEventEntryPrimary)"!]U

#if (defined DEM_MAX_NUMBER_EVENT_ENTRY_SEC)
#error DEM_MAX_NUMBER_EVENT_ENTRY_SEC already defined
#endif
/** \brief Maximum number of events which can be stored in the secondary
 ** memory
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_MAX_NUMBER_EVENT_ENTRY_SEC [!"num:integer(DemGeneral/DemMaxNumberEventEntrySecondary)"!]U

#if (defined DEM_MAX_NUMBER_EVENT_ENTRY_MIR)
#error DEM_MAX_NUMBER_EVENT_ENTRY_MIR already defined
#endif
/** \brief Maximum number of events which can be stored in the mirror memory
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_MAX_NUMBER_EVENT_ENTRY_MIR [!"num:integer(DemGeneral/DemMaxNumberEventEntryMirror)"!]U

#if (defined DEM_MAX_NUMBER_EVENT_ENTRY_PER)
#error DEM_MAX_NUMBER_EVENT_ENTRY_PER already defined
#endif
/** \brief Maximum number of events which can be stored in the permanent memory
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
[!IF "node:exists(DemGeneral/DemMaxNumberEventEntryPermanent)"!]
#define DEM_MAX_NUMBER_EVENT_ENTRY_PER [!"num:integer(DemGeneral/DemMaxNumberEventEntryPermanent)"!]U
[!ELSE!]
#define DEM_MAX_NUMBER_EVENT_ENTRY_PER 0U
[!ENDIF!]

#if (defined DEM_NUMBER_OF_EVENT_CLASSES)
#error DEM_NUMBER_OF_EVENT_CLASSES already defined
#endif
/** \brief Number of individual event classes which are present in the system
 **
 ** If calibration is enabled the Dem combine set of this parameter to one entry in Dem_EventClass[]
 **/
[!CALL "CREATE_EVENT_CLASS_LIST"!]
#define DEM_NUMBER_OF_EVENT_CLASSES [!"num:i($MaxNumberEventClasses)"!]U

#if (defined DEM_NUMBER_OF_EVENTS)
#error DEM_NUMBER_OF_EVENTS already defined
#endif
/** \brief Number of events which are present in the system
 **
 ** Calculated by number of event IDs listed in Dem_IntErrId.h and
 ** Dem_IntEvtId.h including ::DEM_EVENT_ID_INVALID.
 **
 ** \note Macro name is still existing for compatibility reasons with AR2.1.
 **/
#define DEM_NUMBER_OF_EVENTS [!"num:integer(count(DemConfigSet/*/DemEventParameter/*) + 1)"!]U

#if (defined DEM_NUM_SWC_EVENTS)
#error DEM_NUM_SWC_EVENTS already defined
#endif
/** \brief Number of SW-C events present in the system
 **/
#define DEM_NUM_SWC_EVENTS [!"num:integer(count(DemConfigSet/*/DemEventParameter/*[DemEventKind = 'DEM_EVENT_KIND_SWC']))"!]U

#if (defined DEM_NUM_BSW_EVENTS)
#error DEM_NUM_BSW_EVENTS already defined
#endif
/** \brief Number of BSW events present in the system
 **/
#define DEM_NUM_BSW_EVENTS (DEM_NUMBER_OF_EVENTS - DEM_NUM_SWC_EVENTS - 1U)

#if (defined DEM_NUM_OF_PIDS_IN_OBDFF)
#error DEM_NUM_OF_PIDS_IN_OBDFF already defined
#endif
/** \brief Number of PIDs to be stored in OBD freeze frame **/
[!IF "node:exists(as:modconf('Dem')[1]/DemConfigSet/*/DemPidClass/*)"!]
/* !LINKSTO dsn.Dem.OBD.DEM_NUM_OF_PIDS_IN_OBDFF,1 */
#define DEM_NUM_OF_PIDS_IN_OBDFF [!"$NumOfPidInOBDFF"!]U
[!ELSE!][!//
#define DEM_NUM_OF_PIDS_IN_OBDFF 0U
[!ENDIF!]

#if (defined DEM_OBDFF_SINGLE)
#error DEM_OBDFF_SINGLE already defined
#endif
/** \brief Single OBD freeze frame support */
#define DEM_OBDFF_SINGLE            0x01U

#if (defined DEM_OBDFF_MULTIPLE)
#error DEM_OBDFF_MULTIPLE already defined
#endif
/** \brief Multiple OBD freeze frame support */
#define DEM_OBDFF_MULTIPLE            0x02U

#if (defined DEM_OBDFF_SUPPORT_KIND)
#error DEM_OBDFF_SUPPORT_KIND already defined
#endif
/** \brief Type of OBD freeze frame support
 **
 ** This macro controls support of the multiple and single OBD Freeze Frame
 **/
/* !LINKSTO dsn.Dem.OBD.OBDFreezeFrame.HandlingVariants,1 */
[!IF "$NumOfPidInOBDFF > 0"!]
[!IF "(as:modconf('Dem')[1]/DemGeneral/DemExtendedDataCapture = 'DEM_TRIGGER_ON_FDC_THRESHOLD') and
      (as:modconf('Dem')[1]/DemGeneral/DemFreezeFrameCapture = 'DEM_TRIGGER_ON_FDC_THRESHOLD')"!]
/* !LINKSTO dsn.Dem.OBD.DEM_OBDFF_SUPPORT_KIND.DEM_OBDFF_SINGLE,1 */
#define DEM_OBDFF_SUPPORT_KIND            DEM_OBDFF_SINGLE
[!ELSE!]
/* !LINKSTO dsn.Dem.OBD.DEM_OBDFF_SUPPORT_KIND.DEM_OBDFF_MULTIPLE,1 */
#define DEM_OBDFF_SUPPORT_KIND            DEM_OBDFF_MULTIPLE
[!ENDIF!]
[!ELSE!]
#define DEM_OBDFF_SUPPORT_KIND            STD_OFF
[!ENDIF!]

#if (defined DEM_MAX_EVENTS_PER_READINESS_GROUP)
#error DEM_MAX_EVENTS_PER_READINESS_GROUP already defined
#endif
/** \brief Maximum number of events per readiness groups
 *
 *  If calibration is enabled, this value defines the maximum number of events
 *  which can be assigned to an OBD readiness group.
 *  If calibration is disabled, this value is set to 0 which triggers an
 *  optimized implementation of OBD readiness groups.
 */
[!/* !LINKSTO Dem.Dsn.DemMaxNumEventsPerReadinessGroup,1 */!][!//
[!IF "node:exists(DemGeneral/DemMaxNumEventsPerReadinessGroup)"!]
#define DEM_MAX_EVENTS_PER_READINESS_GROUP [!"num:integer(DemGeneral/DemMaxNumEventsPerReadinessGroup)"!]U
[!ELSE!][!//
#define DEM_MAX_EVENTS_PER_READINESS_GROUP 0U
[!ENDIF!]

/*------------------[DTC groups configuration]------------------------------*/

/* Symbolic names of configured DTC groups */
[!INDENT "0"!]
  [!LOOP "node:order(DemGeneral/DemGroupOfDTC/*, './DemGroupDTCs')"!]
    [!VAR "PredefinedGroup" = "'true'"!]
    [!/* create group name only for commentation */!][!//
    [!VAR "CommentGroupName" = "name(.)"!]
    [!IF "$CommentGroupName = 'DEM_DTC_GROUP_EMISSION_REL_DTCS'"!]
      [!VAR "CommentGroupName" = "'OBD-relevant'"!]
    [!ELSEIF "$CommentGroupName = 'DEM_DTC_GROUP_POWERTRAIN_DTCS'"!]
      [!VAR "CommentGroupName" = "'powertrain'"!]
    [!ELSEIF "$CommentGroupName = 'DEM_DTC_GROUP_CHASSIS_DTCS'"!]
      [!VAR "CommentGroupName" = "'chassis'"!]
    [!ELSEIF "$CommentGroupName = 'DEM_DTC_GROUP_BODY_DTCS'"!]
      [!VAR "CommentGroupName" = "'body'"!]
    [!ELSEIF "$CommentGroupName = 'DEM_DTC_GROUP_NETWORK_COM_DTCS'"!]
      [!VAR "CommentGroupName" = "'network communication'"!]
    [!ELSE!]
      [!VAR "PredefinedGroup" = "'false'"!]
      [!VAR "CommentGroupName" = "substring($CommentGroupName, 15)"!]
    [!ENDIF!]

    #if (defined DemConf_DemGroupOfDTC_[!"name(.)"!])
    #error DemConf_DemGroupOfDTC_[!"name(.)"!] already defined
    #endif
    /** \brief Export symbolic name value of DTC group
     **[!"$CommentGroupName"!]
     **/
    #define DemConf_DemGroupOfDTC_[!"name(.)"!][!//
    [!CALL "Indent", "Length" = "31 - string-length(name(.))"!] [!"translate(num:inttohex(DemGroupDTCs, 6), 'abcdef', 'ABCDEF')"!]U

    [!/* Predefined non-emission related DTC group */!]
    [!IF "$CommentGroupName != 'OBD-relevant'"!]
      [!IF "$PredefinedGroup = 'true'"!]
        #if (defined [!"name(.)"!])
        #error [!"name(.)"!] already defined
        #endif
        /** \brief Export PREDEFINED symbolic name value (without prefix)
         ** as per definition of ::Dem_DTCGroupType in SWS
         **/
        #define [!"name(.)"!][!CALL "Indent", "Length" = "31 - string-length(name(.))"!] [!"translate(num:inttohex(DemGroupDTCs, 6), 'abcdef', 'ABCDEF')"!]U

      [!ENDIF!]
    [!ENDIF!]
    #if (defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES)
    #if (defined Dem_[!"name(.)"!])
    #error Dem_[!"name(.)"!] already defined
    #endif
    /** \brief Export symbolic name value with module abbreviation as prefix
     ** only (AUTOSAR version <= AUTOSAR 4.0 rev2)
     **/
    #define Dem_[!"name(.)"!][!CALL "Indent", "Length" = "31 - string-length(name(.))"!] [!"translate(num:inttohex(DemGroupDTCs, 6), 'abcdef', 'ABCDEF')"!]U
    #endif /* defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES */
  [!ENDLOOP!]
[!ENDINDENT!]

#if (defined DEM_EMISSION_REL_DTCS_GROUP_EXIST)
#error DEM_EMISSION_REL_DTCS_GROUP_EXIST already defined
#endif
 /** \brief Switch, indicating if emision related DTC group is enabled */
[!IF "(count(as:modconf('Dem')[1]/DemGeneral/DemGroupOfDTC/*[name(.) = 'DEM_DTC_GROUP_EMISSION_REL_DTCS']) > 0)"!]
   [!WS "0"!]#define DEM_EMISSION_REL_DTCS_GROUP_EXIST   STD_ON
[!ELSE!][!//
   [!WS "0"!]#define DEM_EMISSION_REL_DTCS_GROUP_EXIST   STD_OFF
[!ENDIF!]

/*------------------[Warning indicators configuration]----------------------*/

/* Symbolic names of configured warning indicator IDs */
[!LOOP "DemGeneral/DemIndicator/*"!]
  [!INDENT "0"!]

    [!IF "$DemRteUsage = 'true'"!]
      /* Following macro is generated by the RTE to identify if it is in synch with the current DEM configuration.
       * Notwithstanding, the macro is not intended for the usage via an RTE interface but only via a c API. */
      #if (DemConf_DemIndicator_[!"name(.)"!] != [!"num:integer(DemIndicatorID)"!]U)
      #error Definition of macro DemConf_DemIndicator_[!"name(.)"!] does not match to the DEM configuration due to RTE and DEM are out of synch. Please update the RTE based on the newest DEM BSWMD file!
      #endif
    [!ELSE!]
      #if (defined DemConf_DemIndicator_[!"name(.)"!])
      #error DemConf_DemIndicator_[!"name(.)"!] already defined
      #endif
      /** \brief Export symbolic name value */
      #define DemConf_DemIndicator_[!"name(.)"!][!CALL "Indent", "Length" = "31 - string-length(name(.))"!] [!"num:integer(DemIndicatorID)"!]U
    [!ENDIF!]

    #if (defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES)

    #if (defined Dem_[!"name(.)"!])
    #error Dem_[!"name(.)"!] already defined
    #endif
    /** \brief Export symbolic name value with module abbreviation as prefix
     ** only (AUTOSAR version <= AUTOSAR 4.0 rev2)
     **/
    #define Dem_[!"name(.)"!][!CALL "Indent", "Length" = "31 - string-length(name(.))"!] [!"num:integer(DemIndicatorID)"!]U
    #endif /* defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES */
  [!ENDINDENT!]
[!ENDLOOP!]


#if (defined DEM_NUMBER_OF_INDICATORS)
#error DEM_NUMBER_OF_INDICATORS already defined
#endif
/** \brief Number of warning indicators which are present in the system
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
[!VAR "NumIndicator" = "count(DemGeneral/DemIndicator/*)"!]
#define DEM_NUMBER_OF_INDICATORS                [!"num:i($NumIndicator)"!]U


#if (defined DEM_NUM_INDICATOR_LINKS)
#error DEM_NUM_INDICATOR_LINKS already defined
#endif
/** \brief Number of warning indicator links
 **        In case of calibration-support a link represents an indicator class */
#define DEM_NUM_INDICATOR_LINKS                 [!"num:i($NumIndicatorLinks)"!]U


#if (defined DEM_INDICATOR_MULTIPLICITY)
#error DEM_INDICATOR_MULTIPLICITY already defined
#endif
/** \brief Number of different warning indicator which could be assigned to an
 **        event. Without calibration support the assigned indicator can not be
 **        changed.
 **/
#if (DEM_INDICATORCLASS_SUPPORT == STD_ON)
#define DEM_INDICATOR_MULTIPLICITY              DEM_NUMBER_OF_INDICATORS
#else
#define DEM_INDICATOR_MULTIPLICITY              1U
#endif


#if (defined DEM_NUM_INDICATOR_COUNTER)
#error DEM_NUM_INDICATOR_COUNTER already defined
#endif
/** \brief Number of used indicator counter in ::Dem_NvData */
#if (DEM_INDICATORCLASS_SUPPORT == STD_ON)
#define DEM_NUM_INDICATOR_COUNTER               DEM_NUMBER_OF_EVENTS
#else
#define DEM_NUM_INDICATOR_COUNTER               DEM_NUM_INDICATOR_LINKS
#endif


#if (defined DEM_NUM_INDICATOR_COUNTER_BIT)
#error DEM_NUM_INDICATOR_COUNTER_BIT already defined
#endif
/** \brief Number of bytes to hold one bit for each indicator counter
 **        in ::Dem_NvData for IndicatorCycleCounterRole and
 **        IndicatorCycleCounterWIRStatus */
#define DEM_NUM_INDICATOR_COUNTER_BIT           ((DEM_NUM_INDICATOR_COUNTER + 7U) / 8U)


[!VAR "NumBSWEventIndicatorConfigured" = "0"!]
[!LOOP "DemConfigSet/*/DemEventParameter/*"!]
  [!IF "( ./DemEventKind = 'DEM_EVENT_KIND_BSW') and ($CalibrationSupport = 'true') and (DemGeneral/DemMaxNumberIndicatorClasses > 0 or $NumIndicatorLinks > 0)"!]
    [!VAR "NumBSWEventIndicatorConfigured" = "$NumBSWEventIndicatorConfigured + 1"!]
  [!ELSE!]
    [!IF "count(DemEventClass/DemIndicatorAttribute/*) != 0 and ./DemEventKind = 'DEM_EVENT_KIND_BSW'"!]
      [!VAR "NumBSWEventIndicatorConfigured" = "$NumBSWEventIndicatorConfigured + 1"!]
    [!ENDIF!]
  [!ENDIF!]
[!ENDLOOP!]

#if (defined DEM_NUM_BSWEVENT_INDICATOR_USED)
#error DEM_NUM_BSWEVENT_INDICATOR_USED already defined
#endif
/** \brief Number of BSW events which are configured for warning indicator */
#define DEM_NUM_BSWEVENT_INDICATOR_USED         [!"num:integer($NumBSWEventIndicatorConfigured)"!]U

[!IF "$IndicatorClassSupport = 'true'"!]
  [!IF "($NumIndicator != 0) and ($NumberOfIndicatorClasses < DemGeneral/DemMaxNumberIndicatorClasses)"!]
    [!VAR "NumberOfIndicatorClasses" = "DemGeneral/DemMaxNumberIndicatorClasses"!]
  [!ENDIF!]
#if (defined DEM_NUM_INDICATOR_GROUPS)
#error DEM_NUM_INDICATOR_GROUPS already defined
#endif
/** \brief Number of warning indicator groups */
#define DEM_NUM_INDICATOR_GROUPS                [!"num:i($NumberOfIndicatorClasses + 1)"!]U

[!ENDIF!]
/*------------------[Enable conditions configuration]-----------------------*/

/* Symbolic names of configured enable conditions */
[!LOOP "DemGeneral/DemEnableCondition/*"!]
  [!INDENT "0"!]
    [!IF "$DemRteUsage = 'true'"!]
      /* Following macro is generated by the RTE to identify if it is in synch with the current DEM configuration.
       * Notwithstanding, the macro is not intended for the usage via an RTE interface but only via a c API. */
      #if (DemConf_DemEnableCondition_[!"name(.)"!] != [!"num:integer(DemEnableConditionId)"!])
      #error Definition of macro DemConf_DemEnableCondition_[!"name(.)"!] does not match to the DEM configuration due to RTE and DEM are out of synch. Please update the RTE based on the newest DEM BSWMD file!
      #endif
    [!ELSE!]
      #if (defined DemConf_DemEnableCondition_[!"name(.)"!])
      #error DemConf_DemEnableCondition_[!"name(.)"!] already defined
      #endif
      /** \brief Export symbolic name value */
      #define DemConf_DemEnableCondition_[!"name(.)"!][!CALL "Indent", "Length" = "31 - string-length(name(.))"!] [!"num:integer(DemEnableConditionId)"!]U
    [!ENDIF!]

    #if (defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES)
    #if (defined Dem_[!"name(.)"!])
    #error Dem_[!"name(.)"!] already defined
    #endif
    /** \brief Export symbolic name value with module abbreviation as prefix
     ** only (AUTOSAR version <= AUTOSAR 4.0 rev2)
     **/
    #define Dem_[!"name(.)"!][!CALL "Indent", "Length" = "31 - string-length(name(.))"!] [!"num:integer(DemEnableConditionId)"!]U
    #endif /* defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES */
  [!ENDINDENT!]
[!ENDLOOP!]

#if (defined DEM_NUM_ENABLECONDITIONS)
#error DEM_NUM_ENABLECONDITIONS already defined
#endif
/** \brief Number of enable conditions */
#define DEM_NUM_ENABLECONDITIONS [!"num:integer(count(DemGeneral/DemEnableCondition/*))"!]U

#if (defined DEM_ENCONDITIONGROUP_UNUSED)
#error DEM_ENCONDITIONGROUP_UNUSED already defined
#endif
/** \brief Used in Dem_EventDesc and Dem_EventClassDesc if a dedicated event
 ** does not refer to any enable condition group */
#define DEM_ENCONDITIONGROUP_UNUSED         DEM_NUM_ENCONDGROUPS

/*------------------[Multi event triggering configuration]------------------*/

[!CALL "GET_MULTI_EVENT_TRIGGERING_CLASS_COUNT"!]
#if (defined DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT)
#error DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT already defined
#endif
/** \brief Number of multi event triggering classes */
#define DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT [!"num:integer($NumMultiEventTriggeringClasses)"!]U

#if (defined DEM_MULTI_EVENT_TRIGGERING_COUNT)
#error DEM_MULTI_EVENT_TRIGGERING_COUNT already defined
#endif
/** \brief Number of multi event triggering configurations */
#define DEM_MULTI_EVENT_TRIGGERING_COUNT [!"num:integer($NumMultiEventTriggering)"!]U

#if (defined DEM_MULTI_EVENT_TRIGGERING_COUNT_MAX_WIDTH)
#error DEM_MULTI_EVENT_TRIGGERING_COUNT_MAX_WIDTH already defined
#endif
/** \brief Maximum bit-width of multi event triggering configurations */
[!IF "num:integer($NumMultiEventTriggering) > 255"!]
#define DEM_MULTI_EVENT_TRIGGERING_COUNT_MAX_WIDTH 16U
[!ELSE!][!//
#define DEM_MULTI_EVENT_TRIGGERING_COUNT_MAX_WIDTH 8U
[!ENDIF!]

[!CALL "GET_MULTI_EVENT_TRIGGERING_SLAVE_COUNT"!]
#if (defined DEM_MULTI_EVENT_TRIGGERING_SLAVE_COUNT)
#error DEM_MULTI_EVENT_TRIGGERING_SLAVE_COUNT already defined
#endif
/** \brief Number of configured slave events based on multi event triggering classes */
#define DEM_MULTI_EVENT_TRIGGERING_SLAVE_COUNT [!"num:integer($NumMultiEventTriggeringSlaves)"!]U

[!CALL "GET_WIDTH", "PNumber" = "num:integer($NumMultiEventTriggering) + 1", "context" = "'MultiEventTriggering'"!][!//
[!VAR "MultiEventTriggeringIdxWidth" = "num:integer($NumberOfBits)"!][!//
[!//
#if (defined DEM_MULTI_EVENT_TRIGGERING_BIT_COUNT)
#error DEM_MULTI_EVENT_TRIGGERING_BIT_COUNT already defined
#endif
/** \brief Bit-width needed to store DEM_MULTI_EVENT_TRIGGERING_COUNT */
#define DEM_MULTI_EVENT_TRIGGERING_BIT_COUNT [!"$MultiEventTriggeringIdxWidth"!]U

#if (defined DEM_ROOT_ERROR_BUFFER_SIZE)
#error DEM_ROOT_ERROR_BUFFER_SIZE already defined
#endif
/** \brief Number of multi event root error queue element groups */
#define DEM_ROOT_ERROR_BUFFER_SIZE [!"num:integer(($MultiEventTriggeringIdxWidth * num:integer(DemGeneral/DemBswErrorBufferSize) + 7) div 8)"!]U

#if (defined DEM_ROOT_ERROR_ENTRY_MASK)
#error DEM_ROOT_ERROR_ENTRY_MASK already defined
#endif
/** \brief Mask used to extract multi event indeces from root error queue */
[!IF "$MultiEventTriggeringIdxWidth > 8"!]
#define DEM_ROOT_ERROR_ENTRY_MASK [!"num:inttohex(bit:shl(1, $MultiEventTriggeringIdxWidth) - 1, 4)"!]U
[!ELSE!][!//
#define DEM_ROOT_ERROR_ENTRY_MASK [!"num:inttohex(bit:shl(1, $MultiEventTriggeringIdxWidth) - 1, 2)"!]U
[!ENDIF!]

#if (defined DEM_MULTIEVENTTRIGGERINGMASTERIDX_UNUSED)
#error DEM_MULTIEVENTTRIGGERINGMASTERIDX_UNUSED already defined
#endif
/** \brief Used in Dem_GetMultiEventTriggeringMasterIdx if a dedicated event
 ** does not have any entry in Dem_MultiEventTriggeringMasterEventId[] */
#define DEM_MULTIEVENTTRIGGERINGMASTERIDX_UNUSED   DEM_MULTI_EVENT_TRIGGERING_COUNT

#if (defined DEM_MULTIEVENTTRIGGERINGIDX_UNUSED)
#error DEM_MULTIEVENTTRIGGERINGIDX_UNUSED already defined
#endif
/** \brief Used in Dem_EventDesc and Dem_EventClassDesc if a dedicated event
 ** does not refer to any multi event triggering class configuration */
#define DEM_MULTIEVENTTRIGGERINGIDX_UNUSED   DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT

/*------------------[Operation and aging cycles configuration]--------------*/

#ifndef DEM_PROCESS_OPCYC_STATE
/** \brief Operation cycle processing is triggered by START/END */
#define DEM_PROCESS_OPCYC_STATE        0x00U
#endif

#ifndef DEM_PROCESS_OPCYC_COUNTER
/** \brief Operation cycle processing is triggered by collecting an external
 ** counter value */
#define DEM_PROCESS_OPCYC_COUNTER      0x01U
#endif

#if (defined DEM_OPERATION_CYCLE_PROCESSING)
#error DEM_OPERATION_CYCLE_PROCESSING already defined
#endif
/** \brief Operation cycle processing mode
 **
 ** This processing mode defines whether the operation cycles are triggered by
 ** START/END reports via Dem_SetOperationCycleState(), or collecting an
 ** external counter value via Dem_SetOperationCycleCntValue().
 **
 ** \note Macro name is NOT present in SWS. This is as per bugzilla ticket
 ** #47189.
 **/
#define DEM_OPERATION_CYCLE_PROCESSING [!"DemGeneral/DemOperationCycleProcessing"!]

#ifndef DEM_PROCESS_AGINGCTR_INTERN
/** \brief Aging counter processing is triggered internally */
#define DEM_PROCESS_AGINGCTR_INTERN      0x00U
#endif

#ifndef DEM_PROCESS_AGINGCTR_EXTERN
/** \brief Aging counter processing is triggered by collecting an external
 ** counter value */
#define DEM_PROCESS_AGINGCTR_EXTERN      0x01U
#endif

#if (defined DEM_AGINGCYCLE_COUNTER_PROCESSING)
#error DEM_AGINGCYCLE_COUNTER_PROCESSING already defined
#endif
/** \brief Aging counter processing mode
 **
 ** This processing mode defines whether aging is triggered via
 ** Dem_SetOperationCycleState() and Dem_SetAgingCycleState(), or via an
 ** external counter value reported by Dem_SetAgingCycleCounterValue().
 **/
#define DEM_AGINGCYCLE_COUNTER_PROCESSING [!"DemGeneral/DemAgingCycleCounterProcessing"!]

#if (defined DEM_PROCESS_OCCCTR_CDTC)
#error DEM_PROCESS_OCCCTR_CDTC already defined
#endif
/** \brief Occurrence counter processing is triggered
 ** after the fault confirmation was successfull
 **/
#define DEM_PROCESS_OCCCTR_CDTC    0x00U

#if (defined DEM_PROCESS_OCCCTR_TF)
#error DEM_PROCESS_OCCCTR_TF already defined
#endif
/** \brief Occurrence counter processing is triggered
 **  by the TestFailed bit only
 **/
#define DEM_PROCESS_OCCCTR_TF      0x01U

#if (defined DEM_OCCURRENCE_COUNTER_PROCESSING)
#error DEM_OCCURRENCE_COUNTER_PROCESSING already defined
#endif
/** \brief Occurrence counter processing mode
 **
 ** This switch defines the consideration of the fault confirmation
 ** process for the occurrence counter.
 **/
#define DEM_OCCURRENCE_COUNTER_PROCESSING  [!//
[!"DemGeneral/DemOccurrenceCounterProcessing"!]

/* Symbolic names of configured operation cycle types */
[!VAR "OpCycleTypeNr" = "0"!]
[!VAR "isAutoEndEnabled" = "0"!]
[!VAR "isWarmupDefined" = "0"!]
[!LOOP "DemGeneral/DemOperationCycle/*"!]
  [!IF "DemOperationCycleType = 'DEM_OPCYC_IGNITION'"!]
    [!VAR "OpCycleTypeNr" = "0"!]
  [!ELSEIF "DemOperationCycleType = 'DEM_OPCYC_OBD_DCY'"!]
    [!VAR "OpCycleTypeNr" = "1"!]
  [!ELSEIF "DemOperationCycleType = 'DEM_OPCYC_POWER'"!]
    [!VAR "OpCycleTypeNr" = "2"!]
  [!ELSEIF "DemOperationCycleType = 'DEM_OPCYC_WARMUP'"!]
    [!VAR "OpCycleTypeNr" = "3"!]
  [!ELSEIF "DemOperationCycleType = 'DEM_OPCYC_TIME'"!]
    [!VAR "OpCycleTypeNr" = "4"!]
  [!ELSE!]
    [!VAR "OpCycleTypeNr" = "5"!]
  [!ENDIF!]
  [!INDENT "0"!]

    #if (defined [!"name(.)"!]_TYPE)
    #error [!"name(.)"!]_TYPE already defined
    #endif
    /** \brief Symbolic name of configured operation cycle type
     ** [!"DemOperationCycleType"!] for [!"name(.)"!].
    [!WS!]** Not used in the current implementation
    **/
    #define [!"name(.)"!]_TYPE [!CALL "Indent", "Length" = "31 - string-length(name(.))"!][!"num:integer($OpCycleTypeNr)"!]U
  [!ENDINDENT!]
  [!IF "DemOperationCycleAutomaticEnd = 'true'"!]
    [!VAR "isAutoEndEnabled" = "1"!]
  [!ENDIF!]
[!ENDLOOP!]

[!VAR "CycCtr" = "0"!]
[!VAR "isDYCFound" = "0"!]
[!VAR "ObdDcyId" = "0"!]
[!VAR "isIgnitionFound" = "0"!]
[!VAR "ObdIgnitionId" = "0"!]
[!VAR "isWarmupFound" = "0"!]
[!VAR "ObdWarmupId" = "0"!]
[!//
/* Symbolic names of configured operation cycles and failure cycles */
[!LOOP "DemGeneral/DemOperationCycle/*"!]
  [!INDENT "0"!]
    [!IF "$DemRteUsage = 'true'"!]
      /* Following macro is generated by the RTE to identify if it is in synch with the current DEM configuration.
       * Notwithstanding, the macro is not intended for the usage via an RTE interface but only via a c API. */
      #if ([!"name(.)"!] != [!"num:integer($CycCtr)"!])
      #error Definition of macro [!"name(.)"!] does not match to the DEM configuration due to RTE and DEM are out of synch. Please update the RTE based on the newest DEM BSWMD file!
      #endif
    [!ELSE!]
      #if (defined [!"name(.)"!])
      #error [!"name(.)"!] already defined
      #endif
      /** \brief Symbolic name of operation cycle
       ** [!"name(.)"!]
       **/
      #define [!"name(.)"!][!//
      [!CALL "Indent", "Length" = "31 - string-length(name(.))"!] [!"num:integer($CycCtr)"!]U
    [!ENDIF!]
  [!ENDINDENT!]
  [!IF "(./DemOperationCycleType = 'DEM_OPCYC_OBD_DCY')"!]
    [!VAR "isDYCFound" = "1"!]
    [!VAR "ObdDcyId" = "num:integer($CycCtr)"!]
  [!ENDIF!]
  [!IF "(./DemOperationCycleType = 'DEM_OPCYC_IGNITION')"!]
    [!VAR "isIgnitionFound" = "1"!]
    [!VAR "ObdIgnitionId" = "num:integer($CycCtr)"!]
  [!ENDIF!]
  [!IF "(./DemOperationCycleType = 'DEM_OPCYC_WARMUP')"!]
    [!VAR "isWarmupFound" = "1"!]
    [!VAR "ObdWarmupId" = "num:integer($CycCtr)"!]
  [!ENDIF!]
  [!VAR "CycCtr" = "$CycCtr + 1"!]
[!//
[!ENDLOOP!]

/* !LINKSTO dsn.Dem.OBD.OPCYC.WARMUP.Id,1 */
[!IF "$isWarmupFound = 1"!]
#if (defined DEM_OPCYC_WARMUP_ID)
#error DEM_OPCYC_WARMUP_ID already defined
#endif
/** \brief ID the operation cycle from type 'DEM_OPCYC_WARMUP' */
#define DEM_OPCYC_WARMUP_ID [!"num:integer($ObdWarmupId)"!]U
[!ENDIF!]

#if (defined DEM_NUM_OPCYCLES)
#error DEM_NUM_OPCYCLES already defined
#endif
/** \brief Number of operation cycles */
#define DEM_NUM_OPCYCLES [!"num:integer($CycCtr)"!]U

[!IF "$isAutoEndEnabled = 1"!]
#if (defined DEM_OPCYC_AUTO_END_MASK_GROUP_LENGTH)
#error DEM_OPCYC_AUTO_END_MASK_GROUP_LENGTH already defined
#endif
/* Number of operation cycles, masked by one automatic end enabled mask */
#define DEM_OPCYC_AUTO_END_MASK_GROUP_LENGTH 8U

#if (defined DEM_OPCYC_AUTO_END_ENABLED)
#error DEM_OPCYC_AUTO_END_ENABLED already defined
#endif
/** \brief automatic end of opcycle configured for at least 1 opcycle */
#define DEM_OPCYC_AUTO_END_ENABLED STD_ON
[!//
[!/* calculate size of array, that holds auto end masks */!]
[!VAR "numOfOpCycles" = "count(DemGeneral/DemOperationCycle/*)"!]
[!IF "$numOfOpCycles <= 8"!]
  [!VAR "MasksArraySize" = "1"!]
[!ELSEIF "$numOfOpCycles mod 8 = 0"!]
  [!VAR "MasksArraySize" = "count(DemGeneral/DemOperationCycle/*) div 8"!]
[!ELSE!]
  [!VAR "MasksArraySize" = "count(DemGeneral/DemOperationCycle/*) div 8 + 1"!]
[!ENDIF!]
[!//
#if (defined DEM_OPCYC_NUM_OF_AUTO_END_ENABLED_MASKS)
#error DEM_OPCYC_NUM_OF_AUTO_END_ENABLED_MASKS already defined
#endif
/** \brief automatic end of opcycle configured for at least 1 opcycle */
#define DEM_OPCYC_NUM_OF_AUTO_END_ENABLED_MASKS [!"num:integer($MasksArraySize)"!]U
[!ELSE!]
#if (defined DEM_OPCYC_AUTO_END_ENABLED)
#error DEM_OPCYC_AUTO_END_ENABLED already defined
#endif
/** \brief automatic end of opcycle not configured for at least 1 opcycle */
#define DEM_OPCYC_AUTO_END_ENABLED STD_OFF
[!ENDIF!]

/* compile switch for OBD DCY */
/* !LINKSTO dsn.Dem.OBD.OPCYC.DCY.CompileSwitch,1 */
#if (defined DEM_OPCYC_OBD_DCY_USED)
#error DEM_OPCYC_OBD_DCY_USED already defined
#endif
[!IF "$isDYCFound = 1"!]
/** \brief OBD DCY not used */
#define DEM_OPCYC_OBD_DCY_USED STD_ON
[!ELSE!]
/** \brief OBD DCY not used */
#define DEM_OPCYC_OBD_DCY_USED STD_OFF
[!ENDIF!]

/* !LINKSTO dsn.Dem.OBD.OPCYC.DCY.0001,1 */
[!IF "$isDYCFound = 1"!]
#if (defined DEM_OPCYC_OBD_DCY_ID)
#error DEM_OPCYC_OBD_DCY_ID already defined
#endif
/** \brief ID of the operation cycle from type 'DEM_OPCYC_OBD_DCY' */
#define DEM_OPCYC_OBD_DCY_ID [!"num:integer($ObdDcyId)"!]U
[!ENDIF!]

/* !LINKSTO dsn.Dem.OBD.OPCYC.IGNITION.0001,1 */
[!IF "$isIgnitionFound = 1"!]
#if (defined DEM_OPCYC_IGNITION_ID)
#error DEM_OPCYC_IGNITION_ID already defined
#endif
/** \brief ID the operation cycle from type 'DEM_OPCYC_IGNITION' */
#define DEM_OPCYC_IGNITION_ID [!"num:integer($ObdIgnitionId)"!]U
[!ENDIF!]

/* Symbolic names of configured aging cycles */
[!VAR "AgeCycCtr" = "0"!]
[!IF "count(DemConfigSet/*/DemEventParameter/*[DemEventClass/DemAgingAllowed = 'true']) > 0"!]
  [!LOOP "DemGeneral/DemAgingCycle/*"!]
    [!INDENT "0"!]
      [!IF "$DemRteUsage = 'true'"!]
        /* Following macro is generated by the RTE to identify if it is in synch with the current DEM configuration.
         * Notwithstanding, the macro is not intended for the usage via an RTE interface but only via a c API. */
        #if ([!"name(.)"!] != [!"num:integer($AgeCycCtr)"!])
        #error Definition of macro [!"name(.)"!] does not match to the DEM configuration due to RTE and DEM are out of synch. Please update the RTE based on the newest DEM BSWMD file!
        #endif
      [!ELSE!]
        #if (defined [!"name(.)"!])
        #error [!"name(.)"!] already defined
        #endif
        /** \brief Symbolic name of aging cycle [!"name(.)"!] */
        #define [!"name(.)"!][!CALL "Indent", "Length" = "31 - string-length(name(.))"!] [!"num:integer($AgeCycCtr)"!]U
      [!ENDIF!]
    [!ENDINDENT!]
    [!VAR "AgeCycCtr" = "$AgeCycCtr + 1"!]
  [!ENDLOOP!]
[!ENDIF!]

#if (defined DEM_NUM_AGINGCYCLES)
#error DEM_NUM_AGINGCYCLES already defined
#endif
/** \brief Number of aging cycles
 **
 ** For these cycles, aging will not be performed based on the operation cycle
 ** of the respective event.
 **
 ** The value is always 0, if ::DEM_USE_AGING is switched off. */
#define DEM_NUM_AGINGCYCLES [!"num:integer($AgeCycCtr)"!]U

/*------------------[OCC5 Configuration]------------------------------------*/
/* !LINKSTO dsn.Dem.OBD.OCC5.VccOcc5Used,1 */
#if (defined DEM_VCC_OCC5_USED)
#error DEM_VCC_OCC5_USED already defined
#endif
[!CALL "GET_VCC_OCC5_USED"!][!//
/* !LINKSTO dsn.Dem.OBD.OCC5.Encapsulation,1 */
[!IF "$VccOcc5Used = 1"!]
  [!WS "0"!]#define DEM_VCC_OCC5_USED          STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_VCC_OCC5_USED          STD_OFF
[!ENDIF!]

/*------------------[Operation Cycle Counters Configuration]----------------*/

#if (defined DEM_OPCYCLE_CTR_CSLF_SUPPORT)
#error DEM_OPCYCLE_CTR_CSLF_SUPPORT already defined
#endif
/** \brief Macro for availability of feature cycles since last failed */
[!CALL "IS_INT_DATA_REFERENCED", "InternalDataElement" = "'DEM_CYCLES_SINCE_LAST_FAILED'"!]
[!IF "$IsIntDataReferenced"!]
  [!WS "0"!]#define DEM_OPCYCLE_CTR_CSLF_SUPPORT          STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OPCYCLE_CTR_CSLF_SUPPORT          STD_OFF
[!ENDIF!]

#if (defined DEM_OPCYCLE_CTR_CSFF_SUPPORT)
#error DEM_OPCYCLE_CTR_CSFF_SUPPORT already defined
#endif
/** \brief Macro for availability of feature cycles since first failed */
[!CALL "IS_INT_DATA_REFERENCED", "InternalDataElement" = "'DEM_CYCLES_SINCE_FIRST_FAILED'"!]
[!IF "$IsIntDataReferenced"!]
  [!WS "0"!]#define DEM_OPCYCLE_CTR_CSFF_SUPPORT          STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OPCYCLE_CTR_CSFF_SUPPORT          STD_OFF
[!ENDIF!]

#if (defined DEM_OPCYCLE_CTRS_SUPPORT)
#error DEM_OPCYCLE_CTRS_SUPPORT already defined
#endif
/** \brief Macro for availability of any of the cycle counters as specified by AUTOSAR */
#if ( (DEM_OPCYCLE_CTR_CSLF_SUPPORT == STD_ON) || (DEM_OPCYCLE_CTR_CSFF_SUPPORT == STD_ON) )
#define DEM_OPCYCLE_CTRS_SUPPORT          STD_ON
#else
#define DEM_OPCYCLE_CTRS_SUPPORT          STD_OFF
#endif

/*------------------[Dem BSW Distribution macro]--------------------------------------*/

[!INDENT "0"!][!//
  [!VAR "DemBSWDistributionOfEventReports" = "'false'"!][!//
  [!IF "node:exists(DemGeneral/DemBSWDistribution/DemDistributedBSWEventReporting) and (DemGeneral/DemBSWDistribution/DemDistributedBSWEventReporting = 'true')"!][!//
    [!VAR "DemBSWDistributionOfEventReports" = "'true'"!][!//
  [!ENDIF!][!//
[!ENDINDENT!]
#if (defined DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING)
#error DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING already defined
#endif
/** \brief Macro for verifying if the Dem Multi-Core functionality is enabled */
#define DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING [!IF "$DemBSWDistributionOfEventReports"!][!WS!]STD_ON[!ELSE!][!WS!]STD_OFF[!ENDIF!]

/*==================[type definitions]======================================*/

/*------------------[Dem_ConfigType]----------------------------------------*/

/** \brief This type of the external data structure shall contain the post
 **  build initialization data for the Dem.
 **
 ** \note Type is unused, as only pre-compile time support is implemented. */
typedef uint8 Dem_ConfigType;

/*------------------[Dem_FFSegIdxType]--------------------------------------*/

/** \brief Index of freeze frame segment type
 **
 ** Index concerning ::Dem_FFSegments[].
 **
 ** Note: The range (maximum of 65500) of this type is limited by the
 ** configuration (multiplicity of parameter DemDidClass).
 */
typedef uint16 Dem_FFSegIdxType;

[!IF "DemGeneral/DemEventCombinationSupport = 'DEM_EVCOMB_TYPE1'"!]
/*------------------[Dem_DTCConfIdxType]------------------------------------*/
/** \brief Type of DTC configuration index
 **
 ** Note: Type is available only if Event Combination Support is Type 1
 */
[!CALL "CALC_EVENT_DESC"!]
[!IF "$CalEvDescDTCConfIdxWidth <= 8"!]
typedef uint8 Dem_DTCConfIdxType;
[!ELSE!][!//
typedef uint16 Dem_DTCConfIdxType;
[!ENDIF!]

[!ENDIF!]
/*==================[external function declarations]========================*/
[!IF "(count(DemConfigSet/*/DemEventParameter/*[node:refexists(DemDTCClassRef) and as:ref(DemDTCClassRef)/DemImmediateNvStorage = 'true']) > 0) or
      (DemGeneral/DemImmediateStorageInternalEvents = 'true') or (DemGeneral/DemClearDTCBehavior != 'DEM_CLRRESP_VOLATILE')"!]

#define DEM_START_SEC_[!"text:toupper(as:modconf('Dem')[1]/DemGeneral/DemCallbackMemStackMainFuncTrigger)"!]_CODE
#include <Dem_MemMap.h>

/** \brief Integration code for Memory stack main function triggering, allowing the Dem module
 ** to indirectly trigger the Memory stack by calling this callout function
 **
 ** Please refer to configuration parameter DemCallbackMemStackMainFuncTrigger for information.
 **
 ** \param[in]  BlockId Id of the NvM block
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_APPL_CODE) [!"DemGeneral/DemCallbackMemStackMainFuncTrigger"!](
  NvM_BlockIdType BlockId);

#define DEM_STOP_SEC_[!"text:toupper(as:modconf('Dem')[1]/DemGeneral/DemCallbackMemStackMainFuncTrigger)"!]_CODE
#include <Dem_MemMap.h>

[!ENDIF!]

[!IF "node:exists(DemGeneral/DemCalloutDynamicDTCFnc)"!]

#define DEM_START_SEC_[!"text:toupper(as:modconf('Dem')[1]/DemGeneral/DemCalloutDynamicDTCFnc)"!]_CODE
#include <Dem_MemMap.h>

/** \brief Get the variant specific DTC value of an event
 **
 ** The function calculates or looks up a variant specific DTC, based on the EventId
 ** and/or the original DTC value. It is called every time the Dem needs to access an UDS DTC.
 **
 ** \param[in]  EventId  Identification of an event by assigned event ID.
 **                      The event ID is configured in the Dem.
 ** \param[in]  DTC      Original/configured UDS DTC value of the selected event.
 **
 ** \return     Calculated or looked-up variant specific UDS DTC value for the selected event
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(uint32, DEM_APPL_CODE) [!"DemGeneral/DemCalloutDynamicDTCFnc"!](
  uint16 EventId, uint32 DTC);

#define DEM_STOP_SEC_[!"text:toupper(as:modconf('Dem')[1]/DemGeneral/DemCalloutDynamicDTCFnc)"!]_CODE
#include <Dem_MemMap.h>

[!ENDIF!]
/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

[!IF "(as:modconf('Dem')[1]/DemGeneral/DemExtendedDataCapture = 'DEM_TRIGGER_ON_FDC_THRESHOLD') and
      (as:modconf('Dem')[1]/DemGeneral/DemEventDisplacementStrategy = 'DEM_DISPLACEMENT_FULL') and
      (as:modconf('Dem')[1]/DemGeneral/DemEventDisplacementSupport = 'true')"!]
#define DEM_START_SEC_CONST_16
#include <Dem_MemMap.h>

  [!VAR "NumLines" = "0"!]
  [!LOOP "DemConfigSet/*/DemAdvDisplacementPassiveTableLine/*"!]
    [!WS "0"!]/** \brief event IDs of passive events, referenced by [!"name(.)"!] */
    [!WS "0"!]extern CONST(Dem_EventIdType, DEM_CONST)
      [!WS "2"!]Dem_AdvDisplPassiveEventIdsLine[!"num:integer($NumLines)"!][DEM_NUM_OF_PASSIVE_EVENT_REFS_LINE[!"num:integer($NumLines)"!]];

      [!VAR "NumLines" = "$NumLines + 1"!]
  [!ENDLOOP!]

#define DEM_STOP_SEC_CONST_16
#include <Dem_MemMap.h>
[!ENDIF!]

#define DEM_START_SEC_CONST_8
#include <Dem_MemMap.h>

/** \brief Configuration structure */
extern CONST(Dem_ConfigType, DEM_CONST) [!"name(DemConfigSet/*[1])"!];

#define DEM_STOP_SEC_CONST_8
#include <Dem_MemMap.h>

/* !LINKSTO Dem.Dem_FFSegId.External,1 */
[!IF "$CalibrationSupport = 'true'"!]
#define DEM_START_SEC_CALIB_16
#include <Dem_MemMap.h>

  [!LOOP "DemGeneral/DemFreezeFrameClass/*"!]
    [!VAR "NumFFSegs" = "count(DemDidClassRef/*)"!]
    [!WS "0"!]extern CONST(Dem_FFSegIdxType, DEM_CONST) Dem_FFSegIdx[!"name(.)"!][[!"num:integer($NumFFSegs)"!]];
  [!ENDLOOP!]

#define DEM_STOP_SEC_CALIB_16
#include <Dem_MemMap.h>
[!ENDIF!]

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/

#endif /* ifndef DEM_CFG_H */
/*==================[end of file]===========================================*/
