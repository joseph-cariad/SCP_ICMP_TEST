/**
 * \file
 *
 * \brief AUTOSAR Dem
 *
 * This file contains the implementation of the AUTOSAR
 * module Dem.
 *
 * \version 6.4.1
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2021 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
#ifndef DEM_H
#define DEM_H

/* This file contains or includes all external identifiers of
 * the AUTOSAR module Dem. */

/*==================[inclusions]============================================*/
/* !LINKSTO dsn.Dem.IncludeStr,1 */

#include <TSAutosar.h>                        /* EB specific standard types */
#include <Std_Types.h>                            /* AUTOSAR standard types */

#include <Dem_Types.h>           /* public Dem types, also generated by RTE */
#include <Dem_BSW_Types.h>                      /* public Dem RTE prototype */

#include <Dem_Stc.h>                        /* Module public static symbols */

#if (DEM_DCM_ENABLED == STD_ON)
#include <Dcm_Types.h>
#endif

/* !LINKSTO Dem.ProjectSpecificCustomization.HeaderFile,1 */
#if (DEM_PROJECT_SPECIFIC_CUSTOMIZATION_SUPPORT == STD_ON)
#include <Dem_Customization.h>      /* project specific APIs implementation */
#endif

/*==================[macros]================================================*/

/*------------------[DTC status indicators bits]----------------------------*/

#if (defined DEM_SI30_STATUS_UNCONFIRMEDDTC)
#error DEM_SI30_STATUS_UNCONFIRMEDDTC already defined
#endif
/** \brief DTC status indicator unconfirmed DTC status-bit */
#define DEM_SI30_STATUS_UNCONFIRMEDDTC      0x01U

#if (defined DEM_SI30_STATUS_UNCONFIRMEDDTC_TOC)
#error DEM_SI30_STATUS_UNCONFIRMEDDTC_TOC already defined
#endif
/** \brief DTC status indicator unconfirmed DTC in this operation cycle
 ** status-bit */
#define DEM_SI30_STATUS_UNCONFIRMEDDTC_TOC  0x02U

#if (defined DEM_SI30_STATUS_UNCONFIRMEDDTC_SLC)
#error DEM_SI30_STATUS_UNCONFIRMEDDTC_SLC already defined
#endif
/** \brief DTC status indicator unconfirmed DTC since last clear status-bit */
#define DEM_SI30_STATUS_UNCONFIRMEDDTC_SLC  0x04U

#if (defined DEM_SI30_STATUS_AGEDDTC)
#error DEM_SI30_STATUS_AGEDDTC already defined
#endif
/** \brief DTC status indicator aged DTC status-bit */
#define DEM_SI30_STATUS_AGEDDTC             0x08U

#if (defined DEM_SI30_STATUS_SYMPTOM_SLC)
#error DEM_SI30_STATUS_SYMPTOM_SLC already defined
#endif
/** \brief DTC status indicator symptom since last clear status-bit */
#define DEM_SI30_STATUS_SYMPTOM_SLC         0x10U

#if (defined DEM_SI30_STATUS_WIR_SLC)
#error DEM_SI30_STATUS_WIR_SLC already defined
#endif
/** \brief DTC status indicator warning indicator request since last clear
 ** status-bit */
#define DEM_SI30_STATUS_WIR_SLC             0x20U

#if (defined DEM_SI30_STATUS_EMISSIONRELATEDDTC)
#error DEM_SI30_STATUS_EMISSIONRELATEDDTC already defined
#endif
/** \brief DTC status indicator emission related DTC status-bit */
#define DEM_SI30_STATUS_EMISSIONRELATEDDTC  0x40U

#if (defined DEM_SI30_STATUS_TFSLC_AGED)
#error DEM_SI30_STATUS_TFSLC_AGED already defined
#endif
/** \brief DTC status indicator test failed since last clear or aged
 ** status-bit */
#define DEM_SI30_STATUS_TFSLC_AGED          0x80U

/*==================[external data]=========================================*/

#define DEM_START_SEC_VAR_SAVED_ZONE_UNSPECIFIED
#include <Dem_MemMap.h>

/** \brief Struct containing all NVRAM data */
extern VAR(Dem_NvDataType, DEM_VAR_CLEARED) Dem_NvData;

#define DEM_STOP_SEC_VAR_SAVED_ZONE_UNSPECIFIED
#include <Dem_MemMap.h>

#define DEM_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <Dem_MemMap.h>

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)

/** \brief Struct containing gate entry base and primary data to be read
 ** from and written to NVRAM block */
extern VAR(Dem_NvGateEntryPrimaryDataType, DEM_VAR_CLEARED)
  Dem_NvGateEntryPrimaryData;

#if (DEM_MAX_NUMBER_EVENT_ENTRY_SEC != 0U)
/** \brief Struct containing gate entry base and secondary data to be read
 ** from and written to NVRAM block */
extern VAR(Dem_NvGateEntrySecondaryDataType, DEM_VAR_CLEARED)
  Dem_NvGateEntrySecondaryData;
#endif

#if (DEM_MAX_NUMBER_EVENT_ENTRY_MIR != 0U)
/** \brief Struct containing gate entry base and mirror data to be read from
 ** and written to NVRAM block */
extern VAR(Dem_NvGateEntryMirrorDataType, DEM_VAR_CLEARED)
  Dem_NvGateEntryMirrorData;
#endif

#endif /* DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON */

#define DEM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <Dem_MemMap.h>

/*==================[external function declarations]========================*/

#define DEM_START_SEC_CODE
#include <Dem_MemMap.h>

#if (DEM_VERSION_INFO_API == STD_ON)
/** \brief This service returns the version information of this module.
 **
 ** The version information includes:
 ** - Module Id
 ** - Vendor Id
 ** - Vendor specific version numbers (BSW00407).
 **
 ** This function shall be pre compile time configurable On/Off by the
 ** configuration parameter: DEM_VERSION_INFO_API
 **
 ** \param[out] versioninfo  Pointer to where to store the version information
 **                          of this module.
 **
 ** \ServiceID{::DEM_SID_GetVersionInfo}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_GetVersionInfo(
  P2VAR(Std_VersionInfoType, AUTOMATIC, DEM_APPL_DATA) versioninfo);
#endif /* DEM_VERSION_INFO_API == STD_ON */

/*------------------[Interface ECU State Manager <--> Dem]------------------*/

/** \brief PreInit function to make the Dem queue operational
 **
 ** This function shall be used to initialize the internal states necessary to
 ** process events reported by BSWs
 **
 ** Dem_PreInit() shall be called by the ECU State Manager during the startup
 ** phase of the ECU before the NVRAM Manager has finished the restore of
 ** NVRAM data.
 **
 ** \param[in] ConfigPtr  refer to ::Dem_ConfigType
 **
 ** \ServiceID{::DEM_SID_PreInit}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_PreInit(
  P2CONST(Dem_ConfigType, AUTOMATIC, DEM_APPL_CONST) ConfigPtr);

/** \brief Initializes or reinitializes the Dem module.
 **
 ** This function shall be used during the startup phase of the ECU after
 ** the NVRAM Manager has finished the restore of NVRAM data.
 **
 ** SW-Components including Monitor Functions are initialized afterwards.
 **
 ** Caveats: The Dem is not functional until this function has been called.
 **
 ** \ServiceID{::DEM_SID_Init}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_Init(void);

/** \brief Shutdown function
 **
 ** This function is used to complete all pending operations in the Dem
 ** by preparing the internal states and event data for transfer to the NVRAM
 **
 ** Caveats: Once this function has been executed no further updates
 ** are applied to the Dem internal event data.
 **
 ** \ServiceID{::DEM_SID_Shutdown}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_Shutdown(void);

/*------------------[Interface BSW modules / SW-Components <--> Dem]--------*/

/** \brief Selects a DTC or DTC group as target for further operations.
 **
 ** This API shall be called before the following operations:
 ** Dem_ClearDTC(), Dem_DisableDTCRecordUpdate(), Dem_EnableDTCRecordUpdate(),
 ** Dem_GetDTCSelectionResult(), Dem_GetFunctionalUnitOfDTC(),
 ** Dem_GetSeverityOfDTC(), Dem_GetStatusOfDTC(), Dem_SelectFreezeFrameData(),
 ** Dem_SelectExtendedDataRecord() and Dem_GetDTCSelectionResultForClearDTC().
 **
 ** \param[in] ClientId   Unique client ID, assigned to the instance of the
 **                       calling module.
 ** \param[in] DTC        Defines the DTC in respective format that is
 **                       selected.
 **                       If the DTC fits to a DTC group number, the DTC group
 **                       is selected.
 ** \param[in] DTCFormat  Defines the input-format of the provided DTC value.
 ** \param[in] DTCOrigin  The event memory of the requested DTC or group of
 **                       DTC.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK      DTC selection successfully requested.
 ** \retval E_NOT_OK  DTC selection request failed.
 **
 ** \ServiceID{::DEM_SID_SelectDTC}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.SelectDTC,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SelectDTC(
  uint8             ClientId,
  uint32            DTC,
  Dem_DTCFormatType DTCFormat,
  Dem_DTCOriginType DTCOrigin);

/** \brief Provides the status of the DTC selection request.
 **
 ** This API provides information if the last call to Dem_SelectDTC() has
 ** selected a valid DTC or group of DTCs.
 ** The API is optionally called after a Dem_SelectDTC(). APIs which depend on
 ** Dem_SelectDTC() have the same behavior with or without the call of
 ** Dem_GetDTCSelectionResult.
 **
 ** \param[in] ClientId   Unique client ID, assigned to the instance of the
 **                       calling module.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK                 The DTC select parameter check is successful
 **                              and the requested DTC or group of DTC in the
 **                              selected origin is selected for further
 **                              operations.
 ** \retval E_NOT_OK             No DTC selected.
 ** \retval DEM_WRONG_DTC        Selected DTC value in selected format does
 **                              not exist.
 ** \retval DEM_WRONG_DTCORIGIN  Selected DTCOrigin does not exist.
 **
 ** \ServiceID{::DEM_SID_GetDTCSelectionResult}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_91023,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetDTCSelectionResult(
  uint8 ClientId);

/** \brief Provides information if the last call to Dem_SelectDTC() has selected
 ** a valid DTC or group of DTCs
 **
 ** The function provides information if the last call to Dem_SelectDTC() has
 ** selected a valid DTC or group of DTCs for Dem_ClearDTC().
 **
 ** \param[in] ClientId   Unique client id, assigned to the instance of the
 **                       calling module.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK                 The DTC select parameter check is successful
 **                              and the requested DTC or group of DTC in the
 **                              selected origin is selected for further
 **                              operations.
 ** \retval E_NOT_OK             No DTC selected.
 ** \retval DEM_WRONG_DTC        Selected DTC value in selected format does
 **                              not exist.
 ** \retval DEM_WRONG_DTCORIGIN  Selected DTCOrigin does not exist or ClearDTC
 **                              is prohibited.
 **
 ** \ServiceID{::DEM_SID_GetDTCSelectionResultForClearDTC}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.GetDTCSelectionResultForClearDTC,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetDTCSelectionResultForClearDTC(
  uint8 ClientId);

#if (DEM_NUM_BSW_EVENTS > 0U)

/** \brief Function to report the status of diagnostic events of BSW
 **
 ** Interface for BSW Components to report Errors during start up (even before
 ** Dem initialization) and normal operation. At a first step, it is assumed,
 ** that all incoming results are considered as debounced. If a central
 ** pre-debouncing is provided, this API shall be used to support them for the
 ** BSW.
 **
 ** In case ::DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING is enabled, this
 ** API supports calls from the configured Dem satellite instances.
 **
 ** Configurations: The size of the buffer queue needs to be configured (ref.
 ** to ::DEM_BSW_ERROR_BUFFER_SIZE)
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] EventStatus  Monitor test result
 **
 ** \ServiceID{::DEM_SID_ReportErrorStatus}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Asynchronous}
 */
/* !LINKSTO Dem.Dem_ReportErrorStatus.Unavailable,1 */
extern FUNC(void, DEM_CODE) Dem_ReportErrorStatus(
  Dem_EventIdType     EventId,
  Dem_EventStatusType EventStatus);
#endif

#define DEM_STOP_SEC_CODE
#include <Dem_MemMap.h>

#if (DEM_INCLUDE_RTE == STD_ON)
#define Dem_START_SEC_CODE
#else
#define DEM_START_SEC_CODE
#endif
#include <Dem_MemMap.h>

#if (DEM_INCLUDE_RTE == STD_OFF)

/** \brief Processes the events reported by SW-Cs via RTE
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim. Some bits of the UDS DTC status
 ** byte changes synchronously or asynchronously (refer to Dem036 and Dem379).
 **
 ** Service for reporting the Event Status to the Dem. This service shall be
 ** used to report an Event Status as soon as a new test result is available.
 **
 ** This Service stores the event in the Event Memory.
 **
 ** API is called from the Monitor Function.
 **
 ** Caveats: Dem configuration during integration of Monitor Functions is
 ** system specific.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 **
 ** \param[in] EventStatus Monitor test result
 **
 ** \return success of operation
 ** \retval E_OK     set of event status was successful
 ** \retval E_NOT_OK set of event status failed or could not be accepted
 **
 ** \ServiceID{::DEM_SID_SetEventStatus}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous/Asynchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetEventStatus(
  Dem_EventIdType     EventId,
  Dem_EventStatusType EventStatus);

/** \brief Resets the event failed status
 **
 ** This API can only be used through the RTE and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 ** This service shall be used to reset the Event Status stored in the Event
 ** Memory in the Dem, without the usage of API Dem_SetEventStatus(EventId,
 ** Passed), because no new test result is available at this time.
 **
 ** With this API the status bit "Failed" defined by
 ** Dem_EventStatusExtendedType is set to 0. API is called by Monitor
 ** Function.
 **
 ** Refer to ISO14229: DTC Status Bit Definition, Table D.14, Bit0 Test
 ** failed.
 **
 ** Dem_ResetEventStatus does not influence the status bit 6
 ** ("testNotCompletedThisMonitoringCycle")
 **
 ** Caveats: Dem configuration during integration of Monitor Functions
 ** is system specific
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 **
 ** \return success of operation
 ** \retval E_OK     reset of event status was successful
 ** \retval E_NOT_OK reset of event status failed
 **
 ** \ServiceID{::DEM_SID_ResetEventStatus}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_ResetEventStatus(
  Dem_EventIdType EventId);

/** \brief Captures the freeze frame data for a specific event
 **
 ** This API can only be used through the RTE and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** If the Dem does not receive any request to pre-store a freeze frame,
 ** freeze frame capture is linked to the API call Dem_SetEventStatus(). This
 ** API call triggers the freeze frame storage.
 **
 ** If Dem_SetEventStatus(EventId, Passed) is called the corresponding
 ** pre-stored freeze frame is discarded (same behavior like
 ** Dem_ClearPrestoredFreezeFrame()). The API call Dem_ResetEventStatus() does
 ** not influence the pre-stored freeze frame.
 **
 ** API is called from Monitor Function.
 **
 ** Caveats: Dem configuration during integration of Monitor Functions is
 ** system specific.
 **
 ** Configuration: While configuring the Dem the capability of pre-store
 ** functionality for the required event has to be defined.
 **
 ** Note: Optional development freeze frames are not supported by this API.
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 **
 ** \return success of operation
 ** \retval E_OK     PreStoreFreezeFrame was successful
 ** \retval E_NOT_OK PreStoreFreezeFrame failed
 **
 ** \ServiceID{::DEM_SID_PrestoreFreezeFrame}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_PrestoreFreezeFrame(
  Dem_EventIdType EventId);

/** \brief Clears a prestored freeze frame of a specific event
 **
 ** This API can only be used through the RTE and therefore no declaration
 ** is exported via \verbatim Dem.h\endverbatim.
 **
 ** The API shall be called to delete or release the prestored freeze frame for
 ** specific Event ID. If the API Dem_SetEventStatus() (passed | failed) is
 ** called it has the same effect - that means it's not necessary to call the
 ** API Dem_ClearPrestoredFreezeFrame directly after Dem_SetEventStatus().
 **
 ** Caveats: Dem configuration during integration of Monitor Functions is
 ** system specific.
 **
 ** Configuration: While configuring the Dem the capability of pre-store
 ** functionality for the required event has to be defined.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 **
 ** \return success of operation
 ** \retval E_OK     ClearPreStoreFreezeFrame was successful
 ** \retval E_NOT_OK ClearPreStoreFreezeFrame failed
 **
 ** \ServiceID{::DEM_SID_ClearPrestoredFreezeFrame}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_ClearPrestoredFreezeFrame(
  Dem_EventIdType EventId);

/** \brief Sets an operation cycle state
 **
 ** Dem shall be called by the SW-Component as soon as it detects the status
 ** change of the CycleState for the Operation Cycle.
 **
 ** Configuration: The OperationCycleId shall be configured in view of sender
 ** receiver communication.
 **
 ** \param[in] OperationCycleId  Identification of operation cycle, like power
 **                     cycle, driving cycle,  ... (0 <= OpCycleId < DEM_NUM_OPCYCLES)
 **
 ** \param[in] CycleState  New operation cycle state: (re-)start or end
 **
 ** \return success of operation
 ** \retval E_OK     set of operation cycle was successful
 ** \retval E_NOT_OK set of operation cycle failed
 **
 ** \ServiceID{::DEM_SID_SetOperationCycleState}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetOperationCycleState(
  Dem_OperationCycleIdType    OperationCycleId,
  Dem_OperationCycleStateType CycleState);

/** \brief Sets an operation cycle as qualified
 **
 ** Dem shall be called by the SW-Component as soon as it detects that the
 ** operation cycle is qualified.
 **
 ** \param[in] OperationCycleId  Identification of operation cycle
 **                              Note: Only driving cycle is allowed!
 **
 ** \return success of operation
 ** \retval E_OK     set operation cycle as qualified has succeeded
 ** \retval E_NOT_OK operation cycle could not be set as qualified
 **
 ** \ServiceID{::DEM_SID_SetCycleQualified}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.OperationCycleQualification.SetCycleQualified,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetCycleQualified(
  Dem_OperationCycleIdType OperationCycleId);

/** \brief Provides the value of the external operation cycle counter
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** Note: Functionality not implemented, only stub available.
 ** \param[in] OperationCycleId  Identification of operation cycle, like power
 **                     cycle, driving cycle,  ... (0 <= OpCycleId < DEM_NUM_OPCYCLES)
 ** \param[in] CounterValue  Current external counter value of the respective operation
 **                     cycle.
 **
 ** \return success of operation
 ** \retval E_OK      set of operation cycle counter was successful
 ** \retval E_NOT_OK  set of operation cycle counter failed
 **
 ** \ServiceID{::DEM_SID_SetOperationCycleCntValue}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetOperationCycleCntValue(
  uint8 OperationCycleId,
  uint8 CounterValue);

#if ( (DEM_AGINGCYCLE_COUNTER_PROCESSING == DEM_PROCESS_AGINGCTR_INTERN) && \
      (DEM_NUM_AGINGCYCLES > 0U) )
/** \brief Triggers the next aging cycle state
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** \param[in] AgingCycleId  Identification of aging cycle.
 **
 ** \return success of operation
 ** \retval E_OK      set of aging cycle was successful
 ** \retval E_NOT_OK  set of aging cycle failed
 **
 ** \ServiceID{::DEM_SID_SetAgingCycleState}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetAgingCycleState(
  uint8 AgingCycleId);
#endif

/** \brief Provides the value of the external aging cycle counter
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** Note: Functionality not implemented, only stub available.
 ** \param[in] CounterValue  Current external aging cycle counter value.
 **
 ** \return success of operation
 ** \retval E_OK      set of aging cycle counter was successful
 ** \retval E_NOT_OK  set of aging cycle counter failed
 **
 ** \ServiceID{::DEM_SID_SetAgingCycleCounterValue}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetAgingCycleCounterValue(
  uint8 CounterValue);

#if (DEM_USER_CTRL_WIR_SUPPORT == STD_ON)
/** \brief Sets the WIR status bit via failsafe SW-Cs.
 **
 ** Note: Because the user controlled warning indicator requested bits are only
 ** stored volatile, after a module restart this information is lost for Dem.
 ** The failsafe SW-C application must know the current UserCtrlWIR and request
 ** it again, if necessary.
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** \param[in] EventId    Identification of an event by assigned EventId.
 **                       The Event Number is configured in the DEM.
 **                       Min.: 1 (0: Indication of no Event or Failure).
 **                       Max.:Result of configuration of Event Numbers in
 **                       DEM (Max is either 255 or 65535).
 ** \param[in] WIRStatus  Requested status of event related WIR-bit (regarding
 **                       to the current status of function inhibition).
 **                       WIRStatus = TRUE -> WIR-bit shall be set to "1".
 **                       WIRStatus = FALSE -> WIR-bit shall be set to "0",
 **                       if no internal indicator requested it on.
 **
 ** \return success of operation
 ** \retval E_OK      The request is accepted.
 ** \retval E_NOT_OK  The request is not accepted (e.g. disabled controlDTCSetting)
 **                   and should be repeated.
 **
 ** \ServiceID{::DEM_SID_SetWIRStatus}
 ** \Reentrancy{Reentrant for different EventIds. Non reentrant for the same EventId.}
 ** \Synchronicity{Synchronous}
 **
 */
/* !LINKSTO SWS_Dem_00831,1 */
/* !LINKSTO SWS_Dem_00839,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetWIRStatus(
  Dem_EventIdType EventId, boolean WIRStatus);
#endif

/** \brief Gets the debouncing status of an event
 **
 ** Note: Functionality not implemented, only stub available.
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[out] DebouncingState  Bit 0 Temporarily Defective (corresponds to 0 < FDC < 127)
 **                              Bit 1 finally Defective (corresponds to FDC = 127)
 **                              Bit 2 temporarily healed (corresponds to -128 < FDC < 0)
 **                              Bit 3 Test complete (corresponds to FDC = -128 or FDC = 127)
 **                              Bit 4 DTR Update (= Test complete && Debouncing
 **                              complete && enable conditions / storage conditions
 **                              fulfilled)
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation could not be performed
 ** \retval DEM_E_NODATAAVAILABLE The requested event data is not currently
 **                               stored (but the request was valid)
 ** \retval DEM_E_WRONG_RECORDNUMBER The requested record number is not
 **                                  supported by the event
 ** \retval DEM_E_WRONG_BUFFERSIZE The provided buffer size is too small.
 **
 ** \ServiceID{::DEM_SID_GetDebouncingOfEvent}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetDebouncingOfEvent(
  Dem_EventIdType                                          EventId,
  P2VAR(Dem_DebouncingStateType, AUTOMATIC, DEM_APPL_DATA) DebouncingState);

/** \brief Gets the data of a freeze frame by event.
 **
 ** Note: Functionality not implemented, only stub available.
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] RecordNumber  This parameter is a unique identifier for a
 **                     freeze frame record as defined in ISO15031-5
 **                     and ISO14229-1.
 ** \param[in] DataId  This parameter specifies the PID/DID that shall be
 **                     copied to the destination buffer. If ReportTotalRecord
 **                     is TRUE, the value of DataId is ignored.
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **                     to the buffer, to which the freeze frame data record
 **                     shall be written to. The format is raw hexadecimal
 **                     values and contains no header-information.
 ** \param[out] BufSize  When the function is called this parameter contains
 **                     the maximum number of data bytes that can be written
 **                     to the buffer.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation could not be performed
 ** \retval DEM_E_NODATAAVAILABLE The requested event data is not currently
 **                               stored (but the request was valid)
 ** \retval DEM_E_WRONG_RECORDNUMBER The requested record number is not
 **                                  supported by the event
 ** \retval DEM_E_WRONG_DIDNUMBER The requested DID is not supported by the
 **                               freeze frame
 ** \retval DEM_E_WRONG_BUFFERSIZE The provided buffer size is too small.
 **
 ** \ServiceID{::DEM_SID_GetEventFreezeFrameData}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventFreezeFrameDataEx(
  Dem_EventIdType                         EventId,
  uint8                                   RecordNumber,
  uint16                                  DataId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) BufSize);

/** \brief Gets the data of an extended data record by event
 **
 ** Note: Functionality not implemented, only stub available.
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] RecordNumber  Identification of requested Extended data record.
 **                     Valid values are between 0x01 and 0xEF as defined in.
 **                     ISO14229-1. 0xFF means data of all extended data records
 **                     are returned
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **                     to the buffer, to which the extended data shall be
 **                     written to. The format is raw hexadecimal values and
 **                     contains no header-information.
 ** \param[out] BufSize  When the function is called this parameter contains
 **                     the maximum number of data bytes that can be written
 **                     to the buffer.
 **                     The function returns the actual number of written
 **                     data bytes in this parameter.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation could not be performed
 ** \retval DEM_E_NODATAAVAILABLE The requested event data is not currently
 **                               stored (but the request was valid)
 ** \retval DEM_E_WRONG_RECORDNUMBER The requested record number is not
 **                                  supported by the event
 ** \retval DEM_E_WRONG_BUFFERSIZE The provided buffer size is too small.
 **
 ** \ServiceID{::DEM_SID_GetEventExtendedDataRecordEx}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventExtendedDataRecordEx(
  Dem_EventIdType                         EventId,
  uint8                                   RecordNumber,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) BufSize);

/** \brief Gets the fault detection counter of an event
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** The API shall be used by SW-C to request the current Fault Detection
 ** Counter for a given EventID.
 **
 ** \param[in] EventId  Provide the EventId value the fault detection counter
 **                     is requested for. If the return value of the function
 **                     is other than OK this parameter does not contain valid
 **                     data.
 ** \param[out] FaultDetectionCounter  This parameter receives the
 **                     Fault Detection Counter information of the requested
 **                     EventId. If the return value of the function call is
 **                     other than OK this parameter does not contain valid
 **                     data.
 **
 ** \return success of operation
 ** \retval E_OK                    request was successful
 ** \retval E_NOT_OK                request failed
 ** \retval DEM_E_NO_FDC_AVAILABLE  there is no fault detection counter
 **                                 available for the requested event
 **
 ** \ServiceID{::DEM_SID_GetFaultDetectionCounter}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetFaultDetectionCounter(
  Dem_EventIdType                        EventId,
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA) FaultDetectionCounter);

#endif /* (DEM_INCLUDE_RTE == STD_OFF) */

#if ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL))

/** \brief Gets the current extended event status of an event
 **
 ** This API shall be used to read the event status from the Dem. This API is
 ** provided to be used by SW-Components or other basic software modules
 ** e.g. FiM.
 **
 ** For the DCM the API Dem_GetStatusOfDTC() is used.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[out] EventStatusExtended  for explanation see
 **                     ::Dem_EventStatusExtendedType
 **
 ** \return success of operation
 ** \retval E_OK     get of event status was successful
 ** \retval E_NOT_OK get of event status failed
 **
 ** \ServiceID{::DEM_SID_GetEventStatus}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventStatus(
  Dem_EventIdType EventId,
  P2VAR(Dem_EventStatusExtendedType, AUTOMATIC, DEM_APPL_DATA)
    EventStatusExtended);

/** \brief Gets the event failed status of an event
 **
 ** This API shall be used to read Bit 0 of ::Dem_EventStatusExtendedType from
 ** the Dem.
 **
 ** For the DCM the API Dem_GetStatusOfDTC() is used.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[out] EventFailed
 **                     - TRUE Last Failed
 **                     - FALSE not Last Failed
 **
 ** \return success of operation
 ** \retval E_OK     get of event failed was successful
 ** \retval E_NOT_OK get of event failed failed
 **
 ** \ServiceID{::DEM_SID_GetEventFailed}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventFailed(
  Dem_EventIdType                          EventId,
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) EventFailed);

/** \brief Gets the event tested status of an event
 **
 ** This API shall be used to read negated Bit 6 of
 ** ::Dem_EventStatusExtendedType from the Dem.
 **
 ** For the DCM the API Dem_GetStatusOfDTC() is used.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[out] EventTested
 **                     - TRUE event tested this cycle
 **                     - FALSE event not tested this cycle
 **
 ** \return success of operation
 ** \retval E_OK     get of event state "tested" was successful
 ** \retval E_NOT_OK get of event state "tested" failed
 **
 ** \ServiceID{::DEM_SID_GetEventTested}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventTested(
  Dem_EventIdType                          EventId,
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) EventTested);

/** \brief Function to get the DTC of an event
 **
 ** Gets the DTC which is mapped to EventId by Dem Configuration.
 **
 ** Configuration: Mapping of Events to DTCs is configured in Dem. Mapping is
 ** "n to 1" or "1 to n".
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] DTCFormat  This parameter defines the output-format of the
 **                     requested DTC value, either OBD DTC format or
 **                     UDS DTC format.
 ** \param[out] DTCOfEvent  Receives the DTC value returned by the function.
 **                     If the return value of the function is other than
 **                     OK this parameter does not contain valid data.
 **
 ** \return success of operation
 ** \retval E_OK                   get of DTC was successful
 ** \retval E_NOT_OK               get of DTC failed
 ** \retval DEM_E_NO_DTC_AVAILABLE there is no DTC configured in the requested
 **                     format
 **
 ** \ServiceID{::DEM_SID_GetDTCOfEvent}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetDTCOfEvent(
  Dem_EventIdType                              EventId,
  Dem_DTCFormatType                            DTCFormat,
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA)      DTCOfEvent);

#if (DEM_NUM_ENABLECONDITIONS > 0U)
/** \brief Function to set enable condition
 **
 ** This API shall be used to set the enable condition. For each event an
 ** enable condition value is assigned to. An enable condition specifies
 ** a certain number of checks (e.g. correct voltage range) for an event
 ** before the event can be qualified as confirmed.
 **
 ** Configuration: Required configuration parameters per event:
 **                - EnableConditionID
 **                - EnableConditionStatus
 **
 ** This API is optional and depends on the automotive manufacturer.
 **
 ** Note: This API is not available, if no enable condition are configured.
 ** \param[in] EnableConditionID  This parameter identifies the enable
 **                condition.
 ** \param[in] ConditionFulfilled  This parameter specifies whether the
 **                enable condition assigned to the EnableConditionID
 **                is fulfilled (TRUE) or not fulfilled (FALSE).
 **
 ** \return success of operation
 ** \retval E_OK       enable condition could be set successfully
 ** \retval E_NOT_OK   enable condition could not be set
 **
 ** \ServiceID{::DEM_SID_SetEnableCondition}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetEnableCondition(
  uint8   EnableConditionID,
  boolean ConditionFulfilled);
#endif

/** \brief Sets a storage condition.
 **
 ** Note: Functionality not implemented, only stub available.
 ** \param[in] StorageConditionID  This parameter identifies the storage condition.
 ** \param[in] ConditionFulfilled  This parameter specifies whether the
 **                enable condition assigned to the EnableConditionID
 **                is fulfilled (TRUE) or not fulfilled (FALSE).
 **
 ** \return success of operation
 ** \retval E_OK       storage condition could be set successfully
 ** \retval E_NOT_OK   storage condition could be set
 **
 ** \ServiceID{::DEM_SID_SetStorageCondition}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetStorageCondition(
  uint8   StorageConditionID,
  boolean ConditionFulfilled);

/** \brief Reset/freeze counter, time, frequency-based event debouncing.
 **
 ** \param[in] EventId              Identification of an event by assigned EventId.
 **                                 The Event Number is configured in the DEM.
 **                                 Min.: 1 (0: Indication of no Event or Failure)
 **                                 Max.:Result of configuration of Event Numbers in
 **                                 DEM (Max is either 255 or 65535). **
 ** \param[in] DebounceResetStatus  Identification of freeze or reset behavior of
 **                                 the internal debounce counter/timer/frequency.
 ** \return success of operation
 ** \retval E_OK      Freeze/reset of event debounce counter/timer/frequency was successful.
 ** \retval E_NOT_OK  Only on development error, Freeze/reset was not successful.
 **
 ** \ServiceID{::DEM_SID_ResetEventDebounceStatus}
 ** \Reentrancy{Reentrant for different EventIds. Non reentrant for the same EventId.}
 ** \Synchronicity{Synchronous}
 **
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_ResetEventDebounceStatus(
  Dem_EventIdType EventId,
  Dem_DebounceResetStatusType DebounceResetStatus);

#endif /* ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL)) */

#if ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL))

#if (DEM_NUMBER_OF_INDICATORS > 0U)
/** \brief Reads the indicator-status
 **
 ** This function shall be used to read the indicator-status derived from the
 ** event status as a summary of all assigned events.
 **
 ** Configuration: The assignment for the Dem_IndicatorId to indicator has to
 ** be done. Examples for indicators: lamps, different text messages, icons,
 ** ...
 **
 ** Note: This API is not available, if no indicators are configured.
 ** \param[in] IndicatorId  Number of indicator
 ** \param[out] IndicatorStatus  Status of the indicator, like on, off,
 **                              blinking.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed or is not supported
 **
 ** \ServiceID{::DEM_SID_GetIndicatorStatus}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem046,2 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetIndicatorStatus(
  Dem_IndicatorIdType                                      IndicatorId,
  P2VAR(Dem_IndicatorStatusType, AUTOMATIC, DEM_APPL_DATA) IndicatorStatus);
#endif

#endif /* ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL)) */

#if ( (DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL) || \
      ( (DEM_DEFAULT_ASR_SERVICE_API != DEM_SERVICE_API_ASR40) && \
        (DEM_ENABLE_ASR40_SERVICE_API == STD_OFF) ) )
#if (DEM_ENABLE_ASR43_SERVICE_API == STD_OFF)
/** \brief Gets the data of a freeze frame by event.
 **
 ** Note: Optional development freeze frames are not supported by this API.
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] RecordNumber  This parameter is a unique identifier for a
 **                     freeze frame record as defined in ISO15031-5
 **                     and ISO14229-1.
 ** \param[in] ReportTotalRecord  This parameter specifies whether all
 **                     PIDs/DIDs are requested (TRUE). A dedicated
 **                     PID/DID is requested by the parameter DataId
 **                     (FALSE)
 ** \param[in] DataId  This parameter specifies the PID/DID that shall be
 **                     copied to the destination buffer. If ReportTotalRecord
 **                     is TRUE, the value of DataId is ignored.
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **                     to the buffer, to which the freeze frame data record
 **                     shall be written to. The format is raw hexadecimal
 **                     values and contains no header-information.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_GetEventFreezeFrameData}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventFreezeFrameData(
  Dem_EventIdType                        EventId,
  uint8                                  RecordNumber,
  boolean                                ReportTotalRecord,
  uint16                                 DataId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) DestBuffer);
#endif /* (DEM_ENABLE_ASR43_SERVICE_API == STD_OFF) */
#endif

#if ( (DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL) || \
      ( (DEM_DEFAULT_ASR_SERVICE_API != DEM_SERVICE_API_ASR42) && \
        (DEM_ENABLE_ASR42_SERVICE_API == STD_OFF) ) )
#if (DEM_ENABLE_ASR43_SERVICE_API == STD_OFF)
/** \brief Gets the data of a freeze frame by event.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] RecordNumber  This parameter is a unique identifier for a
 **                     freeze frame record as defined in ISO15031-5
 **                     and ISO14229-1.
 ** \param[in] ReportTotalRecord  This parameter specifies whether all
 **                     PIDs/DIDs are requested (TRUE). A dedicated
 **                     PID/DID is requested by the parameter DataId
 **                     (FALSE)
 ** \param[in] DataId  This parameter specifies the PID/DID that shall be
 **                     copied to the destination buffer. If ReportTotalRecord
 **                     is TRUE, the value of DataId is ignored.
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **                     to the buffer, to which the freeze frame data record
 **                     shall be written to. The format is raw hexadecimal
 **                     values and contains no header-information.
 **
 ** \return success of operation
 ** \retval E_OK                    Operation was successful
 ** \retval DEM_E_NODATAAVAILABLE   The requested event data is not currently
 **                                 stored (but the request was valid)
 ** \retval DEM_E_WRONG_RECORDNUMBER  The requested record number is not
 **                                   supported by the event
 ** \retval DEM_E_WRONG_DIDNUMBER   The requested DID is not supported by
 **                                 the freeze frame
 **
 ** \ServiceID{::DEM_SID_GetEventFreezeFrameData}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_ASR42_GetEventFreezeFrameData(
  Dem_EventIdType                        EventId,
  uint8                                  RecordNumber,
  boolean                                ReportTotalRecord,
  uint16                                 DataId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) DestBuffer);
#endif /* (DEM_ENABLE_ASR43_SERVICE_API == STD_OFF) */
#endif

#if ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL))
#if (DEM_ENABLE_ASR43_SERVICE_API == STD_OFF)
/** \brief Gets the data of an extended data record by event
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] RecordNumber  Identification of requested Extended data record.
 **                     Valid values are between 0x01 and 0xEF as defined in.
 **                     ISO14229-1. 0xFF means data of all extended data records
 **                     are returned
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **                     to the buffer, to which the extended data shall be
 **                     written to. The format is raw hexadecimal values and
 **                     contains no header-information.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_GetEventExtendedDataRecord}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventExtendedDataRecord(
  Dem_EventIdType                        EventId,
  uint8                                  RecordNumber,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) DestBuffer);
#endif /* (DEM_ENABLE_ASR43_SERVICE_API == STD_OFF) */

/** \brief Gets the event memory overflow indication status.
 **
 ** \param[in] DTCOrigin  If the Dem supports more than one event
 **                     memory this parameter is used to select
 **                     the source memory the overflow indication
 **                     shall be read from.
 ** \param[out] OverflowIndication  This parameter returns TRUE if the
 **                     respective event memory was overflowed, otherwise it
 **                     returns FALSE
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed or is not supported
 **
 ** \ServiceID{::DEM_SID_GetEventMemoryOverflow}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventMemoryOverflow(
  Dem_DTCOriginType                        DTCOrigin,
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) OverflowIndication);

/** \brief Gets the number of entries currently stored in the event memory.
 **
 ** \param[in] DTCOrigin   If the Dem supports more than one event
 **                        memory this parameter is used to select
 **                        the source memory the number of entries
 **                        shall be read from.
 ** \param[out] NumberOfEventMemoryEntries   This parameter returns
 **                        the number of entries currently stored
 **                        in the requested event memory.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed or is not supported
 **
 ** \ServiceID{::DEM_SID_GetNumberOfEventMemoryEntries}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO SWS_Dem_00652,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetNumberOfEventMemoryEntries(
  Dem_DTCOriginType                      DTCOrigin,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) NumberOfEventMemoryEntries);

#if (DEM_SUPPRESSION_SUPPORT == DEM_DTC_SUPPRESSION)
/** \brief Set the suppression status of a specific DTC.
 **
 ** This API shall be used to suppress the external reporting
 ** (e.g. DTC number, UDS status, DTC extended data records,
 ** DTC statistical data,...) of a DTC.
 **
 ** \param[in] DTC  Diagnostic Trouble Code
 ** \param[in] DTCFormat  Defines the input-format of the provided DTC value.
 ** \param[in] SuppressionStatus  This parameter specifies whether
 **                     the respective DTC shall be disabled (TRUE)
 **                     or enabled (FALSE).
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed or event entry for this DTC still exists
 **
 ** \ServiceID{::DEM_SID_SetDTCSuppression}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem586,1 */
/* !LINKSTO Dem589,2 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetDTCSuppression(
  uint32            DTC,
  Dem_DTCFormatType DTCFormat,
  boolean           SuppressionStatus);
#endif /* (DEM_SUPPRESSION_SUPPORT == DEM_DTC_SUPPRESSION) */

/* !LINKSTO Dem_OBD_0001,2 */
#if (DEM_OBD_Support == STD_ON)
/** \brief Service for reporting the Event as disabled to the Dem for the PID
 ** $41 computation
 **
 ** \param[in] EventId  Identification of an Event by assigned EventId.
 **
 ** \return success of operation
 ** \retval E_OK     set of event to disabled was successful
 ** \retval E_NOT_OK set of event disabled failed
 **
 ** \ServiceID{::DEM_SID_SetEventDisabled}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem312,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetEventDisabled(
  Dem_EventIdType EventId);

/** \brief Marks the current OBD driving cycle as having met the criteria
 **        for the PFC cycle. API is needed in OBD-relevant ECUs
 **        only.
 **
 ** \return success of operation
 ** \retval E_OK      always E_OK is returned
 ** \retval E_NOT_OK  E_NOT_OK will never appear
 **
 ** \ServiceID{::DEM_SID_SetPfcCycleQualified}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetPfcCycleQualified(void);

/** \brief Returns TRUE if the criteria for the PFC cycle have been
 **        met during the current OBD driving cycle.
 **        API is needed in OBD-relevant ECUs only.
 **
 ** \param[out] isqualified TRUE: During the current OBD driving cycle the criteria
 **                         for the PFC cycle have been met. FALSE: During
 **                         the current OBD driving cycle the criteria for the
 **                         PFC cycle have not been met or permanent memory
 **                         is not defined.
 ** \return success of operation
 ** \retval E_OK      always E_OK is returned
 ** \retval E_NOT_OK  E_NOT_OK will never appear
 **
 ** \ServiceID{::DEM_SID_GetPfcCycleQualified}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetPfcCycleQualified(
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) isqualified);

/** \brief Sets the TNCSLC bit for all not confirmed (CDTC==0) and not pending (PDTC==0) events
 *         assigned to any ReadinessGroup reported by PID$01.
 **
 ** \return none
 **
 ** \ServiceID{::DEM_SID_ResetReadiness}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO VCC_DEM_007_Req196v1,1 */
extern FUNC(void, DEM_CODE) Dem_ResetReadiness(void);
#endif /* #if (DEM_OBD_Support == STD_ON) */

/* !LINKSTO SWS_Dem_01080,1 */
#if (DEM_AVAILABILITY_SUPPORT == DEM_EVENT_AVAILABILITY)
/** \brief Set the available status of a specific event.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] AvailableStatus  Specifies whether the respective event shall
                        be disabled (FALSE) or enabled (TRUE).
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed or change of available status not accepted
 **
 ** \ServiceID{::DEM_SID_SetEventAvailable}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO SWS_Dem_01080,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetEventAvailable(
  Dem_EventIdType EventId,
  boolean         AvailableStatus);
#endif /* (DEM_AVAILABILITY_SUPPORT == DEM_EVENT_AVAILABILITY) */

#endif /* ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL)) */

#if ((DEM_INCLUDE_RTE == STD_OFF) || (DEM_OBD_Support == STD_OFF) || \
     (!defined DEM_INTERNAL))

/** \brief Service to set the status of the PTO
 **
 ** Note: Functionality not implemented, only stub available.
 ** \param[in] PtoStatus  sets the status of the PTO (TRUE == active,
 **              FALSE == inactive)
 **
 ** \return success of operation
 ** \retval E_OK   new PTO status has been adopted by Dem
 ** \retval E_NOT_OK  new PTO status has not been adopted by Dem
 **
 ** \ServiceID{::DEM_SID_SetPtoStatus}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetPtoStatus(boolean PtoStatus);
#endif /* ((DEM_INCLUDE_RTE == STD_OFF) || (DEM_OBD_Support == STD_OFF) ||
          (!defined DEM_INTERNAL)) */

#if (DEM_INCLUDE_RTE == STD_ON)
#define Dem_STOP_SEC_CODE
#else
#define DEM_STOP_SEC_CODE
#endif
#include <Dem_MemMap.h>

#define DEM_START_SEC_CODE
#include <Dem_MemMap.h>

/*------------------[Interface Dcm <--> Dem]--------------------------------*/

/* --- Access DTCs and Status Information --- */

/** \brief Allows filtering for DTCs with severity information.
 **
 ** This API shall be used for the API's
 ** Dem_GetNextFilteredDTC(), Dem_GetNextFilteredDTCAndFDC() and
 ** Dem_GetNextFilteredDTCAndSeverity().
 ** The function resets the internal counter to the first event that
 ** matches the filter settings. The filter mask attributes are used until
 ** the next call of Dem_SetDTCFilter or Dem_Init().
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId   Unique client ID, assigned to the instance of the
 **                       calling module
 ** \param[in] DTCStatusMask  Status-byte mask for DTC status-byte filtering
 **                       Values:
 **                       0x00: Autosar-specific value to deactivate the
 **                       status-byte filtering (different meaning than in
 **                       ISO 14229-1) to report all supported DTCs (used for
 **                       service 0x19 subfunctions 0x0A/0x15)
 **                       0x01...0xFF: Status-byte mask according to
 **                       ISO 14229-1 DTCStatusMask (handed over by Dcm from
 **                       service request directly) to filter for DTCs with
 **                       at least one status bit set matching this
 **                       status-byte mask
 ** \param[in] DTCFormat  Defines the output-format of the requested DTC
 **                       values for the sub-sequent API calls
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory, this
 **                       parameter is used to select the source memory the
 **                       DTCs shall be read from.
 ** \param[in] FilterWithSeverity  This flag defines whether severity
 **                       information (ref. to parameter below) shall be used
 **                       for filtering. This is to allow for coexistence of
 **                       DTCs with and without severity information.
 **                       - TRUE Severity information is a filter criteria
 **                       - FALSE Severity information is not a filter criteria
 ** \param[in] DTCSeverityMask  This parameter contains the DTCSeverityMask
 **                       according to ISO14229-1.
 ** \param[in] FilterForFaultDetectionCounter  This flag defines whether
 **                       Fault Detection Counter(FDC) information shall be
 **                       used for filtering. This is to allow for coexistence
 **                       of DTCs with and without FDC information.
 **                       If FDC information is a filter criteria, only those
 **                       DTCs with a FDC value between 1 and 0x7E shall be
 **                       reported.
 **                       - TRUE  FDC information is a filter criteria
 **                       - FALSE FDC information is not a filter criteria
 **
 ** Remark: If the event does not uses the debouncing inside Dem, then the
 ** Dem must request this information via Xxx_DemGetFaultDetectionCounter.
 **
 ** \return Status of the operation to (re-)set a DTC filter
 ** \retval E_OK Indicates that the filter was successfully set
 ** \retval E_NOT_OK Indicates a wrong DTCOrigin or DTCFormat
 **
 ** \ServiceID{::DEM_SID_SetDTCFilter}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetDTCFilter(
  uint8                      ClientId,
  uint8                      DTCStatusMask,
  Dem_DTCFormatType          DTCFormat,
  Dem_DTCOriginType          DTCOrigin,
  boolean                    FilterWithSeverity,
  Dem_DTCSeverityType        DTCSeverityMask,
  boolean                    FilterForFaultDetectionCounter);

/** \brief Sets a freeze frame record filter
 **
 ** The filtered freeze frame records can be retrieved by the function
 ** Dem_GetNextFilteredRecord(). This filter always belongs to primary memory.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId   Unique client ID, assigned to the instance of the
 **                       calling module.
 ** \param[in] DTCFormat  Defines the output-format of the requested DTC values.
 **
 ** \param[out] NumberOfFilteredRecords  Number of freeze frame records
 **                                      currently stored in the event memory.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK Filter is accepted.
 ** \retval E_NOT_OK Wrong filter selected.
 **
 ** \ServiceID{::DEM_SID_SetFreezeFrameRecordFilter}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_00209,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetFreezeFrameRecordFilter(
  uint8                                   ClientId,
  Dem_DTCFormatType                       DTCFormat,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) NumberOfFilteredRecords);

/** \brief Gets the status of a DTC
 **
 ** The DTCs of OBD Events Suppression shall be reported as DEM_WRONG_DTC.
 **
 ** This API shall be used to read the status of a DTC to the parameter
 ** DTCStatus according to ISO14229.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in]  ClientId  Unique client ID, assigned to the instance of the
 **                     calling module
 ** \param[out] DTCStatus  This parameter receives the status information of
 **                     the requested DTC. It follows the format as defined
 **                     in ISO14229-1. If the return value of the function
 **                     call is other than E_OK, this parameter does not
 **                     contain valid data.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK Status of the DTC is correctly provided in the DTCStatus parameter
 ** \retval E_NOT_OK No DTC selected
 ** \retval DEM_WRONG_DTC Selected DTC value in selected format does not exist
 ** \retval DEM_WRONG_DTCORIGIN Selected DTCOrigin does not exist
 **
 ** \ServiceID{::DEM_SID_GetStatusOfDTC}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.GetStatusOfDTC,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetStatusOfDTC(
  uint8                                                  ClientId,
  P2VAR(Dem_DTCStatusMaskType, AUTOMATIC, DEM_APPL_DATA) DTCStatus);

/** \brief Gets the DTC Status availability mask
 **
 ** The API shall be used to get the DTC status availability mask, i.e.
 ** the DTC status information (according to ISO14229) supported by the Dem.
 **
 ** Only supported bits can be used as filter parameters in the API
 ** Dem_SetDTCFilter().
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId client ID for which the status availability mask
 **                     will be retrieved.
 ** \param[out] DTCStatusMask  The value from type ::Dem_DTCStatusMaskType
 **                   indicates the supported DTC status bits from the Dem.
 **                   All supported information is indicated by setting the
 **                   corresponding status bit to 1.
 **
 ** \return success of operation
 ** \retval E_OK     get of DTC status availability mask was successful
 ** \retval E_NOT_OK get of DTC status availability mask failed
 **
 ** \ServiceID{::DEM_SID_GetDTCStatusAvailabilityMask}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetDTCStatusAvailabilityMask(
  uint8 ClientId,
  P2VAR(Dem_UdsStatusByteType, AUTOMATIC, DEM_APPL_DATA) DTCStatusMask);

/** \brief Gets the number of a filtered DTC
 **
 ** The API shall be used to get the number of DTCs matching the defined status
 ** mask. The DTC Status mask filter is set by the API Dem_SetDTCFilter().
 **
 ** Caveats: DTC filter has been set up properly before function call
 ** (Dem_SetDTCFilter).
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId client ID for which the number of filtered DTCs
 **                     will be retrieved.
 ** \param[out] NumberOfFilteredDTC  The number of DTCs matching the defined
 **                                  status mask.
 **
 ** \return Status of the operation to retrieve a number of DTC from the Dem.
 **         The value ::DEM_PENDING is never returned (because of synchronous
 **         behavior).
 ** \retval E_OK      Getting number of filtered DTCs was successful
 ** \retval E_NOT_OK  No DTC filter set
 **
 ** \ServiceID{::DEM_SID_GetNumberOfFilteredDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Asynchronous}
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_00061,1 */
extern FUNC(Std_ReturnType , DEM_CODE)
  Dem_GetNumberOfFilteredDTC(
    uint8 ClientId,
    P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) NumberOfFilteredDTC);

/** \brief Gets the next filtered DTC
 **
 ** The API shall be used to return the current DTC and its associated status
 ** from the Dem matching the filter criteria defined by the API call
 ** Dem_SetDTCFilter(). After having returned the data the function skips to the
 ** next DTC matching the filter criteria.
 **
 ** To receive all DTCs matching the filter criteria this function shall
 ** called continuously until the return value of the function is
 ** "NoMatchingDTC".
 **
 ** The chronological order shall be reported if the DTC status mask parameter
 ** is set to "pending" and/or "confirmed" (no other status bits are allowed
 ** to be set). The function shall start with the most recent DTC. The
 ** chronological order may vary with the customer specific attributes used by
 ** the algorithm for sorting the DTC records (e.g. pre-sorted records or
 ** time-stamp attributes of the records).
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId client ID for which the next filtered DTC will be
 **                     retrieved.
 ** \param[out] DTC  Receives the DTC value in respective format of the filter
 **                  returned by this function. If the return value of the
 **                  function is other than E_OK this parameter
 **                  does not contain valid data
 ** \param[out] DTCStatus  This parameter receives the status information of
 **                  the requested DTC. If the return value of the function
 **                  call is other than OK this parameter does not contain
 **                  valid data.
 **
 ** \return Status of the operation to retrieve a DTC from the Dem.
 **                  The value DEM_PENDING is never returned (because
 **                  of synchronous behavior).
 ** \retval E_OK                 Returned next filtered element
 ** \retval E_NOT_OK             No DTC filter set
 ** \retval DEM_NO_SUCH_ELEMENT  No further element matching the filter criteria
 **                              found.
 **
 ** \ServiceID{::DEM_SID_GetNextFilteredDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_00215,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetNextFilteredDTC(
  uint8                                                  ClientId,
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA)                DTC,
  P2VAR(Dem_DTCStatusMaskType, AUTOMATIC, DEM_APPL_DATA) DTCStatus);

#if (DEM_GET_DTCBYOCCURRENCETIME_SUPPORT == STD_ON)
/** \brief Gets the DTC by occurrence time
 **
 ** The API provides the capability to access specific events stored in the
 ** primary memory at certain important points in time. The API call will
 ** return one DTC according to the ::Dem_DTCRequestType.
 **
 ** \param[in] ClientId    Unique client ID, assigned to the instance of the
 **                        calling module.
 ** \param[in] DTCRequest  This parameter defines the request type of the DTC.
 ** \param[out] DTC        Receives the DTC value in UDS format returned by
 **                        the function. If the return value of the function
 **                        is other than E_OK, this parameter does not contain
 **                        valid data.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK                The call was successful and the parameter DTC
 **                             contains the requested element.
 ** \retval E_NOT_OK            A development error was detected.
 ** \retval DEM_NO_SUCH_ELEMENT The requested element is not stored.
 **
 ** \ServiceID{::DEM_SID_GetDTCByOccurrenceTime}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 **
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_00218,1 */
extern FUNC(Std_ReturnType, DEM_CODE)
  Dem_GetDTCByOccurrenceTime(
    uint8                                        ClientId,
    Dem_DTCRequestType                           DTCRequest,
    P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA)      DTC);
#endif

/** \brief Gets the next freeze frame record number and its associated DTC
 ** stored in the event memory.
 **
 ** The API shall be used to get the next freeze frame record
 ** number and its associated DTC stored in the event memory. After having
 ** returned the data the function skips to the next record matching the filter
 ** criteria. To receive all records matching the filter criteria this function
 ** shall called continuously until the return value of the function is
 ** "DEM_NO_SUCH_ELEMENT".
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId   Unique client ID, assigned to the instance of the
 **                       calling module.
 ** \param[out] DTC  Receives the DTC value in respective format of the filter
 **                  returned by this function. If the return value of the
 **                  function is other than E_OK this parameter
 **                  does not contain valid data.
 ** \param[out] RecordNumber  Freeze frame record number of the reported DTC
 **                  (relative addressing). If the return value of the
 **                  function is other than E_OK this
 **                  parameter does not contain valid data.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK                Returned next filtered element.
 ** \retval E_NOT_OK            Indicates a development error.
 ** \retval DEM_NO_SUCH_ELEMENT No further element
 *                              (matching the filter criteria) found
 **
 ** \ServiceID{::DEM_SID_GetNextFilteredRecord}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.GetNextFilteredRecord,1 */
extern FUNC(Std_ReturnType, DEM_CODE)
  Dem_GetNextFilteredRecord(
    uint8                                   ClientId,
    P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA) DTC,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  RecordNumber);

/** \brief returns next filtered fault detection counter
 **
 ** The API shall be used to return the current DTC and its associated Fault
 ** Detection Counter (FDC)from the Dem, matching the filter criteria defined
 ** by the API call Dem_SetDTCFilter. After having returned the data the
 ** function skips to the next DTC matching the filter criteria.
 ** To receive all DTCs matching the filter criteria this function shall be
 ** called continuously until the return value of the function is
 ** "NoMatchingDTC".The interface has an asynchronous behavior,
 ** because the FDC might be received asynchronously from a SW-C, too.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId client ID for which the next filtered DTC and FDC
 **                     will be retrieved.
 ** \param[out] DTC  Receives the DTC value in respective format of the filter
 **                  returned by this function. If the return value of the
 **                  function is other than E_OK this parameter
 **                  does not contain valid data.
 ** \param[out] DTCFaultDetectionCounter  This parameter receives the Fault
 **                  Detection Counter information of the requested DTC. If the
 **                  return value of the function call is other than OK this
 **                  parameter does not contain valid data.
 **
 ** \return Status of the operation to retrieve a DTC from the Dem.
 **         The value ::DEM_PENDING is never returned (because of synchronous
 **         behavior).
 ** \retval E_OK                 Returned next filtered element
 ** \retval E_NOT_OK             No DTC filter set
 ** \retval DEM_NO_SUCH_ELEMENT  No further element matching the filter criteria
 **                              found.
 **
 ** \ServiceID{::DEM_SID_GetNextFilteredDTCAndFDC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Asynchronous}
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_00227,1 */
extern FUNC(Std_ReturnType, DEM_CODE)
  Dem_GetNextFilteredDTCAndFDC(
    uint8                                   ClientId,
    P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA) DTC,
    P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  DTCFaultDetectionCounter);

/** \brief Gets the current DTC and its Severity from the Dem
 **
 ** The API shall return the current DTC and its associated Fault Severity
 ** from the Dem, matching the filter criteria defined by the function call
 ** Dem_SetDTCFilter().
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId client ID for which the next filtered DTC and Severity
 **                     will be retrieved.
 ** \param[out] DTC  Receives the DTC value in respective format of the filter
 **                  returned by this function. If the return value of the
 **                  function is other than E_OK this parameter
 **                  does not contain valid data.
 ** \param[out] DTCStatus  Receives the status value returned by the function.
 **                  If the return value is other than ::E_OK this
 **                  parameter does not contain valid data.
 ** \param[out] DTCSeverity  Receives the severity value returned by the function.
 **                  If the return value is other than ::E_OK this
 **                  parameter does not contain valid data.
 ** \param[out] DTCFunctionalUnit  Receives the functional unit value returned by the
 **                  function. If the return value is other than ::E_OK this
 **                  parameter does not contain valid data.
 **
 ** \return Status of the operation to retrieve a DTC from the Dem.
 **                  The value DEM_PENDING is never returned (because
 **                  of synchronous behavior).
 ** \retval E_OK                 Returned next filtered element
 ** \retval E_NOT_OK             No DTC filter set
 ** \retval DEM_NO_SUCH_ELEMENT  No further element matching the filter criteria
 **                              found.
 **
 ** \ServiceID{::DEM_SID_GetNextFilteredDTCAndSeverity}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_00281,1 */
extern FUNC(Std_ReturnType, DEM_CODE)
  Dem_GetNextFilteredDTCAndSeverity(
    uint8                                                ClientId,
    P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA)              DTC,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)               DTCStatus,
    P2VAR(Dem_DTCSeverityType, AUTOMATIC, DEM_APPL_DATA) DTCSeverity,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)               DTCFunctionalUnit);

/** \brief Gets the supported DTC formats of the ECU
 **
 ** The supported formats are configured via DemTypeOfDTCSupported.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId client ID for which the translation type will be
 **                     retrieved.
 ** \return The Translation format provides the configured translation formats
 **                 according to ISO 14229-1 service 0x19
 **
 ** \ServiceID{::DEM_SID_GetTranslationType}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_DTCTranslationFormatType, DEM_CODE)
  Dem_GetTranslationType(uint8 ClientId);

/** \brief Gets the severity of the selected DTC
 **
 ** This API returns the severity of a DTC configured via DemDTCSeverity.
 ** The target DTC whose severity is required must be selected first by
 ** calling Dem_SelectDTC().
 **
 ** \param[in] ClientId      Unique client ID, assigned to the instance of the
 **                          calling module.
 ** \param[out] DTCSeverity  This parameter contains the DTCSeverityMask
 **                          according to ISO14229-1.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK                 The DTC severity is correctly provided in the
 **                              DTCSeverity parameter.
 ** \retval E_NOT_OK             A development error was detected.
 ** \retval DEM_WRONG_DTC        Dem_SelectDTC() was called to select a
 **                              DTC group or a single DTC in OBD format or
 **                              no DTC matching the DTC selection criteria
 **                              could be found.
 ** \retval DEM_WRONG_DTCORIGIN  Selected DTCOrigin does not exist.
 **
 ** \ServiceID{::DEM_SID_GetSeverityOfDTC}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.GetSeverityOfDTC,1 */
extern FUNC(Std_ReturnType, DEM_CODE)
  Dem_GetSeverityOfDTC(
    uint8                                                ClientId,
    P2VAR(Dem_DTCSeverityType, AUTOMATIC, DEM_APPL_DATA) DTCSeverity);

/** \brief Gets the functional unit of the selected DTC
 **
 ** This API returns the functional unit of a DTC configured via
 ** DemDTCFunctionalUnit. The target DTC whose functional unit is required
 ** must be selected first by calling Dem_SelectDTC().
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId            Unique client ID, assigned to the instance
 **                                of the calling module.
 ** \param[out] DTCFunctionalUnit  This parameter contains the Functional unit
 **                                value of the DTC
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK                 The DTC functional unit is correctly provided
 **                              in the DTCFunctionalUnit parameter
 ** \retval E_NOT_OK             A development error was detected.
 ** \retval DEM_WRONG_DTC        Dem_SelectDTC() was called to select a
 **                              DTC group or a single DTC in OBD format or
 **                              no DTC matching the DTC selection criteria
 **                              could be found.
 **
 ** \retval DEM_WRONG_DTCORIGIN  Selected DTCOrigin does not exist.
 **
 ** \ServiceID{::DEM_SID_GetFunctionalUnitOfDTC}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.GetFunctionalUnitOfDTC,1 */
extern FUNC(Std_ReturnType, DEM_CODE)
  Dem_GetFunctionalUnitOfDTC(
    uint8                                  ClientId,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) DTCFunctionalUnit);

/* --- Access extended data records and freeze frame data --- */

/** \brief Disables the event memory update of a specific DTC (only one at
 ** one time)
 **
 ** This function shall be used if the freeze frame or extended data record
 ** are about to be accessed by subsequent API-calls. It is done to ensure
 ** that the data contained in this record is not changed while the freeze
 ** frame or extended data record are accessed by the external application,
 ** e.g. Dcm.
 **
 ** This function shall protect the event related data of the specified DTC
 ** within the specified origin from updating or deleting, to allow a
 ** consistent read for the following subsequent API-calls:
 ** Dem_SelectExtendedDataRecord(), Dem_GetSizeOfExtendedDataRecordSelection(),
 ** Dem_GetNextExtendedDataRecord(), Dem_SelectFreezeFrameData(),
 ** Dem_GetSizeOfFreezeFrameSelection() and Dem_GetNextFreezeFrameData().
 **
 ** New and other events including their associated freeze frames and extended
 ** data records can still be added to and changed in the event memory as long
 ** as space is available. Event related data might still be updated in
 ** background (e.g. Dem-internal data elements).
 **
 ** DTC status information update is not affected by this function.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId  Unique client ID, assigned to the instance of the
 **                      calling module.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK                 Event memory update successfully disabled.
 ** \retval E_NOT_OK             Failed to disable DTC record update.
 ** \retval DEM_WRONG_DTC        Selected DTC value in selected format does not
 **                              exist or a group of DTC was selected.
 ** \retval DEM_WRONG_DTCORIGIN  Selected DTCOrigin does not exist.
 **
 ** \ServiceID{::DEM_SID_DisableDTCRecordUpdate}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.DisableDTCRecordUpdate,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DisableDTCRecordUpdate(uint8 ClientId);

/** \brief Enables the event memory update of the DTC disabled by
 ** Dem_DisableDTCRecordUpdate() before
 **
 ** The function Dem_EnableDTCRecordUpdate is the counterpart to the function
 ** Dem_DisableDTCRecordUpdate(). It enables the event memory update of the DTC
 ** disabled by Dem_DisableDTCRecordUpdate() before. It shall be called after
 ** the freeze frame and extended data record were protected by the function
 ** Dem_DisableDTCRecordUpdate(), after the access by subsequent API-calls is
 ** finished.
 **
 ** It is called to release the currently disabled DTC which has been
 ** protected by the function Dem_DisableDTCRecordUpdate(), so that the data can
 ** be updated again.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK      Event memory update successfully enabled.
 ** \retval E_NOT_OK  Failed to enable DTC record update.
 **
 ** \ServiceID{::DEM_SID_EnableDTCRecordUpdate}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.EnableDTCRecordUpdate,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_EnableDTCRecordUpdate(uint8 ClientId);

/** \brief Triggers the Dem internal Freeze Frame selection process on the
 ** event memory assigned to the ClientId
 **
 ** This API sets the filter to be used by Dem_GetNextFreezeFrameData() and
 ** Dem_GetSizeOfFreezeFrameSelection(). The target DTC whose freeze frame
 ** is to be read must be selected first by calling Dem_SelectDTC().
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId     Unique client ID, assigned to the instance of the
 **                         calling module.
 ** \param[in] RecordNumber Unique identifier for a snapshot record as defined
 **                         in ISO 14229-1. The value 0xFF is a placeholder
 **                         referencing all snapshot records of the addressed
 **                         DTC. The value 0x00 indicates the DTC-specific
 **                         WWHOBD snapshot record.
 **
 ** \return Status of the operation to select the freeze frame record
 **         for the given client.
 ** \retval E_OK                Freeze frame data successfully selected.
 ** \retval DEM_WRONG_DTC       Dem_SelectDTC() was called to select a DTC
 **                             group or a single DTC in OBD format or no DTC
 **                             matching the DTC selection criteria was found.
 ** \retval DEM_WRONG_DTCORIGIN Selected DTCOrigin does not exist.
 ** \retval E_NOT_OK            A development error was detected.
 **
 ** \ServiceID{::DEM_SID_SelectFreezeFrameData}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.SelectFreezeFrameData,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SelectFreezeFrameData(
  uint8 ClientId,
  uint8 RecordNumber);

/** \brief Triggers the Dem internal Extended Data Record selection process
 ** on the event memory assigned to the ClientId
 **
 ** This API sets the filter to be used by Dem_GetNextExtendedDataRecord() and
 ** Dem_GetSizeOfExtendedDataRecordSelection(). The target DTC whose extended
 ** data record is to be read must be selected first by calling
 ** Dem_SelectDTC().
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId            Unique client ID, assigned to the instance
 **                                of the calling module.
 ** \param[in] ExtendedDataNumber  Identification/Number of requested extended
 **                                data record. Additionally the values 0xFE
 **                                and 0xFF are explicitly allowed to request
 **                                the overall size of all OBD records / all
 **                                records.
 **
 ** \return Status of the operation to select the extended data record
 **         for the given client.
 ** \retval E_OK                   Extended data record successfully selected.
 ** \retval E_NOT_OK               A development error was detected.
 ** \retval DEM_WRONG_DTC          Dem_SelectDTC() was called to select a DTC
 **                                group or a single DTC in OBD format or no
 **                                DTC matching the DTC selection criteria was
 **                                found.
 ** \retval DEM_WRONG_DTCORIGIN    Selected DTCOrigin does not exist.
 **
 ** \ServiceID{::DEM_SID_SelectExtendedDataRecord}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.SelectExtendedDataRecord,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SelectExtendedDataRecord(
  uint8 ClientId,
  uint8 ExtendedDataNumber);

/** \brief Gets the data of the selected freeze frame record
 **
 ** This API copies the data of the (next) freeze frame record selected by
 ** Dem_SelectFreezeFrameData() to the provided destination buffer.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in]  ClientId    Unique client ID, assigned to the instance
 **                         of the calling module.
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **                         to the buffer to which the freeze frame data shall
 **                         be written. The format is: {RecordNumber,
 **                         NumOfDIDs, DID[1], data[1], ..., DID[N], data[N]}.
 ** \param[in,out] BufSize  When the function is called, this parameter
 **                         contains the maximum number of data bytes that can
 **                         be written to the buffer.
 **                         The function returns the actual number of written
 **                         data bytes in this parameter.
 **
 ** \return Status of the operation of type
 **         ::Std_ReturnType
 ** \retval E_OK                 Size and buffer successfully returned.
 ** \retval DEM_BUFFER_TOO_SMALL Provided buffer size too small.
 ** \retval E_NOT_OK             Selection function is not called or
 **                              a development error is detected.
 ** \retval DEM_NO_SUCH_ELEMENT  Found no (further) element matching the
 **                              filter criteria.
 **
 ** \ServiceID{::DEM_SID_GetNextFreezeFrameData}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.GetNextFreezeFrameData,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetNextFreezeFrameData(
  uint8                                   ClientId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) BufSize);

/** \brief Gets the size of the selected freeze frame record(s)
 **
 ** The API returns the size of the freeze frame record(s) selected by
 ** Dem_SelectFreezeFrameData(). This size includes the number of user data
 ** bytes (pure freeze frame data) as well as the number of bytes in the
 ** header (record number, number of DIDs and the individual DIDs).
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId            Unique client ID, assigned to the instance
 **                                of the calling module.
 ** \param[out] SizeOfFreezeFrame  Number of bytes in the requested freeze
 **                                frame.
 **
 ** \return Status of the operation of type
 **              ::Std_ReturnType
 ** \retval E_OK                Size returned successfully.
 ** \retval E_NOT_OK            Selection function is not called or a
 **                             development error is detected.
 ** \retval DEM_NO_SUCH_ELEMENT Record number is not supported by
 **                             configuration and therefore invalid.
 **
 ** \ServiceID{::DEM_SID_GetSizeOfFreezeFrameSelection}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.GetSizeOfFreezeFrameSelection,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetSizeOfFreezeFrameSelection(
  uint8                                   ClientId,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) SizeOfFreezeFrame);

/** \brief Gets the data of the selected extended data record
 **
 ** The API copies the data of the (next) extended data record selected by
 ** Dem_SelectExtendedDataRecord() to the provided destination buffer.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId     Unique client ID, assigned to the instance of
 **                         the calling module.
 ** \param[out] DestBuffer  This parameter contains a byte pointer that
 **                         points to the buffer, to which the extended
 **                         data record shall be written.
 **                         The format is: {ExtendedDataRecordNumber,
 **                         data[0], data[1], ..., data[n]}
 ** \param[in,out] BufSize  When the function is called, this parameter
 **                         contains the maximum number of data bytes that
 **                         can be written to the buffer. The function
 **                         returns the actual number of written data bytes
 **                         in this parameter.
 **
 ** \return Status of the operation to retrieve extended data by DTC.
 ** \retval E_OK                  Size returned successfully.
 ** \retval E_NOT_OK              Selection function is not called or a
 **                               development error is detected.
 ** \retval DEM_BUFFER_TOO_SMALL  Provided buffer size too small.
 ** \retval DEM_NO_SUCH_ELEMENT   Found no (further) element matching the
 **                               filter criteria.
 **
 ** \ServiceID{::DEM_SID_GetNextExtendedDataRecord}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.GetNextExtendedDataRecord,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetNextExtendedDataRecord(
  uint8                                   ClientId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) BufSize);

/** \brief Gets the size of the selected extended data record(s)
 **
 ** The API returns the size of the extended data record(s) selected by
 ** Dem_SelectExtendedDataRecord(), which represents the number of user data
 ** bytes stored in the extended data record, including any extended data
 ** record header information i.e. the extended data record number.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId                   Unique client ID, assigned to the
 **                                       instance of the calling module.
 ** \param[out] SizeOfExtendedDataRecord  Size of the requested extended data
 **                                       record(s) including record number.
 **                                       The format for a single
 **                                       ExtendedDataRecord is:
 **                                       {RecordNumber, data[1], ...,data[N]}
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK                Size returned successfully.
 ** \retval E_NOT_OK            Selection function is not called or a
 **                             development error is detected.
 ** \retval DEM_NO_SUCH_ELEMENT Record number is not supported by
 **                             configuration and therefore invalid.
 **
 ** \ServiceID{::DEM_SID_GetSizeOfExtendedDataRecordSelection}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.GetSizeOfExtendedDataRecordSelection,1 */
extern FUNC(Std_ReturnType, DEM_CODE)
  Dem_GetSizeOfExtendedDataRecordSelection(
    uint8                                   ClientId,
    P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) SizeOfExtendedDataRecord);

/* --- Clear DTC information --- */

/** \brief Clears single DTCs as well as groups of DTCs
 **
 ** It shall be used to clear:
 ** - all the event status related to the specified DTC
 ** - all associated event memory entries for these events (extended data
 **   and/or freeze frame data, etc.)
 **
 ** \param[in] ClientId   Unique client id, assigned to the instance of the
 **                       calling module.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK                    DTC successfully cleared.
 ** \retval E_NOT_OK                No DTC selected.
 ** \retval DEM_WRONG_DTC           Selected DTC value in selected format does
 **                                 not exist or clearing is limited to group
 **                                 of all DTCs only.
 ** \retval DEM_WRONG_DTCORIGIN     Selected DTCOrigin does not exist or DTC
 **                                 clearing is prohibited.
 ** \retval DEM_CLEAR_FAILED        DTC clearing failed.
 ** \retval DEM_CLEAR_BUSY          Another client is currently clearing DTCs.
 **                                 The requested operation will not be
 **                                 started and the caller shall try again at
 **                                 a later moment.
 ** \retval DEM_CLEAR_MEMORY_ERROR  An error occurred during erasing a memory
 **                                 location (e.g. if DemClearDTCBehavior is
 **                                 set to DEM_CLRRESP_NON-VOLATILE_FINISH and
 **                                 erasing of non-volatile-block failed).
 ** \retval DEM_PENDING             Clearing the DTCs is currently in
 **                                 progress. The caller shall call this
 **                                 function again at a later moment.
 **
 ** \ServiceID{::DEM_SID_ClearDTC}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Asynchronous}
 **
 */
/* !LINKSTO Dem.ASR431.ClearDTC,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_ClearDTC(
  uint8 ClientId);

/* --- Control DTC setting --- */

/** \brief Disables the storage and the update of UDS status bytes of all DTCs
 **
 ** This function shall be called to disable DTC setting for all DTCs.
 **
 ** This is only for preventing DTCs from being stored in case of an induced
 ** failure situations in a system, e.g. during flash-reprogramming of one ECU
 ** in a network. In that case all the ECU's are commanded via diagnostic
 ** request (linked to the above diagnostic request) to suppress storage of a
 ** DTC while maintaining correct fail-safe behavior as the flashed ECU is not
 ** participating in the normal communication anymore. If one of the other
 ** networked ECUs needs one of the signals which are now missing, this will
 ** lead to a failsafe-reaction of the ECU (as per the AUTOSAR concept the
 ** fail-safe reaction of an ECU is triggered by certain event-status updates
 ** or a FiM-command which is itself triggered by an event-status update).
 **
 ** Note: This API must only be used by the Dcm module!
 **
 ** Note: This API can be used only by one client ID at a time.
 ** \param[in] ClientId   Unique client ID, assigned to the instance of the
 **                       calling module.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK      The operation was successful
 ** \retval E_NOT_OK  On development error or if DTC setting was already
 **                   disabled by a different client
 **
 ** \ServiceID{::DEM_SID_DisableDTCSetting}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.ControlDTCSetting.DisableDTCSetting,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DisableDTCSetting(uint8 ClientId);

/** \brief (Re)-Enables the storage and the update of UDS status bytes
 ** of all DTCs
 **
 ** This function shall be called to enable the DTC setting for all DTCs.
 ** See also Dem_DisableDTCSetting().
 **
 ** Note: This API must only be used by the Dcm module!
 **
 ** Note: This API can be used only by one client ID at a time.
 **
 ** Note: If configured, the InitMonitorForEvent callback functions are
 ** triggered asynchronously from Dem_MainFunction() when the DTC setting
 ** is re-enabled.
 ** \param[in] ClientId   Unique client ID, assigned to the instance of the
 **                       calling module.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK      The operation was successful
 ** \retval E_NOT_OK  On development error or if a different client was
 **                   responsible for disabling the DTC setting
 **
 ** \ServiceID{::DEM_SID_EnableDTCSetting}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.ControlDTCSetting.EnableDTCSetting,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_EnableDTCSetting(uint8 ClientId);

/*-------------------[Vendor specific APIs]---------------------------------*/

/** \brief Sets a filter for stored DTCs
 **
 ** This API shall be called before Dem_DcmGetNextFilteredStoredDTC().
 ** It sets the new filter criteria and resets the internal counter
 ** to the first event that matches the filter settings. The filter mask
 ** attributes are used until the next call of Dem_DcmSetStoredDTCFilter
 ** or Dem_Init(). This function shall not be called to interrupt
 ** a Dem_DcmGetNextFilteredStoredDTC() call sequence and change the filter
 ** criteria.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] ClientId   Unique client ID, assigned to the instance of the
 **                       calling module.
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory
 **                       this parameter is used to select the source memory
 **                       the DTCs shall be read from.
 ** \param[in] DataKind   DataKind selects only stored DTCs which contain the
 **                       requested data kind (freeze frame or extended data).
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK      Filter was successfully set
 ** \retval E_NOT_OK  Failed to set stored DTC filter
 **
 ** \ServiceID{::DEM_SID_SetStoredDTCFilter}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.Dem_DcmSetStoredDTCFilter.API,2 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmSetStoredDTCFilter(
  uint8             ClientId,
  Dem_DTCOriginType DTCOrigin,
  Dem_DataKindType  DataKind);

/** \brief Gets the next filtered stored DTC
 **
 ** The API shall return the stored DTC in event memory from the Dem,
 ** matching the filter criteria defined by the function
 ** call Dem_DcmSetStoredDTCFilter().
 **
 ** Note: This API must only be used by the Dcm module!
 **
 ** Note: The value ::DEM_PENDING is never returned, because of the
 **       implemented synchronous behavior.
 ** \param[in] ClientId   Unique client ID, assigned to the instance of the
 **                       calling module.
 ** \param[out] DTC       Receives the DTC value in UDS format returned by this
 **                       function. If the return value of the function is other
 **                       than ::E_OK this parameter does not contain
 **                       valid data.
 **
 ** \return Status of the operation of type ::Std_ReturnType
 ** \retval E_OK                 Returned next filtered element
 ** \retval E_NOT_OK             A development error was detected
 ** \retval DEM_NO_SUCH_ELEMENT  No further element matching the
 **                              filter criteria found
 **
 ** \ServiceID{::DEM_SID_GetNextFilteredStoredDTC}
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.Dem_DcmGetNextFilteredStoredDTC.API,2 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmGetNextFilteredStoredDTC(
    uint8                                   ClientId,
    P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA) DTC);

/*------------------[Interface Dlt <--> Dem]--------------------------------*/
/* Since the configuration parameter DemTriggerDltReports is always switched
 * off, the APIs Dem_DltGetMostRecentFreezeFrameRecordData() and
 * Dem_DltGetAllExtendedDataRecords() are currently not implemented.
 */

/*------------------[OBD-specific Interfaces]-------------------------------*/

#if ((DEM_IUMPR_FUNCTIONS_ENABLED == STD_ON) && (DEM_OBD_Support == STD_ON))
/** \brief Service for reporting that faults are possibly found because are all
 **  conditions are fulfilled.
 **
 ** Note: Functionality not implemented, only stub available.
 ** \param[in] RatioID Ratio Identifier reporting that a respective diagnostic
 **              function could have found a fault -only used when interface
 **              option "API" is selected.
 **
 ** \return success of operation
 ** \retval E_OK     report of IUMPR was successfully reported
 ** \retval E_NOT_OK report of IUMPR was not reported
 **
 ** \ServiceID{::DEM_SID_RepIUMPRFaultDetect}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_RepIUMPRFaultDetect(
  Dem_RatioIdType RatioID);

/** \brief Service to lock the denominator of a specific monitor.
 **
 ** Note: Functionality not implemented, only stub available.
 ** \param[in] RatioID Ratio Identifier reporting that specific denominator is
 **              locked (for physical reasons e.g. temperature conditions or
 **              minimum activity)
 **
 ** \return success of operation
 ** \retval E_OK     IUMPR denominator status was successfully reported
 ** \retval E_NOT_OK IUMPR denominator status was not successfully reported
 **
 ** \ServiceID{::DEM_SID_RepIUMPRDenLock}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_RepIUMPRDenLock(
  Dem_RatioIdType RatioID);

/** \brief Service to release the denominator of a specific monitor.
 **
 ** Note: Functionality not implemented, only stub available.
 ** \param[in] RatioID Ratio Identifier reporting that specific denominator is
 **              released (for physical reasons e.g. temperature conditions or
 **              minimum activity)
 **
 ** \return success of operation
 ** \retval E_OK     IUMPR denominator status was successfully reported
 ** \retval E_NOT_OK IUMPR denominator status was not successfully reported
 **
 ** \ServiceID{::DEM_SID_RepIUMPRDenRelease}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_RepIUMPRDenRelease(
  Dem_RatioIdType RatioID);
#endif /* (DEM_IUMPR_FUNCTIONS_ENABLED == STD_ON) && (DEM_OBD_Support == STD_ON) */

#if ((DEM_DCM_ENABLED == STD_ON) && (DEM_OBD_Support == STD_ON))
/* !LINKSTO Dem.ASR431.SWS_Dem_00316,1 */
/** \brief Service is used for requesting IUMPR data according to InfoType
 **        $08. This interface is derived from the prototype
 **        &lt;Module&gt;_GetInfotypeValueData() defined by the Dcm. Therefore
 **        Dcm_OpStatusType and Std_ReturnType are contained. API is needed in
 **        OBD-relevant ECUs only.
 **
 ** API Availability: This API will be available only if ({ecuc(Dem/
 **                   DemGeneral.DemOBDSupport)} != DEM_OBD_NO_OBD_SUPPORT)
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in]     OpStatus              Only DCM_INITIAL will appear, because
 **                                      this API behaves synchronous.
 **
 ** \param[in,out] Iumprdata08BufferSize The maximum number of data bytes that
 **                                      can be written to the Iumprdata08
 **                                      Buffer.
 **
 ** \param[out]    Iumprdata08           Buffer containing the number of data
 **                                      elements (as defined in ISO-15031-5)
 **                                      and contents of InfoType $08. The
 **                                      buffer is provided by the Dcm.
 **
 ** \return Always E_OK is returned.
 **
 ** \ServiceID{::DEM_SID_DcmGetInfoTypeValue08}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmGetInfoTypeValue08(
  Dcm_OpStatusType                       OpStatus,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Iumprdata08,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Iumprdata08BufferSize);

/* !LINKSTO Dem.ASR431.SWS_Dem_00317,1 */
/** \brief Service is used for requesting IUMPR data according to InfoType
 **        $0B. This interface is derived from the prototype
 **        &lt;Module&gt;_GetInfotypeValueData() defined by the Dcm. Therefore
 **        Dcm_OpStatusType and Std_ReturnType are contained. API is needed in
 **        OBD-relevant ECUs only.
 **
 ** API Availability: This API will be available only if ({ecuc(Dem/
 **                   DemGeneral.DemOBDSupport)} != DEM_OBD_NO_OBD_SUPPORT)
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in]     OpStatus              Only DCM_INITIAL will appear, because
 **                                      this API behaves synchronous.
 **
 ** \param[in,out] Iumprdata0BBufferSize The maximum number of data bytes that
 **                                      can be written to the Iumprdata0B
 **                                      Buffer.
 **
 ** \param[out]    Iumprdata0B           Buffer containing the number of data
 **                                      elements (as defined in ISO-15031-5)
 **                                      and contents of InfoType $0B. The
 **                                      buffer is provided by the Dcm.
 **
 ** \return Always E_OK is returned.
 **
 ** \ServiceID{::DEM_SID_DcmGetInfoTypeValue0B}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmGetInfoTypeValue0B(
  Dcm_OpStatusType                       OpStatus,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Iumprdata0B,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Iumprdata0BBufferSize);
#endif /* (DEM_DCM_ENABLED == STD_ON) && (DEM_OBD_Support == STD_ON) */

#if (DEM_OBD_Support == STD_ON)
/** \brief Service to report the value of PID $01 computed by the Dem.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[out] PID01value  Buffer containing the contents of PID$01 computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID01}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem318,2, Dem.Pid.SupportedPid_1,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID01(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID01value);
#endif

/** \brief Service to report the value of PID $21 computed by the Dem.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[out] PID21value  Buffer containing the contents of PID$21 computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID21}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem319,2 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID21(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID21value);

/** \brief Service to report the value of PID $30 computed by the Dem.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[out] PID30value  Buffer containing the contents of PID$30 computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID30}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID30(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID30value);

/** \brief Service to report the value of PID $31 computed by the Dem.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[out] PID31value  Buffer containing the contents of PID$31 computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID31}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID31(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID31value);

#if (DEM_OBD_Support == STD_ON)
/** \brief Service to report the value of PID $41 computed by the Dem.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[out] PID41value  Buffer containing the contents of PID$41 computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID41}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID41(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID41value);
#endif

/** \brief Service to report the value of PID $4D computed by the Dem.
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[out] PID4Dvalue  Buffer containing the contents of PID$4D computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID4D}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID4D(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID4Dvalue);

/** \brief Service to report the value of PID $4E computed by the Dem.
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[out] PID4Evalue  Buffer containing the contents of PID$4E computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID4E}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID4E(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID4Evalue);

#if (DEM_OBD_COMPLIANCY_ENABLED == STD_ON)
/** \brief Service to report the value of PID $1C computed by the Dem.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[out] PID1Cvalue  Buffer containing the contents of PID$1C computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID1C}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID1C(
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID1Cvalue);
#endif

/* !LINKSTO Dem_OBD_0001,2 */
#if (DEM_OBD_Support == STD_ON)
/** \brief Gets data element per PID and index of the most important freeze
 ** frame being selected for the output of service $02
 **
 ** The function stores the data in the provided DestBuffer.
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] PID  This parameter is an identifier for a PID as defined in
 **              ISO15031-5.
 ** \param[in] DataElementIndexOfPID  This parameter is a Data element index
 **              of this PID according to the Dcm configuration
 **              of service $02. It is zero-based and consecutive,
 **              and ordered by the data element positions.
 ** \param[in,out] DestBuffer  This parameter contains a byte pointer that
 **              points to the buffer to which freeze frame data shall be
 **              written. The format is raw hexadecimal values and contains
 **              no header information.
 ** \param[in,out] BufSize  When the function is called this parameter
 **              contains the maximum number of data bytes that can be written
 **              to the buffer.
 **
 ** \return success of operation
 ** \retval E_OK Freeze frame data was successfully reported
 ** \retval E_NOT_OK Freeze frame data was not successfully reported
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfOBDFreezeFrame}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.ReadDataOfOBDFreezeFrame,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfOBDFreezeFrame(
  uint8                                   PID,
  uint8                                   DataElementIndexOfPID,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) BufSize);

/** \brief Gets DTC by freeze frame record number
 **
 ** Note: This API must only be used by the Dcm module!
 ** \param[in] FrameNumber  Unique identifier for a freeze frame record as
 **              defined in ISO 15031-5. The value 0x00 indicates the complete
 **              OBD freeze frame. Other values are reserved for future
 **              functionality and are not supported yet.
 ** \param[out] DTC  Diagnostic Trouble Code. If the return value of the
 **              function is other than E_OK this parameter does not
 **              contain valid data.
 ** \param[in] DTCFormat  Output format of the DTC value.
 ** \return success of operation
 ** \retval E_OK   operation was successful
 ** \retval E_NOT_OK  no DTC available
 **
 ** \ServiceID{::DEM_SID_DcmGetDTCOfOBDFreezeFrame}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.GetDTCOfOBDFreezeFrame,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmGetDTCOfOBDFreezeFrame(
  uint8                                   FrameNumber,
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA) DTC,
  Dem_DTCFormatType                       DTCFormat);

/** \brief Reports the value of a requested "availability-OBDMID" to the DCM
 **        upon a Service $06 request. Derived from that the tester displays
 **        the supported tests a mechanic can select from. API is needed in
 **        OBD-relevant ECUs only.
 **
 ** API Availability: This API will be available only if
 ** ({ecuc(Dem/DemGeneral.DemOBDSupport)} != DEM_OBD_NO_OBD_SUPPORT)
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** \param[in] Obdmid  Availablity OBDMID ($00,$20, $40...)
 **
 ** \param[out] Obdmidvalue  Bit coded information on the support of OBDMIDs.
 ** \return success of operation
 ** \retval E_OK   Report of DTR result successful
 ** \retval E_NOT_OK  Report of DTR result failed
 **
 ** \ServiceID{::DEM_SID_DcmGetAvailableOBDMIDs}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_00766,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmGetAvailableOBDMIDs(
  uint8                                   Obdmid,
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA) Obdmidvalue);

/** \brief Gets the number of TIDs per (functional) OBDMID. This can be used
 **        by the DCM to iteratively request for OBD/TID result data within a
 **        loop from 0....numberOfTIDs-1. API is needed in OBD-relevant ECUs
 **        only.
 **
 ** API Availability: This API will be available only if
 ** ({ecuc(Dem/DemGeneral.DemOBDSupport)} != DEM_OBD_NO_OBD_SUPPORT)
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** \param[in] Obdmid  OBDMID subject of the request to identify the number
 **                    of assigned TIDs.
 **
 ** \param[out] numberOfTIDs  Number of assigned TIDs for the requested OBDMID.
 **                           Used as loop value for the DCM to retrieve all
 **                           OBD/TID result data.
 ** \return success of operation
 ** \retval E_OK  Get number of TIDs successful
 ** \retval E_NOT_OK  Get number of TIDs failed
 **
 ** \ServiceID{::DEM_SID_DcmGetNumTIDsOfOBDMID}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_00767,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmGetNumTIDsOfOBDMID(
  uint8                                  Obdmid,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) numberOfTIDs);

/** \brief Reports a DTR data along with TID-value, UaSID, test result
 **        with lower and upper limit.
 **        API is needed in OBD-relevant ECUs only.
 **
 ** API Availability: This API will be available only if
 ** ({ecuc(Dem/DemGeneral.DemOBDSupport)} != DEM_OBD_NO_OBD_SUPPORT)
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** \param[in] Obdmid    Identification of a DTR element by assigned DTRId.
 ** \param[in] TIDindex  Index of the TID within the DEM. Runs from 0
 **                      to "numberOfTIDs" obtained in the call to Dem_
 **                      DcmGetNumTIDsOfOBDMID()
 **
 ** \param[out] TIDvalue     TID to be put on the tester reponse
 ** \param[out] UaSID        UaSID to be put on the tester reponse
 ** \param[out] Testvalue    Latest test result
 ** \param[out] Lowlimvalue  Lower limit value associated to the latest test
 **                          result
 ** \param[out] Upplimvalue  Upper limit value associated to the latest test
 **                          result
 **
 ** \return success of operation
 ** \retval E_OK   Report of DTR result successful
 ** \retval E_NOT_OK  Report of DTR result failed
 **
 ** \ServiceID{::DEM_SID_DcmGetDTRData}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_00768,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmGetDTRData(
  uint8                                   Obdmid,
  uint8                                   TIDindex,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  TIDvalue,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  UaSID,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) Testvalue,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) Lowlimvalue,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) Upplimvalue);

/* !LINKSTO Dem.ASR431.SWS_Dem_01187,1 */
/** \brief Service to report the value of PID $91 computed by the Dem.
 ** API is needed in OBD-relevant ECUs only.
 **
 ** API Availability: This API will be available only if
 ** ({ecuc(Dem/DemGeneral.DemOBDSupport)} != DEM_OBD_NO_OBD_SUPPORT)
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** \param[out] PID91value  Buffer containing the contents of PID $91
 **                         computed by the Dem.
 **                         The buffer is provided by the Dcm with the
 **                         appropriate size, i.e. during configuration, the
 **                         Dcm identifies the required size from the largest
 **                         PID in order to configure a PIDBuffer.
 **
 ** \retval Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID91}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID91(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID91value);

#endif /* (DEM_OBD_Support == STD_ON) */

/*------------------[J1939-specific Interfaces]-----------------------------*/
#if (DEM_J1939_SUPPORT == STD_ON)

#if (DEM_J1939_READING_DTC_SUPPORT == STD_ON)
/** \brief The function sets the DTC filter for a specific node and returns the composite
 **        lamp status of the filtered DTCs.
 **
 ** \param[in] DTCStatusFilter  The filter type to filter the DTCs.
 ** \param[in] DTCKind  The kind of DTCs to filter.
 ** \param[in] node  The requesting NM node.
 ** \param[out] LampStatus  The status of all the 4 lamps.
 **
 ** \return Filter status available or not
 ** \retval DEM_FILTER_ACCEPTED filter is accepted
 ** \retval DEM_WRONG_FILTER filter is not accepted

 **
 ** \ServiceID{::DEM_SID_J1939DcmSetDTCFilter}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR422.SWS_Dem_00970,1 */
extern FUNC(Dem_ReturnSetFilterType, DEM_CODE) Dem_J1939DcmSetDTCFilter(
  Dem_J1939DcmDTCStatusFilterType                              DTCStatusFilter,
  Dem_DTCKindType                                              DTCKind,
  uint8                                                        node,
  P2VAR(Dem_J1939DcmLampStatusType, AUTOMATIC, DEM_APPL_DATA) LampStatus);


/** \brief Gets the count of filtered J1939 DTC.
 **
 ** \param[out] NumberOfFilteredDTC  The number of DTCs that have been filtered.
 **
 ** \return Number of DTCs available or not
 ** \retval DEM_NUMBER_OK Number of Filtered DTCs is available
 ** \retval DEM_NUMBER_FAILED Number of Filtered DTCs is not available
 **
 ** \ServiceID{::DEM_SID_J1939DcmGetNumberOfFilteredDTC}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR422.Dem_J1939DcmGetNumberOfFilteredDTC,1 */
extern FUNC(Dem_ReturnGetNumberOfFilteredDTCType, DEM_CODE) Dem_J1939DcmGetNumberOfFilteredDTC(
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) NumberOfFilteredDTC);

/** \brief Gets the next filtered J1939 DTC.
 **
 ** \param[out] J1939DTC  The next J1939 DTC value that matches the filter.
 **                       Data is only valid, if return value is DEM_FILTERED_OK.
 ** \param[out] OccurenceCounter  The occurrence counter of the filtered DTC.
 **                               Data is only valid, if return value is DEM_FILTERED_OK.
 **
 ** \return DTC available or not
 ** \retval DEM_FILTERED_OK DTC is found
 ** \retval DEM_FILTERED_NO_MATCHING_ELEMENT  No further element (matching the filter
                                              criteria) found
 **
 ** \ServiceID{::DEM_SID_J1939DcmGetNextFilteredDTC}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR422.Dem_J1939DcmGetNextFilteredDTC,1 */
extern FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE) Dem_J1939DcmGetNextFilteredDTC(
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA) J1939DTC,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) OccurenceCounter);
#endif /* (DEM_J1939_READING_DTC_SUPPORT == STD_ON) */

#if (DEM_J1939_CLEAR_DTC_SUPPORT == STD_ON)
/** \brief Clears active DTCs as well as previously active DTCs.
 **
 ** \param[in] DTCTypeFilter  The following types are available:
 **                           DEM_J1939DTC_CLEAR_ALL
 **                           DEM_J1939DTC_CLEAR_PREVIOUSLY_ACTIVE
 ** \param[in] node           Nm node Id of requesting client
 **
 ** \return Status of the operation of type Dem_ReturnClearDTCType.
 ** \retval DEM_CLEAR_OK           DTC successfully cleared
 ** \retval DEM_ASR42_CLEAR_FAILED DTC clearing failed
 ** \retval DEM_CLEAR_PENDING      The DTC clearing is performed asynchronously
 **                                and still pending. The caller can retry later.
 ** \retval DEM_CLEAR_BUSY         DTC not cleared, as another clearing process
 **                                is in progress. The caller can retry later.
 ** \retval DEM_CLEAR_MEMORY_ERROR An error occurred during erasing a
 **                                memory location
 ** \ServiceID{::DEM_SID_J1939DcmClearDTC}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Asynchronous}
 */
/* !LINKSTO Dem.ASR422.SWS_Dem_00976,1 */
extern FUNC(Dem_ReturnClearDTCType, DEM_CODE) Dem_J1939DcmClearDTC(
  Dem_J1939DcmSetClearFilterType    DTCTypeFilter,
  uint8                                     node);
#endif /* (DEM_J1939_CLEAR_DTC_SUPPORT == STD_ON) */

#if (DEM_J1939_FREEZEFRAME_SUPPORT==STD_ON)
/** \brief Sets filter for the J1939 Freeze Frame.
 **
 ** \param[in] FreezeFrameKind  The type of Freeze Frame to be filtered.
 ** \param[in] node  The Nm node for which the Freeze Frames should be filtered.
 **
 ** \return Filter status available or not
 ** \retval DEM_FILTER_ACCEPTED filter is accepted
 ** \retval DEM_WRONG_FILTER filter is not accepted
 **
 ** \ServiceID{::DEM_SID_J1939DcmSetFreezeFrameFilter}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR422.SWS_Dem_00977,1 */
extern FUNC(Dem_ReturnSetFilterType, DEM_CODE) Dem_J1939DcmSetFreezeFrameFilter(
  Dem_J1939DcmSetFreezeFrameFilterType FreezeFrameKind,
  uint8 node);

/** \brief Gets the next filtered J1939 Freeze Frame data.
 **        The function stores the data in the provided DestBuffer.
 **
 ** \param[out] J1939DTC          The next J1939 DTC value that matches the
 **                               filter. Data is only valid, if return value
 **                               is DEM_FILTERED_OK.
 ** \param[out] OccurenceCounter  The occurrence counter of the filtered DTC.
 **                               Data is only valid, if return value is DEM_FILTERED_OK.
 ** \param[in,out] BufSize        The buffer size of the available buffer at the
 **                               caller and will be filled with the size of
 **                               the freezeframe data in case of success.
 ** \param[in,out] DestBuffer     The buffer that will be filled with the
 **                               freeze frame data.
 **
 ** \return Freeze Frame available or not
 ** \retval DEM_FILTERED_OK              Freeze Frame is found
 ** \retval DEM_FILTERED_NO_MATCHING_ELEMENT Freeze Frame is not available
 **
 ** \ServiceID{::DEM_SID_J1939DcmGetNextFreezeFrame}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR422.Dem_J1939DcmGetNextFreezeFrame,1 */
extern FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE) Dem_J1939DcmGetNextFreezeFrame(
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA) J1939DTC,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  OccurenceCounter,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) BufSize
);
#endif

#if (DEM_J1939_RATIO_SUPPORT == STD_ON)
/** \brief The function sets the Ratio filter for a specific node and returns the corresponding
 **        Ignition Cycle Counter and General Denominator.
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** \param[out] IgnitionCycleCounter Ignition Cycle Counter.
 ** \param[in] OBDMonitoringConditionsEncountered OBD Monitoring Conditions Encountered
 ** \param[in] node  Nm node Id of requesting client.
 **
 ** \return Filter status available or not
 ** \retval DEM_FILTER_ACCEPTED filter is accepted
 ** \retval DEM_WRONG_FILTER filter is not accepted
 **
 ** \ServiceID{::DEM_SID_J1939DcmSetRatioFilter}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_ReturnSetFilterType, DEM_CODE) Dem_J1939DcmSetRatioFilter(
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) IgnitionCycleCounter,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) OBDMonitoringConditionsEncountered,
  uint8 node);

/** \brief Gets the next filtered J1939 Ratio.
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** \param[out] SPN         Receives the SPN of the applicable system monitor.
 **                         If the return value of the function is other than
 **                         DEM_FILTERED_OK this parameter does not contain valid data.
 ** \param[out] Numerator   Receives the Numerator of the applicable system
 **                         monitor. If the return value of the function is other
 **                         than DEM_FILTERED_OK this parameter does not
 **                         contain valid data.
 ** \param[out] Denominator Receives the Denominator of the applicable system
 **                         monitor. If the return value of the function is other
 **                         than DEM_FILTERED_OK this parameter does not
 **                         contain valid data.
 **
 ** \return DTC available or not
 ** \retval DEM_FILTERED_OK Ratio available in out parameter
 ** \retval DEM_FILTERED_NO_MATCHING_ELEMENT No further element available
 **
 ** \ServiceID{::DEM_SID_J1939DcmGetNextFilteredRatio}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE) Dem_J1939DcmGetNextFilteredRatio(
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) SPN,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) Numerator,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) Denominator);
#endif /* (DEM_J1939_RATIO_SUPPORT == STD_ON) */

#if (DEM_J1939_READINESS1_SUPPORT == STD_ON)
/** \brief Service to report the value of Diagnostic Readiness 1 (DM05) computed by the Dem.
 **
 ** \param[out] DataValue Buffer of 8 bytes containing the contents of Diagnostic
 **                       Readiness 1 (DM05) computed by the Dem.
 ** \param[in] node Nm node Id of requesting client.
 **
 ** \return success of operation.
 ** \retval E_OK Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_J1939DcmReadDiagnosticReadiness1}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem.ASR422.SWS_Dem_00982,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_J1939DcmReadDiagnosticReadiness1(
  P2VAR(Dem_J1939DcmDiagnosticReadiness1Type, AUTOMATIC, AUTOMATIC) DataValue,
  uint8 node);
#endif /* (DEM_J1939_READINESS1_SUPPORT == STD_ON)*/

#if (DEM_J1939_READINESS2_SUPPORT == STD_ON)
/** \brief Service to report the value of Diagnostic Readiness 2 (DM21) computed by the Dem.
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** \param[out] DataValue Buffer of 8 bytes containing the contents of Diagnostic
 **                       Readiness 2 (DM21) computed by the Dem.
 ** \param[in] node Nm node Id of requesting client.
 **
 ** \return success of operation.
 ** \retval E_OK Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_J1939DcmReadDiagnosticReadiness2}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */

extern FUNC(Std_ReturnType, DEM_CODE) Dem_J1939DcmReadDiagnosticReadiness2(
  P2VAR(Dem_J1939DcmDiagnosticReadiness2Type, AUTOMATIC, AUTOMATIC) DataValue,
  uint8 node);
#endif /* (DEM_J1939_READINESS2_SUPPORT == STD_ON)*/

#if (DEM_J1939_READINESS3_SUPPORT == STD_ON)
/** \brief Service to report the value of Diagnostic Readiness 3 (DM26) computed by the Dem.
 **
 ** Note: Functionality not implemented, only stub available.
 **
 ** \param[out] DataValue Buffer of 8 bytes containing the contents of Diagnostic
 **                       Readiness 3 (DM26) computed by the Dem.
 ** \param[in] node Nm node Id of requesting client.
 **
 ** \return success of operation.
 ** \retval E_OK Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_J1939DcmReadDiagnosticReadiness3}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */

extern FUNC(Std_ReturnType, DEM_CODE) Dem_J1939DcmReadDiagnosticReadiness3(
  P2VAR(Dem_J1939DcmDiagnosticReadiness3Type, AUTOMATIC, AUTOMATIC) DataValue,
  uint8 node);
#endif /* (DEM_J1939_READINESS3_SUPPORT == STD_ON)*/

#endif /* (DEM_J1939_SUPPORT == STD_ON) */

/*------------------[Scheduled functions]-----------------------------------*/

#if ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL))

/* This macro definition has been introduced in order to fix the compiler
 * warning 'redundant redeclaration'. The solution has been applied according
 * to the fixes suggested in RfC#53853 */
#ifndef RTE_SCHM_SWCBSW_DEM_MAINFUNCTION
#define RTE_SCHM_SWCBSW_DEM_MAINFUNCTION
/** \brief Processes event memory entries from error-queue
 **
 ** This function is used to process all not event based Dem internal
 ** functions. It shall be called periodically as cyclic task by the software
 ** system (e.g. by operating system).
 **
 ** Timing: fixed cyclic
 **
 ** Configuration: The cyclic time for the main function has to be defined as
 ** an operating system task or runnable entity.
 **
 ** \ServiceID{::DEM_SID_MainFunction}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem266,1 */
extern FUNC(void, DEM_CODE) Dem_MainFunction(void);
#endif /* #ifndef RTE_SCHM_SWCBSW_DEM_MAINFUNCTION */

#endif /* #if ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL)) */

#if (DEM_EXTENDED_DATA_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD)
/** \brief Gets the SI30 Status by event.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[out] Status  Pointer to variable which contains the SI30 status
 **                     of the event
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_GetSI30Status}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetSI30Status(
  Dem_EventIdType                        EventId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Status);

#if (DEM_SUPPORT_FIM_ON_FDC_TRESHOLD == STD_ON)
/** \brief Set SymptomSinceLastClear (SI30.bit4).
 **
 ** \param[in] EventId  Identification of the Event for which the status shall be set.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_SetSI30Symptom}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetSI30Symptom(
  Dem_EventIdType                        EventId);

/** \brief Sets the SI30 Status by event.Set WarningIndicatorRequestedSinceLastClear (SI30.bit5).
 **
 ** \param[in] EventId  Identification of the Event for which the status shall be set.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_SetSI30Notification}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetSI30Notification(
  Dem_EventIdType                        EventId);
#endif /* DEM_SUPPORT_FIM_ON_FDC_TRESHOLD == STD_ON */
#endif /* DEM_EXTENDED_DATA_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD */

#define DEM_STOP_SEC_CODE
#include <Dem_MemMap.h>

#endif /* ifndef DEM_H */
/*==================[end of file]===========================================*/
