/**
 * \file
 *
 * \brief AUTOSAR Dem
 *
 * This file contains the implementation of the AUTOSAR
 * module Dem.
 *
 * \version 6.4.1
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2021 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
#ifndef DEM_INT_H
#define DEM_INT_H

/* This file contains or includes all internal configuration dependant
 * identifiers of the AUTOSAR module Dem. */

/*  MISRA-C:2012 Deviation List
 *
 *  MISRAC2012-1) Deviated Rule: 19.2 (required)
 *     "The union keyword should not be used."
 *
 *     Reason:
 *     Union is used to declare a type of all possible pointers to functions
 *     used for Read data element operations.
 *     Since the function pointers have different types, they are declared as instances
 *     of this union.
 *     By using union instead of structure, memory usage is reduced.
 */

/*==================[inclusions]============================================*/
/* !LINKSTO dsn.Dem.IncludeStr,1 */

#include <Std_Types.h>                            /* AUTOSAR standard types */

#if (defined DEM_INTERNAL)
#error DEM_INTERNAL is already defined
#endif
/** \brief Dem-internal marker for RTE-related declarations in
 ** \verbatim Dem.h\endverbatim
 **
 ** Note: \verbatim Dem_Int_Cfg.h\endverbatim includes user-specific h-files,
 **        which in turn might include \verbatim Dem.h\endverbatim also. */
#define DEM_INTERNAL

#include <Dem.h>                              /* Module public declarations */
#include <Dem_Int_Stc.h>             /* Module internal static declarations */
#include <Dem_Int_Cfg.h>                 /* Internal generated declarations */

#include <SchM_Dem.h>    /* Exclusive area, SchM Trigger, and SchM S/R APIs */
#if (DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING == STD_ON)
#include <Os.h>                                  /* regarding GetCoreID API */
#endif

#if (DEM_INCLUDE_RTE == STD_ON)
#if (defined RTE_PTR2ARRAYBASETYPE_PASSING)
#error RTE_PTR2ARRAYBASETYPE_PASSING is already defined
#endif
#define RTE_PTR2ARRAYBASETYPE_PASSING
#include <Rte_Dem.h>                                /* API generated by RTE */
#endif

#if (DEM_DEV_ERROR_DETECT == STD_ON)
#include <Det.h>                                     /* Det Error Reporting */
#endif

#if ((DEM_J1939_SUPPORT == STD_ON) && (DEM_J1939_READING_DTC_SUPPORT == STD_ON))
#include <J1939Dcm_Cbk.h>
#endif

/*==================[macros]================================================*/

#if (DEM_DEV_ERROR_DETECT == STD_ON)

#if (defined DEM_INSTANCE_ID)
#error DEM_INSTANCE_ID is already defined
#endif
#define DEM_INSTANCE_ID     0U

#endif /* DEM_DEV_ERROR_DETECT */





/*------------------------[Defensive programming]----------------------------*/

#if (defined DEM_PRECONDITION_ASSERT)
#error DEM_PRECONDITION_ASSERT is already defined
#endif

#if (defined DEM_PRECONDITION_ASSERT_NO_EVAL)
#error DEM_PRECONDITION_ASSERT_NO_EVAL is already defined
#endif

#if (DEM_PRECONDITION_ASSERT_ENABLED == STD_ON)
/** \brief Report an assertion violation to Det
 **

 ** \param[in] Condition The condition which is verified
 ** \param[in] ApiId The service ID of the API function */
#define DEM_PRECONDITION_ASSERT(Condition, ApiId) \
  DET_PRECONDITION_ASSERT((Condition), DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))

/** \brief Report an assertion violation to Det
 **

 ** \param[in] Condition The condition which is verified
 ** \param[in] ApiId The service ID of the API function */
#define DEM_PRECONDITION_ASSERT_NO_EVAL(Condition, ApiId) \
  DET_PRECONDITION_ASSERT_NO_EVAL((Condition), DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))
#else
#define DEM_PRECONDITION_ASSERT(Condition, ApiId)
#define DEM_PRECONDITION_ASSERT_NO_EVAL(Condition, ApiId)
#endif

#if (defined DEM_POSTCONDITION_ASSERT)
#error DEM_POSTCONDITION_ASSERT is already defined
#endif

#if (defined DEM_POSTCONDITION_ASSERT_NO_EVAL)
#error DEM_POSTCONDITION_ASSERT_NO_EVAL is already defined
#endif

#if (DEM_POSTCONDITION_ASSERT_ENABLED == STD_ON)
/** \brief Report an assertion violation to Det
 **

 ** \param[in] Condition The condition which is verified
 ** \param[in] ApiId The service ID of the API function */
#define DEM_POSTCONDITION_ASSERT(Condition, ApiId) \
  DET_POSTCONDITION_ASSERT((Condition), DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))

/** \brief Report an assertion violation to Det
 **

 ** \param[in] Condition The condition which is verified
 ** \param[in] ApiId The service ID of the API function */
#define DEM_POSTCONDITION_ASSERT_NO_EVAL(Condition, ApiId) \
  DET_POSTCONDITION_ASSERT_NO_EVAL((Condition), DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))
#else
#define DEM_POSTCONDITION_ASSERT(Condition, ApiId)
#define DEM_POSTCONDITION_ASSERT_NO_EVAL(Condition, ApiId)
#endif

#if (defined DEM_INVARIANT_ASSERT)
#error DEM_INVARIANT_ASSERT is already defined
#endif

#if (defined DEM_INVARIANT_ASSERT_NO_EVAL)
#error DEM_INVARIANT_ASSERT_NO_EVAL is already defined
#endif

#if (DEM_INVARIANT_ASSERT_ENABLED == STD_ON)
/** \brief Report an assertion violation to Det
 **

 ** \param[in] Condition The condition which is verified
 ** \param[in] ApiId The service ID of the API function */
#define DEM_INVARIANT_ASSERT(Condition, ApiId) \
  DET_INVARIANT_ASSERT((Condition), DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))

/** \brief Report an assertion violation to Det
 **

 ** \param[in] Condition The condition which is verified
 ** \param[in] ApiId The service ID of the API function */
#define DEM_INVARIANT_ASSERT_NO_EVAL(Condition, ApiId) \
  DET_INVARIANT_ASSERT_NO_EVAL((Condition), DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))
#else
#define DEM_INVARIANT_ASSERT(Condition, ApiId)
#define DEM_INVARIANT_ASSERT_NO_EVAL(Condition, ApiId)
#endif

#if (defined DEM_STATIC_ASSERT)
# error DEM_STATIC_ASSERT is already defined
#endif
#if (DEM_STATIC_ASSERT_ENABLED == STD_ON)
/** \brief Report an static assertion violation to Det
 **
 ** \param[in] Condition Condition which is violated */
# define DEM_STATIC_ASSERT(expr) DET_STATIC_ASSERT(expr)
#else
# define DEM_STATIC_ASSERT(expr)
#endif

#if (defined DEM_UNREACHABLE_CODE_ASSERT)
#error DEM_UNREACHABLE_CODE_ASSERT is already defined
#endif
#if (DEM_UNREACHABLE_CODE_ASSERT_ENABLED == STD_ON)
/** \brief Report an unreachable code assertion violation to Det
 **

 ** \param[in] ApiId Service ID of the API function */
#define DEM_UNREACHABLE_CODE_ASSERT(ApiId) \
  DET_UNREACHABLE_CODE_ASSERT(DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))
#else
#define DEM_UNREACHABLE_CODE_ASSERT(ApiId)
#endif

#if (defined DEM_INTERNAL_API_ID)
#error DEM_INTERNAL_API_ID is already defined
#endif
/** \brief API ID of module internal functions to be used in assertions */
#define DEM_INTERNAL_API_ID DET_INTERNAL_API_ID



/*------------------[PID21 and PID31 configuration]--------------*/

/* either PID21 or PID31 (concerning the computation of distance
 * traveled) is active */
/** \brief Switch, indicating if Dem internally PID related distance calculation
 ** functionality is available  */
#if ((DEM_OBD_CENTRALIZED_PID21_HANDLING == STD_ON) || \
     (DEM_OBD_CENTRALIZED_PID31_HANDLING == STD_ON))
#define DEM_OBD_CENTRALIZED_PID_REL_DISTANCE_HANDLING STD_ON
#else
#define DEM_OBD_CENTRALIZED_PID_REL_DISTANCE_HANDLING STD_OFF
#endif

#if (DEM_OBD_CENTRALIZED_PID_REL_DISTANCE_HANDLING == STD_ON)

#if (defined DEM_MAXIMUM_DISTANCE_TRAVELED)
#error DEM_MAXIMUM_DISTANCE_TRAVELED already defined
#endif
/* !LINKSTO Dem.OBD.PID$21.DistanceTraveled.MaxValue,1 */
/** \brief The maximum value in km which can be returned by PID $21
 ** and PID $31 */
#define DEM_MAXIMUM_DISTANCE_TRAVELED 0xFFFFU

#if (defined DEM_MAXIMUM_DISTANCE_TRAVELED_IN_TICKS)
#error DEM_MAXIMUM_DISTANCE_TRAVELED_IN_TICKS already defined
#endif
/** \brief The maximum distance measured in ticks which needs to
 ** be stored.
 ** Maximum value is calculated as DEM_MAXIMUM_DISTANCE_TRAVELED[km] * 3 600 = 235 926 000
 ** This value can be stored in 28 bits. */
#define DEM_MAXIMUM_DISTANCE_TRAVELED_IN_TICKS \
 (DEM_MAXIMUM_DISTANCE_TRAVELED * 3600U)

#if (defined DEM_CONVERT_TICKS_TO_KILOMETERS)
#error DEM_CONVERT_TICKS_TO_KILOMETERS already defined
#endif
/** \brief Perform conversion from ticks to Kilometers */
#define DEM_CONVERT_TICKS_TO_KILOMETERS(DistanceTraveledKind) \
  ((uint16)((DistanceTraveledKind) / 3600U))

#if (DEM_OBD_CENTRALIZED_PID21_HANDLING == STD_ON)

#if (defined DEM_WUC_ELAPSE_TO_RESET_PID21)
#error DEM_WUC_ELAPSE_TO_RESET_PID21 already defined
#endif
/** \brief The minimum number of warm-up cycles which need to elapse without the MIL
 ** activated in order to trigger the reset of the distance traveled while MIL
 ** is activated counter */
#define DEM_WUC_ELAPSE_TO_RESET_PID21 40U
#endif /* DEM_OBD_CENTRALIZED_PID21_HANDLING == STD_ON */

#endif /* (DEM_OBD_CENTRALIZED_PID_REL_DISTANCE_HANDLING == STD_ON) */

/*------------------[Dem-specific internal Std_ReturnType values]-----------*/

#if (defined DEM_E_DET_REPORT)
#error DEM_E_DET_REPORT already defined
#endif
/** \brief Indicate DET error to calling API
 **
 ** Dem-specific internal ::Std_ReturnType value used by
 ** Dem_InternalSetEventStatus()
 */
#define DEM_E_DET_REPORT   3U

/*------------------[Development error macros]------------------------------*/

#if (DEM_DEV_ERROR_DETECT == STD_ON)

#if (defined DEM_REPORT_ERROR)
#error DEM_REPORT_ERROR already defined
#endif
/** \brief Macro for DET calls in Dem development-error-detection sections */
#if (DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING == STD_ON)
#define DEM_REPORT_ERROR(ApiId, ErrorId) \
  (void)Det_ReportError(DEM_MODULE_ID, GetCoreID(), (ApiId), (ErrorId))
#else
/* !LINKSTO Dem.BSWDistribution.MultipleInstanceDetErrorHandling,1 */
#define DEM_REPORT_ERROR(ApiId, ErrorId) \
  (void)Det_ReportError(DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId), (ErrorId))
#endif

#endif /* DEM_DEV_ERROR_DETECT */

/*------------------[Aging algorithm macros]--------------------------------*/

#if (defined DEM_IS_EVENT_OLDER)
#error DEM_IS_EVENT_OLDER already defined
#endif
/* For events with unconfirmed threshold OCC2 is used instead OccOrder */
#if (DEM_EXTENDED_DATA_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD)
/** \brief Check if event with index EntryIdx is older then even with
 ** index BestEntryIdx */
#define DEM_IS_EVENT_OLDER(EntryIdx, BestEntryIdx)     \
  (EvMemEntry[(EntryIdx)].OCC2 > EvMemEntry[(BestEntryIdx)].OCC2)
#else
#define DEM_IS_EVENT_OLDER(EntryIdx, BestEntryIdx)     \
  (EvMemEntry[(EntryIdx)].OccOrder < EvMemEntry[(BestEntryIdx)].OccOrder)
#endif

/*------------------[General Helper-macros]---------------------------------*/

#if (DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING == STD_ON)

#if (defined DEM_ENTER_EXCLUSIVE_AREA)
#error DEM_ENTER_EXCLUSIVE_AREA already defined
#endif
/* !LINKSTO dsn.Dem.SchMUsage,1 */
/** \brief Macro to enter the generic Dem critical section */
#define DEM_ENTER_EXCLUSIVE_AREA SchM_Enter_Dem_SCHM_DEM_EXCLUSIVE_AREA_MASTER

#if (defined DEM_EXIT_EXCLUSIVE_AREA)
#error DEM_EXIT_EXCLUSIVE_AREA already defined
#endif
/* !LINKSTO dsn.Dem.SchMUsage,1 */
/** \brief Macro to leave the generic Dem critcal section */
#define DEM_EXIT_EXCLUSIVE_AREA SchM_Exit_Dem_SCHM_DEM_EXCLUSIVE_AREA_MASTER

#else

#if (defined DEM_ENTER_EXCLUSIVE_AREA)
#error DEM_ENTER_EXCLUSIVE_AREA already defined
#endif
/* !LINKSTO dsn.Dem.SchMUsage,1 */
/** \brief Macro to enter the generic Dem critical section */
#define DEM_ENTER_EXCLUSIVE_AREA SchM_Enter_Dem_SCHM_DEM_EXCLUSIVE_AREA_0

#if (defined DEM_EXIT_EXCLUSIVE_AREA)
#error DEM_EXIT_EXCLUSIVE_AREA already defined
#endif
/* !LINKSTO dsn.Dem.SchMUsage,1 */
/** \brief Macro to leave the generic Dem critcal section */
#define DEM_EXIT_EXCLUSIVE_AREA SchM_Exit_Dem_SCHM_DEM_EXCLUSIVE_AREA_0

#endif /* (DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING == STD_ON) */

#if (defined DEM_DTC_STATUS_MASKS)
#error DEM_DTC_STATUS_MASKS already defined
#endif
/** \brief DTC status masks */
#define DEM_DTC_STATUS_MASKS    Dem_NvData.DTCStatusMask

#if (defined DEM_OVFIND_FLAGS)
#error DEM_OVFIND_FLAGS  already defined
#endif
/** \brief Flags to indicate whether event memory is full or not */
#define DEM_OVFIND_FLAGS     Dem_NvData.EvMemOvfIndFlags

/* !LINKSTO Dem_OBD_0005,1 */
#if (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U)
#if (defined DEM_PFC_STATUS)
#error DEM_PFC_STATUS  already defined
#endif
/** \brief Flags to indicate whether Dem_SetPfcCycleQualified() function is called */
/* !LINKSTO Dem_OBD_0013,1 */
#define DEM_PFC_STATUS     Dem_NvData.PfcStatus
#endif

#if (defined DEM_INDICATORCOUNTER_ROLE_FAILURE_CYCLE_COUNTER)
#error DEM_INDICATORCOUNTER_ROLE_FAILURE_CYCLE_COUNTER already defined
#endif
/** \brief Indicator cycle counter role is failure cycle counter */
#define DEM_INDICATORCOUNTER_ROLE_FAILURE_CYCLE_COUNTER 0U

#if (defined DEM_INDICATORCOUNTER_ROLE_HEALING_CYCLE_COUNTER)
#error DEM_INDICATORCOUNTER_ROLE_HEALING_CYCLE_COUNTER already defined
#endif
/** \brief Indicator cycle counter role is healing cycle counter */
#define DEM_INDICATORCOUNTER_ROLE_HEALING_CYCLE_COUNTER 1U

#if (DEM_INDICATORCLASS_SUPPORT == STD_OFF)
#if (defined DEM_INDICATOR_DEFAULT_COUNTER)
#error DEM_INDICATOR_DEFAULT_COUNTER already defined
#endif
/** \brief Index of counter is fixed in case of no calibration support */
#define DEM_INDICATOR_DEFAULT_COUNTER  0U
#endif

#if (defined DEM_INDICATOR_CYC_COUNTER)
#error DEM_INDICATOR_CYC_COUNTER already defined
#endif
/** \brief Indicator cycle counter */
#define DEM_INDICATOR_CYC_COUNTER  Dem_NvData.IndicatorCycleCounter

#if (defined DEM_INDICATOR_CYC_COUNTER_ROLE)
#error DEM_INDICATOR_CYC_COUNTER_ROLE already defined
#endif
/** \brief Flags to indicate indicator cycle counter role */
#define DEM_INDICATOR_CYC_COUNTER_ROLE Dem_NvData.IndicatorCycleCounterRole

#if (defined DEM_INDICATOR_CYC_COUNTER_WIR_STATUS)
#error DEM_INDICATOR_CYC_COUNTER_WIR_STATUS already defined
#endif
/** \brief Flags to indicate indicator cycle counter WIR status */
#define DEM_INDICATOR_CYC_COUNTER_WIR_STATUS \
  Dem_NvData.IndicatorCycleCounterWIRStatus

#if ((DEM_NUM_CMB_DTCS > 0U) && (DEM_NUM_FAILURECYCLES > 0U))
#if (defined DEM_CMBEV_FAILURE_CYC_COUNTER)
#error DEM_CMBEV_FAILURE_CYC_COUNTER already defined
#endif
/** \brief FailureCycle counters for all combined events */
#define DEM_CMBEV_FAILURE_CYC_COUNTER Dem_NvData.CmbEvFailureCycleCounter
#endif

#if (DEM_USE_AGING == STD_ON)
#if (defined DEM_AGING_ALLOWED)
#error DEM_AGING_ALLOWED already defined
#endif
/** \brief Aging enabled for an event */
#if (DEM_AGINGALLOWED_CONVENIENT_CALIBRATION == STD_OFF)
#define DEM_AGING_ALLOWED(EvId)      (Dem_GbiNumAgingCycles(EvId) != 0U)
#else
#define DEM_AGING_ALLOWED(EvId)      ((Dem_GbiNumAgingCycles(EvId) != 0U) && \
  (Dem_EventClassDesc[DEM_GBI_EVENTCLASSDESCIDX(EvId)].AgingAllowed == TRUE))
#endif

#if ((DEM_OBD_Support == STD_ON) && (DEM_VCC_OCC5_USED == STD_ON))
#if (defined DEM_OBD_AGING_ALLOWED)
#error DEM_OBD_AGING_ALLOWED already defined
#endif
/** \brief OBD aging enabled for an event */
#define DEM_OBD_AGING_ALLOWED(OBDAgingCycleCounterThreshold)  ((OBDAgingCycleCounterThreshold) > 0U)
#endif

#endif

#if (DEM_USER_CTRL_WIR_SUPPORT == STD_ON)
#if (defined DEM_USER_CTRL_WIR_STATUS_SIZE)
#error DEM_USER_CTRL_WIR_STATUS_SIZE already defined
#endif
/** \brief Size of the user controlled WIR bit status bit-array: Dem_UserCtrlWIRStatus[] */
#define DEM_USER_CTRL_WIR_STATUS_SIZE ( (DEM_NUMBER_OF_EVENTS + 7U) / 8U )

#if (defined DEM_IS_USER_CTRL_WIR_SET)
#error DEM_IS_USER_CTRL_WIR_SET already defined
#endif
/** \brief Macro used to calculate the user controlled WIR bit state of a givent event */
#define DEM_IS_USER_CTRL_WIR_SET(EventId) \
  (DEM_IS_BIT_SET_IN_ARRAY(Dem_UserCtrlWIRStatus, EventId))
#endif /* (DEM_USER_CTRL_WIR_SUPPORT == STD_ON) */

#if (defined DEM_IS_OVFIND_SET)
#error DEM_IS_OVFIND_SET already defined
#endif
/** \brief Is bit set in OverflowFlags */
#define DEM_IS_OVFIND_SET(OriginIdx) \
  (DEM_IS_BIT_SET(DEM_OVFIND_FLAGS, (uint8) (1U << (OriginIdx)) ))

#if (defined DEM_NUMFF)
#error DEM_NUMFF already defined
#endif
/** \brief Get NumFF for an event memory entry */
#define DEM_NUMFF(EvMemEntry, MaxNumFF) \
  (((EvMemEntry)->OccCtr > (MaxNumFF)) ? (MaxNumFF) : (EvMemEntry)->OccCtr)

#if (defined DEM_EVTENTRY_EXISTS_ARRAY_SIZE)
#error DEM_EVTENTRY_EXISTS_ARRAY_SIZE already defined
#endif
/** \brief Size of the bit-array, containing the one bit EvEntryExists status
 ** for each configured event */
#define DEM_EVTENTRY_EXISTS_ARRAY_SIZE ( (DEM_NUMBER_OF_EVENTS + 7U) / 8U )

/*------------------[Helper Macros for Setting EventStatus]-----------------*/
#if (defined DEM_STATUS_FAILED_MASK)
#error DEM_STATUS_FAILED_MASK is already defined
#endif /* DEM_STATUS_FAILED_MASK */
#define DEM_STATUS_FAILED_MASK            0x8000U
#if (defined DEM_EVENT_STATUS_UNCONFIRMED_MASK)
#error DEM_EVENT_STATUS_UNCONFIRMED_MASK is already defined
#endif /* DEM_EVENT_STATUS_UNCONFIRMED_MASK */
#define DEM_EVENT_STATUS_UNCONFIRMED_MASK 0xC000U
#if (defined DEM_EVENT_STATUS_CONFIRMED_MASK)
#error DEM_EVENT_STATUS_CONFIRMED_MASK is already defined
#endif /* DEM_EVENT_STATUS_CONFIRMED_MASK */
#define DEM_EVENT_STATUS_CONFIRMED_MASK   0x4000U
#if (defined DEM_EVENT_STATUS_FFTOC_MASK)
#error DEM_EVENT_STATUS_FFTOC_MASK is already defined
#endif /* DEM_EVENT_STATUS_FFTOC_MASK */
#define DEM_EVENT_STATUS_FFTOC_MASK       0x2000U

/*------------------[Helper Macros for RootId]------------------------------*/

#if (defined DEM_ERRORQUEUE_GET_EVST)
#error DEM_ERRORQUEUE_GET_EVST already defined
#endif
/** \brief Get event status from error-queue entry */
#define DEM_ERRORQUEUE_GET_EVST(ErrorQueueEntry)                     \
  (                                                                  \
    (((ErrorQueueEntry) & DEM_EVENT_STATUS_UNCONFIRMED_MASK)         \
       == DEM_STATUS_FAILED_MASK) ?                                  \
        DEM_EVENT_STATUS_FAILED :                                    \
      (                                                              \
        (((ErrorQueueEntry) & DEM_EVENT_STATUS_UNCONFIRMED_MASK)     \
           == 0x0000U) ?                                             \
            DEM_EVENT_STATUS_PASSED :                                \
          (                                                          \
            (((ErrorQueueEntry) & DEM_EVENT_STATUS_UNCONFIRMED_MASK) \
                == DEM_EVENT_STATUS_CONFIRMED_MASK) ?                \
                DEM_EVENT_STATUS_CONFIRMED :                         \
                DEM_EVENT_STATUS_UNCONFIRMED                         \
          )                                                          \
      )                                                              \
  )

#if (defined DEM_SET_EVENT_FAILED)
#error DEM_SET_EVENT_FAILED is already defined
#endif /* DEM_SET_EVENT_FAILED */
#define DEM_SET_EVENT_FAILED(to) DEM_SET_MASK((to), DEM_STATUS_FAILED_MASK)

#if (defined DEM_SET_EVENT_UNCONFIRMED)
#error DEM_SET_EVENT_UNCONFIRMED is already defined
#endif /* DEM_SET_EVENT_UNCONFIRMED */
#define DEM_SET_EVENT_UNCONFIRMED(to) \
  DEM_SET_MASK((to), DEM_EVENT_STATUS_UNCONFIRMED_MASK)

#if (defined DEM_SET_EVENT_CONFIRMED)
#error DEM_SET_EVENT_CONFIRMED is already defined
#endif /* DEM_SET_EVENT_CONFIRMED */
#define DEM_SET_EVENT_CONFIRMED(to) \
  DEM_SET_MASK((to), DEM_EVENT_STATUS_CONFIRMED_MASK)

#if (defined DEM_SET_EVENT_FFTOC)
#error DEM_SET_EVENT_FFTOC is already defined
#endif /* DEM_SET_EVENT_FFTOC */
#define DEM_SET_EVENT_FFTOC(to) \
  DEM_SET_MASK((to), DEM_EVENT_STATUS_FFTOC_MASK)

#if (defined DEM_CLEAR_EVENT_FFTOC)
#error DEM_CLEAR_EVENT_FFTOC is already defined
#endif /* DEM_CLEAR_EVENT_FFTOC */
#define DEM_CLEAR_EVENT_FFTOC(to) \
  DEM_CLR_MASK_16((to), DEM_EVENT_STATUS_FFTOC_MASK)

#if (defined DEM_IS_ST_BIT_TFTOC_SET)
#error DEM_IS_ST_BIT_TFTOC_SET is already defined
#endif /* DEM_IS_ST_BIT_TFTOC_SET */
#define DEM_IS_ST_BIT_TFTOC_SET(StatusByte) \
  DEM_IS_BIT_SET((StatusByte), DEM_UDS_STATUS_TFTOC)

#if (defined DEM_IS_ST_BIT_TF_SET)
#error DEM_IS_ST_BIT_TF_SET already defined
#endif
/** \brief Check if test failed bit set in DTC status */
#define DEM_IS_ST_BIT_TF_SET(StatusByte) \
  DEM_IS_BIT_SET((StatusByte), DEM_UDS_STATUS_TF)

#if (defined DEM_IS_ST_BIT_TNCTOC_SET)
#error DEM_IS_ST_BIT_TNCTOC_SET already defined
#endif
/** \brief Check if TNCTOC bit set in DTC status */
#define DEM_IS_ST_BIT_TNCTOC_SET(StatusByte) \
  DEM_IS_BIT_SET((StatusByte), DEM_UDS_STATUS_TNCTOC)

#if (defined DEM_IS_ST_BIT_WIR_SET)
#error DEM_IS_ST_BIT_WIR_SET already defined
#endif
/** \brief Check if WIR bit set in DTC status */
#define DEM_IS_ST_BIT_WIR_SET(StatusByte) \
  DEM_IS_BIT_SET((StatusByte), DEM_UDS_STATUS_WIR)

#if (defined DEM_IS_ST_BIT_CDTC_SET)
#error DEM_IS_ST_BIT_CDTC_SET is already defined
#endif /* DEM_IS_ST_BIT_CDTC_SET */
/** \brief Check if CDTC bit set in DTC status */
#define DEM_IS_ST_BIT_CDTC_SET(StatusByte) \
  DEM_IS_BIT_SET((StatusByte), DEM_UDS_STATUS_CDTC)

#if (defined DEM_IS_ST_BIT_PDTC_SET)
#error DEM_IS_ST_BIT_PDTC_SET is already defined
#endif /* DEM_IS_ST_BIT_PDTC_SET */
/** \brief Check if PDTC bit set in DTC status */
#define DEM_IS_ST_BIT_PDTC_SET(StatusByte) \
  DEM_IS_BIT_SET((StatusByte), DEM_UDS_STATUS_PDTC)

#if (defined DEM_ERRORQUEUE_GET_EVID)
#error DEM_ERRORQUEUE_GET_EVID already defined
#endif
/** \brief Get event Id from error-queue entry */
#define DEM_ERRORQUEUE_GET_EVID(ErrorQueueEntry) \
  ((uint16)((ErrorQueueEntry) & (uint16)0x1FFFU))

#if (defined DEM_ERRORQUEUE_GET_FFTOC)
#error DEM_ERRORQUEUE_GET_FFTOC already defined
#endif
/** \brief Get FirstFailed status in queued entry */
#define DEM_ERRORQUEUE_GET_FFTOC(ErrorQueueEntry) \
  (DEM_IS_BIT_SET((ErrorQueueEntry), DEM_EVENT_STATUS_FFTOC_MASK) ?\
   TRUE : FALSE)

#if (defined DEM_IS_EV_ST_BIT_SET)
#error DEM_IS_EV_ST_BIT_SET already defined
#endif
/** \brief Is any bit set from mask in DTC status of event */
#define DEM_IS_EV_ST_BIT_SET(EventId, Mask) \
  DEM_IS_BIT_SET(DEM_DTC_STATUS_MASKS[(EventId)], (Mask))

#if (defined DEM_IS_EV_ST_BIT_TNCTOC_SET)
#error DEM_IS_EV_ST_BIT_TNCTOC_SET already defined
#endif
/** \brief Check if TNCTOC bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_TNCTOC_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_UDS_STATUS_TNCTOC)

#if (defined DEM_IS_EV_ST_BIT_TFTOC_SET)
#error DEM_IS_EV_ST_BIT_TFTOC_SET already defined
#endif
/** \brief Check if TNCTOC bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_TFTOC_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_UDS_STATUS_TFTOC)

#if (defined DEM_IS_EV_ST_BIT_CDTC_SET)
#error DEM_IS_EV_ST_BIT_CDTC_SET already defined
#endif
/** \brief Check if CDTC bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_CDTC_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_UDS_STATUS_CDTC)

#if (defined DEM_IS_EV_ST_BIT_WIR_SET)
#error DEM_IS_EV_ST_BIT_WIR_SET already defined
#endif
/** \brief Check if WIR bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_WIR_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_UDS_STATUS_WIR)

#if (defined DEM_IS_EV_ST_BIT_TF_SET)
#error DEM_IS_EV_ST_BIT_TF_SET already defined
#endif
/** \brief Check if test failed bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_TF_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_UDS_STATUS_TF)

#if (defined DEM_IS_EV_ST_BIT_TNCSLC_SET)
#error DEM_IS_EV_ST_BIT_TNCSLC_SET already defined
#endif
/** \brief Check if TNCSLC bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_TNCSLC_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_UDS_STATUS_TNCSLC)

#if (defined DEM_IS_EV_ST_BIT_PDTC_SET)
#error DEM_IS_EV_ST_BIT_PDTC_SET already defined
#endif
/** \brief Check if PDTC bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_PDTC_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_UDS_STATUS_PDTC)

#if (defined DEM_SET_EV_ST_MASK)
#error DEM_SET_EV_ST_MASK already defined
#endif
/** \brief Set bits in DTCStatusMask */
#define DEM_SET_EV_ST_MASK(EventId, Mask) \
  DEM_SET_MASK(DEM_DTC_STATUS_MASKS[(EventId)], (Mask))

#if (defined DEM_CLR_EV_ST_MASK)
#error DEM_CLR_EV_ST_MASK already defined
#endif
/** \brief Clear bits in DTCStatusMask */
#define DEM_CLR_EV_ST_MASK(EventId, Mask) \
  DEM_CLR_MASK_8(DEM_DTC_STATUS_MASKS[(EventId)], (Mask))

#if (defined DEM_CHNG_EV_ST_MASK)
#error DEM_CHNG_EV_ST_MASK already defined
#endif
/** \brief Change bits in DTCStatusMask */
#define DEM_CHNG_EV_ST_MASK(EventId, Set_Mask, Clr_Mask) \
  do                                                     \
  {                                                      \
    DEM_SET_EV_ST_MASK((EventId), (Set_Mask));           \
    DEM_CLR_EV_ST_MASK((EventId), (Clr_Mask));           \
  } while (0)

#if (defined DEM_ATOMIC_SET_EV_ST_MASK)
#error DEM_ATOMIC_SET_EV_ST_MASK already defined
#endif
/** \brief Atomic Set bits in DTCStatusMask
 *   Note: Must not be used within critical sections. */
#define DEM_ATOMIC_SET_EV_ST_MASK(EventId, Mask) \
  DEM_ATOMIC_SET_MASK(DEM_DTC_STATUS_MASKS[(EventId)], (Mask))

#if (defined DEM_ATOMIC_CLR_EV_ST_MASK)
#error DEM_ATOMIC_CLR_EV_ST_MASK already defined
#endif
/** \brief Atomic Clear bits in DTCStatusMask
 *   Note: Must not be used within critical sections. */
#define DEM_ATOMIC_CLR_EV_ST_MASK(EventId, Mask) \
  DEM_ATOMIC_CLR_MASK(DEM_DTC_STATUS_MASKS[(EventId)], (Mask))

#if (defined DEM_ATOMIC_CHNG_EV_ST_MASK)
#error DEM_ATOMIC_CHNG_EV_ST_MASK already defined
#endif
/** \brief Atomic Change bits in DTCStatusMask
 *   Note: Must not be used within critical sections. */
#define DEM_ATOMIC_CHNG_EV_ST_MASK(EventId, Set_Mask, Clr_Mask) \
  DEM_ATOMIC_CHNG_MASK(DEM_DTC_STATUS_MASKS[(EventId)], (Set_Mask), (Clr_Mask))

#if (DEM_OBDFF_SUPPORT_KIND == DEM_OBDFF_SINGLE)

#if (defined DEM_OBDFF_STORED_EVENT_ID)
#error DEM_OBDFF_STORED_EVENT_ID  already defined
#endif
/** \brief Helper macro for access to Dem_NvData.SingleOBDEventMemoryEntry.EventId */
/* !LINKSTO dsn.Dem.OBD.DEM_OBDFF_STORED_EVENT_ID,1 */
#define DEM_OBDFF_STORED_EVENT_ID     Dem_NvData.SingleOBDEventMemoryEntry.EventId

#if (defined DEM_OBDFF_STORED_DATA)
#error DEM_OBDFF_STORED_DATA  already defined
#endif
/** \brief Helper macro for access to Dem_NvData.SingleOBDEventMemoryEntry.OBDFFData */
/* !LINKSTO dsn.Dem.OBD.DEM_OBDFF_STORED_DATA,1 */
#define DEM_OBDFF_STORED_DATA         Dem_NvData.SingleOBDEventMemoryEntry.OBDFFData

#elif (DEM_OBDFF_SUPPORT_KIND == DEM_OBDFF_MULTIPLE)

#if (defined DEM_OBDFF_ENTRY_OCCURRENCE)
#error DEM_OBDFF_ENTRY_OCCURRENCE  already defined
#endif
#if (defined DEM_OBDFF_ENTRY_FFDATA_LINK)
#error DEM_OBDFF_ENTRY_FFDATA_LINK  already defined
#endif

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)
/** \brief Macro used to abstract the access to OBDOccOrder from Dem_EntryOBDFF */
#define DEM_OBDFF_ENTRY_OCCURRENCE(EvMemEntryIdx)    Dem_EntryOBDFF[(EvMemEntryIdx)].OBDOccOrder
/** \brief Macro used to abstract the access to OBDFFData from Dem_EntryOBDFF */
#define DEM_OBDFF_ENTRY_FFDATA_LINK(EvMemEntryIdx)   Dem_EntryOBDFF[(EvMemEntryIdx)].OBDFFData

#else /* (DEM_USE_IMMEDIATE_NV_STORAGE == STD_OFF) */
/** \brief Macro used to abstract the access to OBDOccOrder from Dem_NvData.OBDFF */
#define DEM_OBDFF_ENTRY_OCCURRENCE(EvMemEntryIdx)    Dem_NvData.EntryOBDFF[(EvMemEntryIdx)].OBDOccOrder
/** \brief Macro used to abstract the access to OBDFFData from Dem_NvData.OBDFF  */
#define DEM_OBDFF_ENTRY_FFDATA_LINK(EvMemEntryIdx)   Dem_NvData.EntryOBDFF[(EvMemEntryIdx)].OBDFFData

#endif /* (DEM_USE_IMMEDIATE_NV_STORAGE == STD_OFF) */
#endif /* (DEM_OBDFF_SUPPORT_KIND == DEM_OBDFF_MULTIPLE) */


#if (DEM_GET_DTCBYOCCURRENCETIME_SUPPORT == STD_ON)
#if (defined DEM_OCCURKIND_STORED_EVENT_ID)
#error DEM_OCCURKIND_STORED_EVENT_ID  already defined
#endif
/** \brief helper macro for access to Dem_NvData.OccurKindEventId */
#define DEM_OCCURKIND_STORED_EVENT_ID(DTCRequestKind) \
  Dem_NvData.OccurKindEventId[(DTCRequestKind) - 1U]
#endif

#if (DEM_OBD_Support == STD_ON)

#if ((DEM_J1939_SUPPORT == STD_ON) && (DEM_J1939_READINESS1_SUPPORT == STD_ON))

#if (defined DEM_J1939_SET_RDY_SUPPORTED)
#error DEM_J1939_SET_RDY_SUPPORTED already defined
#endif
/** \brief Macro to set supported monitor bits for J1939 readiness */
#define DEM_J1939_SET_RDY_SUPPORTED(ReadinessGroup, PIDvalue) \
  (((PIDvalue)[1U - ((ReadinessGroup) / 8U)]) |= (uint8)(1U << ((ReadinessGroup) % 8U)))

#if (defined DEM_J1939_SET_RDY_NOT_COMPLETE)
#error DEM_J1939_SET_RDY_NOT_COMPLETE already defined
#endif
/** \brief Macro to set readiness bits for J1939 readiness to 'Not Complete' value */
#define DEM_J1939_SET_RDY_NOT_COMPLETE(ReadinessGroup, PIDvalue) \
  ((PIDvalue)[2U - (((ReadinessGroup) / 8U) * 2U)] |= \
    (uint8)(1U << ((ReadinessGroup) - (((ReadinessGroup) / 8U) * 4U))))
#endif /* ((DEM_J1939_SUPPORT == STD_ON) && (DEM_J1939_READINESS1_SUPPORT == STD_ON)) */

#if (defined DEM_SET_RDY_SUPPORTED)
#error DEM_SET_RDY_SUPPORTED already defined
#endif
/** \brief Macro to set supported monitor bits in PID $01 or $41 */
#define DEM_SET_RDY_SUPPORTED(ReadinessGroup, PIDvalue) \
  (((PIDvalue)[2U - ((ReadinessGroup) / 8U)]) |= (uint8)(1U << ((ReadinessGroup) % 8U)))

#if (defined DEM_SET_RDY_NOT_COMPLETE)
#error DEM_SET_RDY_NOT_COMPLETE already defined
#endif
/** \brief Macro to set readiness bits in PID $01 or $41 to 'Not Complete' value */
#define DEM_SET_RDY_NOT_COMPLETE(ReadinessGroup, PIDvalue) \
  ((PIDvalue)[3U - (((ReadinessGroup) / 8U) * 2U)] |= \
    (uint8)(1U << ((ReadinessGroup) - (((ReadinessGroup) / 8U) * 4U))))

#if (defined DEM_SET_RDY_COMPLETE)
#error DEM_SET_RDY_COMPLETE already defined
#endif
/** \brief Macro to set readiness bits in PID $01 to 'Complete' value */
#define DEM_SET_RDY_COMPLETE(ReadinessGroup, PIDvalue) \
  ((PIDvalue)[3U - (((ReadinessGroup) / 8U) * 2U)] &= \
    (uint8)~((uint8)(1U << ((ReadinessGroup) - (((ReadinessGroup) / 8U) * 4U)))))

#if (defined DEM_SET_MIL_STATUS_PID01)
#error DEM_SET_MIL_STATUS_PID01 already defined
#endif
/** \brief Macro to set MIL status bit in PID $01 */
#define DEM_SET_MIL_STATUS_PID01(PID01value) \
  ((PID01value) |= 0x80U)

#if (defined DEM_SET_READINESS_GROUP_DISABLED)
#error DEM_SET_READINESS_GROUP_DISABLED already defined
#endif
/** \brief Macro to set the bit of the current readiness group */
#define DEM_SET_READINESS_GROUP_DISABLED(ReadinessGroup, ReadinessStatus) \
  ((ReadinessStatus) &= ~((uint32)1U << (ReadinessGroup)))

#if (defined DEM_RESET_READINESS_GROUP_ENABLED)
#error DEM_RESET_READINESS_GROUP_ENABLED already defined
#endif
/** \brief Macro to reset all readiness group to status enabled */
#define DEM_RESET_READINESS_GROUP_ENABLED(ReadinessStatus) \
  ((ReadinessStatus) |= (0x3FFFU))

#if (defined DEM_MONITOR_IS_ENABLED)
#error DEM_MONITOR_IS_ENABLED already defined
#endif
/** \brief Macro to check if readiness group is enabled */
#define DEM_MONITOR_IS_ENABLED(ReadinessGroup,ReadinessEnableStatus) \
        (((uint32)((ReadinessEnableStatus) >> (ReadinessGroup)) & 1U) != 0U)

#endif /* if (DEM_OBD_Support == STD_ON) */

/* !LINKSTO dsn.Dem.HandleSetCDTC.SetCDTC,1 */
#if (defined DEM_HANDLE_SET_CDTC)
#error DEM_HANDLE_SET_CDTC already defined
#endif
/** \brief sets the confirmed status bit and resets the OCC5 counter
 *   value if necessary */
/* !LINKSTO VCC_DEM_Table_10,1, dsn.Dem.HandleSetCDTC.ResetOCC5,1 */
#if ((DEM_EXTENDED_DATA_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD) && \
     (DEM_VCC_OCC5_USED == STD_ON))
#define DEM_HANDLE_SET_CDTC(EventID, EvMemEntryPtr)                 \
  do{                                                               \
      DEM_SET_EV_ST_MASK((EventID), DEM_UDS_STATUS_CDTC);           \
      (EvMemEntryPtr)->OCC5 = 0U;                                   \
    } while (0)
#else
#define DEM_HANDLE_SET_CDTC(EventID, EvMemEntryPtr)                 \
  do{                                                               \
      DEM_SET_EV_ST_MASK((EventID), DEM_UDS_STATUS_CDTC);           \
    } while (0)
#endif

#if (defined DEM_IS_EVENT_PASSIVE)
#error DEM_IS_EVENT_PASSIVE already defined
#endif
#if (DEM_USE_ADVANCED_EVENT_DISPLACEMENT == STD_ON)
#define DEM_IS_EVENT_PASSIVE(evMemEntryPtr, currentEventId, reportedEventID)  \
      /* currentEventId is not used in advanced displacement */               \
      Dem_IsEventAdvancedPassive((evMemEntryPtr), (reportedEventID))
#elif (DEM_NUM_CMB_DTCS > 0U)
/* If event is combined check the passive state based on the cmb status */
#define DEM_IS_EVENT_PASSIVE(evMemEntryPtr, currentEventId, reportedEventID) \
      (DEM_IS_EVENT_COMBINED(currentEventId) ? \
      ((!DEM_IS_CMB_ST_BIT_SET((currentEventId), DEM_UDS_STATUS_TF)) ? TRUE:FALSE):\
       (!DEM_IS_EV_ST_BIT_TF_SET((currentEventId)) ? TRUE:FALSE))
#else
#define DEM_IS_EVENT_PASSIVE(evMemEntryPtr, currentEventId, reportedEventID)  \
      /* evMemEntryPtr and reportedEventID are not used in this case */       \
      !DEM_IS_EV_ST_BIT_TF_SET((currentEventId))
#endif /* DEM_USE_ADVANCED_EVENT_DISPLACEMENT == STD_ON */

#if (DEM_NUM_CMB_DTCS > 0U)
#if (defined DEM_NUM_CMB_DTCS_BYTES)
#error DEM_NUM_CMB_DTCS_BYTES already defined
#endif
/** \brief size in Bytes for Dem_CmbDTCFlags which is used to check if a cmb status needs to be
 * recalculated */
#define DEM_NUM_CMB_DTCS_BYTES ((uint8)((DEM_NUM_CMB_DTCS + 7u) >> 3u))

#if (defined DEM_IS_EVENT_COMBINED)
#error DEM_IS_EVENT_COMBINED already defined
#endif
/** \brief check if an event is combined or not */
#define DEM_IS_EVENT_COMBINED(EventId) (Dem_GbiDTCConfIdx(EventId) < DEM_NUM_CMB_DTCS)

#if (defined DEM_IS_CMB_ST_BIT_SET)
#error DEM_IS_CMB_ST_BIT_SET already defined
#endif
/** \brief used at storing, aging and displacement of cmb events where the cmb DTC status
 * should be used instead of event status */
#define DEM_IS_CMB_ST_BIT_SET(EventId, Mask) \
  DEM_IS_BIT_SET((Dem_CmbDTCStatus[Dem_GbiDTCConfIdx(EventId)]), (Mask))
#endif /* (DEM_NUM_CMB_DTCS > 0U) */

#if (defined DEM_GET_MASTER_EVID)
#error DEM_GET_MASTER_EVID already defined
#endif
/** \brief If event is involved in combination returns the first EventId from the group
 *  of events stored in Dem_CmbDTCEvents - which is the master event.
 *  If event is not combined, EventId remains the same. */
#if (DEM_NUM_CMB_DTCS > 0U)
#define DEM_GET_MASTER_EVID(EventId) (DEM_IS_EVENT_COMBINED(EventId) ? \
    (Dem_CmbDTCEvents[Dem_CmbDTCEvLnk[Dem_GbiDTCConfIdx(EventId)]]) : (EventId))
#else
#define DEM_GET_MASTER_EVID(EventId) (EventId)
#endif /* (DEM_NUM_CMB_DTCS > 0U) */

#if (defined DEM_GET_DTC_STATUS)
#error DEM_GET_DTC_STATUS already defined
#endif
/** \brief If event is involved in combination returns the combined DTC status
 *  of events stored in Dem_CmbDTCStatus. If event is not combined, returns general DTC status. */
#if (DEM_NUM_CMB_DTCS > 0U)
#define DEM_GET_DTC_STATUS(EventId) (DEM_IS_EVENT_COMBINED(EventId) ? \
    (Dem_CmbDTCStatus[Dem_GbiDTCConfIdx(EventId)]) : DEM_DTC_STATUS_MASKS[(EventId)])
#else
#define DEM_GET_DTC_STATUS(EventId) DEM_DTC_STATUS_MASKS[(EventId)]
#endif /* (DEM_NUM_CMB_DTCS > 0U) */

#if (defined DEM_DTC_SUPPRESSION_ARRAY_SIZE)
#error DEM_DTC_SUPPRESSION_ARRAY_SIZE already defined
#endif
/** \brief Size of Dem_UDSDTCSuppression, Dem_OBDDTCSuppression bit-array */
#define DEM_DTC_SUPPRESSION_ARRAY_SIZE ((DEM_NUMBER_OF_EVENTS + 7U) / 8U)

#if (defined DEM_EVENT_ENABLED_ARRAY_SIZE)
#error DEM_EVENT_ENABLED_ARRAY_SIZE already defined
#endif
/** \brief Size of Dem_EventEnabled bit-array */
#define DEM_EVENT_ENABLED_ARRAY_SIZE ((DEM_NUMBER_OF_EVENTS + 7U) / 8U)

#if (defined DEM_STATUS_BIT_STORAGE_TF_ARRAY_SIZE)
#error DEM_STATUS_BIT_STORAGE_TF_ARRAY_SIZE already defined
#endif
/** \brief Size of the TestFailed bit status bit-array: Dem_StatusBitStorageTF[] */
#define DEM_STATUS_BIT_STORAGE_TF_ARRAY_SIZE ((DEM_NUMBER_OF_EVENTS + 7U) / 8U)

#if (DEM_INDICATORCLASS_SUPPORT== STD_ON)
#if (defined DEM_GET_CALIBRATED_FAILURECYCLE_THRESHOLD)
#error DEM_GET_CALIBRATED_FAILURECYCLE_THRESHOLD already defined
#endif
/** \brief Check whether dedicated indicator has configured DemIndicatorFailureCycleSource to
 *  DEM_FAILURE_CYCLE_EVENT and return the dedicated calibrated failure cycle threshold.
 */
#if (DEM_EVENTCLASS_SUPPORT == STD_ON)
#define DEM_GET_CALIBRATED_FAILURECYCLE_THRESHOLD(EventId, IndicatorClass) \
  ((IndicatorClass)->IsIndFailureCycleSrcEvent ? \
    Dem_EventClassDesc[DEM_GBI_EVENTCLASSDESCIDX(EventId)].EventFailureCycleCounterThreshold : \
      (IndicatorClass)->FailureCycleThreshold)
#else /* (DEM_EVENTCLASS_SUPPORT == STD_OFF) */
#if (DEM_NUM_FAILURECYCLES > 0U)
#define DEM_GET_CALIBRATED_FAILURECYCLE_THRESHOLD(EventId, IndicatorClass) \
  ((IndicatorClass)->IsIndFailureCycleSrcEvent ? \
    DEM_INTERN_EVT_FAILCYC_CTR_THRESHOLD(EventId, Dem_GbiEventFailureClassIdx((EventId))) : \
    (IndicatorClass)->FailureCycleThreshold)
#else /* DEM_NUM_FAILURECYCLES == 0U */
#define DEM_GET_CALIBRATED_FAILURECYCLE_THRESHOLD(EventId, IndicatorClass) \
  ((IndicatorClass)->FailureCycleThreshold)
#endif /* (DEM_NUM_FAILURECYCLES > 0U) */
#endif /* (DEM_EVENTCLASS_SUPPORT == STD_ON) */
#endif /* (DEM_INDICATORCLASS_SUPPORT == STD_ON) */

#if (defined DEM_ORDERED_DTC_REPORTING_USED)
#error DEM_ORDERED_DTC_REPORTING_USED already defined
#endif
/** \brief define, whether DTCs are reported in chronological order via
 *  Dem_GetNextFilteredDTC()
 */
#if (((DEM_RESET_PENDING_BIT_ON_OVERFLOW_SUPPORT == STD_ON) || \
      (DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT == STD_ON)) && \
     (DEM_MAX_NUM_ORDERED_EVENT_IDS > 1U))
#define DEM_ORDERED_DTC_REPORTING_USED   STD_ON
#else
#define DEM_ORDERED_DTC_REPORTING_USED   STD_OFF
#endif

#if ((DEM_INIT_MONITOR_REENABLED_SUPPORT == STD_ON) && (DEM_USE_CB_INIT_MONITOR == STD_ON))
#if (defined DEM_NUM_ENCONDGROUPS_BYTES)
#error DEM_NUM_ENCONDGROUPS_BYTES already defined
#endif
/** \brief Size of Dem_EventEnabled bit-array */
#define DEM_NUM_ENCONDGROUPS_BYTES ((DEM_NUM_ENCONDGROUPS + 7U) / 8U)
#endif

#if ( (DEM_INIT_MONITOR_REENABLED_SUPPORT == STD_ON) && \
      (DEM_USE_CB_INIT_MONITOR == STD_ON) )
#if (defined DEM_IS_INIT_MONITOR_PROCESSING_NEEDED)
#error DEM_IS_INIT_MONITOR_PROCESSING_NEEDED already defined
#endif
/** \brief Returns TRUE if InitMonitorForEvent callbacks need to be triggered
 *  due to re-enabling of monitors
 */
#define DEM_IS_INIT_MONITOR_PROCESSING_NEEDED() \
  (Dem_InitMonitorReenableState.DoProcess != FALSE)
#endif

#if (defined DEM_DTC_SETTING_ALLOWED)
#error DEM_DTC_SETTING_ALLOWED already defined
#endif
/** \brief Returns TRUE if DTC setting is allowed */
/* !LINKSTO Dem.ASR431.ControlDTCSetting.AffectedEvents,1 */
#define DEM_DTC_SETTING_ALLOWED(EventId) \
  ( (FALSE != Dem_DTCSettingAllowed) || \
    (DEM_NO_DTC == Dem_GbiUdsDTC(EventId)) )

#if (defined DEM_CLIENT_ID_INVALID)
#error DEM_CLIENT_ID_INVALID already defined
#endif
/** \brief Marker to identify an invalid client ID */
#define DEM_CLIENT_ID_INVALID    (DEM_NUMBER_OF_CLIENTS + DEM_NUMBER_OF_VIRTUAL_CLIENTS)

#if (defined DEM_VALID_DTC_FOR_EVENT_STORAGE)
#error DEM_VALID_DTC_FOR_EVENT_STORAGE already defined
#endif
/** \brief Macro to define whether an event is an internal event (DTC values 'DEM_NO_DTC')
 *  and therefore valid for storage of event related data.
 */
#if ((DEM_OBD_Support == STD_ON) && (DEM_J1939_SUPPORT == STD_ON))
#define DEM_VALID_DTC_FOR_EVENT_STORAGE(EventId) \
  ((DEM_NO_DTC != Dem_GetJ1939DTC((EventId))) ||   \
   (DEM_NO_DTC != Dem_GetObdDTC((EventId))) ||   \
   (DEM_NO_DTC != Dem_GetUdsDTC((EventId))) )
#elif (DEM_J1939_SUPPORT == STD_ON)
#define DEM_VALID_DTC_FOR_EVENT_STORAGE(EventId) \
  ((DEM_NO_DTC != Dem_GetJ1939DTC((EventId))) ||   \
   (DEM_NO_DTC != Dem_GetUdsDTC((EventId))) )
#elif (DEM_OBD_Support == STD_ON)
#define DEM_VALID_DTC_FOR_EVENT_STORAGE(EventId) \
  ((DEM_NO_DTC != Dem_GetObdDTC((EventId))) ||   \
   (DEM_NO_DTC != Dem_GetUdsDTC((EventId))))
#else
#define DEM_VALID_DTC_FOR_EVENT_STORAGE(EventId) \
  (DEM_NO_DTC != Dem_GetUdsDTC((EventId)))
#endif

#if (DEM_SR_SUPPORT == STD_ON)
#if (defined DEM_IS_SR_ENDIANNESS_CONVERSION_REQUIRED)
#error DEM_IS_SR_ENDIANNESS_CONVERSION_REQUIRED already defined
#endif
/** \brief Macro to define whether data from an SR buffer should be copied as
 *  they are represented in the buffer or should be converted to match the
 *  the endianness of the machine.
 *  The conversion should be done when the endianness of the information from the
 *  SR buffer is not Opaque and is different from the endianness used by the Dem module.
 */
#define DEM_IS_SR_ENDIANNESS_CONVERSION_REQUIRED(DataEndianness) \
  ((CPU_BYTE_ORDER != (DataEndianness)) && (DEM_OPAQUE != (DataEndianness)))
#endif

/*------------------[Calibration unused value]------------------------------*/

#if (DEM_INDICATORCLASS_SUPPORT == STD_ON)
#if (defined DEM_INDICATOR_UNUSED)
#error DEM_INDICATOR_UNUSED already defined
#endif
/** \brief Unused value for indicator group index */
#define DEM_INDICATOR_UNUSED                DEM_NUM_INDICATOR_GROUPS
#endif

/*------------------[Event/DTC description]---------------------------------*/

/* Macros used in Dem_Gbi<> functions to get the place where requested information is stored */

/** \brief Used for retrieving UDS-DTC value, DTCOrigin, ImmediateStorage and DTCSeverity */
#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#if (defined DEM_DESC_CONF1)
#error DEM_DESC_CONF1 already defined
#endif
#define DEM_DESC_CONF1(EventId)  Dem_DTCDesc[Dem_GbiDTCConfIdx(EventId)].DTCConf1
#else
#define DEM_DESC_CONF1(EventId)  Dem_EventDesc[(EventId)].EvConf1
#endif

/** \brief Used for retrieving DTCGroupIdx, FFClassIdx, FFRecInfo, EDClassIdx and
 * AgingCycleThreshold */
#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#if (defined DEM_DESC_CONF2)
#error DEM_DESC_CONF2 already defined
#endif
#define DEM_DESC_CONF2(EventId)  Dem_DTCDesc[Dem_GbiDTCConfIdx(EventId)].DTCConf2
#else
#define DEM_DESC_CONF2(EventId)  Dem_EventDesc[(EventId)].EvConf2
#endif

/** \brief Used for retrieving DTCFunctionalUnit, AgingCycleIdx and Priority */
#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#if (defined DEM_DESC_CONF3)
#error DEM_DESC_CONF3 already defined
#endif
#define DEM_DESC_CONF3(EventId)  Dem_DTCDesc[Dem_GbiDTCConfIdx(EventId)].DTCConf2
#else
#define DEM_DESC_CONF3(EventId)  Dem_EventDesc[(EventId)].EvConf3
#endif

/** \brief Used for retrieving EnablePrestorage, IndicatorUsed and EventKind */
#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#if (defined DEM_DESC_CONF4)
#error DEM_DESC_CONF4 already defined
#endif
#define DEM_DESC_CONF4(EventId)  Dem_EventDesc[(EventId)].EvConf1
#else
#define DEM_DESC_CONF4(EventId)  Dem_EventDesc[(EventId)].EvConf1
#endif

/** \brief Used for retrieving OpCycleIdx */
#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#if (defined DEM_DESC_CONF5)
#error DEM_DESC_CONF5 already defined
#endif
#define DEM_DESC_CONF5(EventId)  Dem_EventDesc[(EventId)].EvConf1
#else
#define DEM_DESC_CONF5(EventId)  Dem_EventDesc[(EventId)].EvConf2
#endif

/** \brief Used for retrieving EventFailureClassIdx, EnCondGrpIdx, DebounceAlgo, DebounceIdx
 * and DebounceStatusIdx */
#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#if (defined DEM_DESC_CONF6)
#error DEM_DESC_CONF6 already defined
#endif
#define DEM_DESC_CONF6(EventId)  Dem_EventDesc[(EventId)].EvConf1
#else
#define DEM_DESC_CONF6(EventId)  Dem_EventDesc[(EventId)].EvConf3
#endif

/** \brief Used for retrieving MultiEventTriggeringClassIdx */
#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#if (defined DEM_DESC_CONF7)
#error DEM_DESC_CONF7 already defined
#endif
#define DEM_DESC_CONF7(EventId)  Dem_EventDesc[(EventId)].EvConf2
#else
#define DEM_DESC_CONF7(EventId)  Dem_EventDesc[(EventId)].EvConf4
#endif

/** \brief Used for retrieving ObdDTC, MinRatioEvent, ObdReadinessGroup */
#if (defined DEM_DESC_OBD_IDX)
#error DEM_DESC_OBD_IDX already defined
#endif
#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#define DEM_DESC_OBD_IDX(EventId)  Dem_GbiDTCConfIdx((EventId))
#else
#define DEM_DESC_OBD_IDX(EventId)  (EventId)
#endif

/** \brief Used for retrieving J1939DTC */
#if (defined DEM_DESC_J1939_IDX)
#error DEM_DESC_J1939_IDX already defined
#endif
#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#define DEM_DESC_J1939_IDX(EventId)  Dem_GbiDTCConfIdx((EventId))
#else
#define DEM_DESC_J1939_IDX(EventId)  (EventId)
#endif

/*------------------[Event description element offsets & masks]-------------*/

/* Independent values: offset, mask (only depends on static value widths) */

/* 1st 32 bits of event description layout */

#if (defined DEM_UDS_DTC_MASK)
#error DEM_UDS_DTC_MASK already defined
#endif
/** \brief Mask of DTC value in 1st element of event desc */
#define DEM_UDS_DTC_MASK             ((1UL << DEM_UDS_DTC_WIDTH) - 1UL)

#if (defined DEM_DTCORIGIN_MASK)
#error DEM_DTCORIGIN_MASK already defined
#endif
/** \brief Mask of DTC origin in 1st element of event desc */
#define DEM_DTCORIGIN_MASK           ((1UL << DEM_DTCORIGIN_WIDTH) - 1UL)

#if (defined DEM_DTCSEVERITY_MASK)
#error DEM_DTCSEVERITY_MASK already defined
#endif
/** \brief Mask of DTC severity in 1st element of event desc */
#define DEM_DTCSEVERITY_MASK         ((1UL << DEM_DTCSEVERITY_WIDTH) - 1UL)

#if (DEM_MAX_NUMBER_PRESTORED_FF > 0U)
#if (defined DEM_ENABLEPRESTORAGE_MASK)
#error DEM_ENABLEPRESTORAGE_MASK already defined
#endif
/** \brief Mask of Prestorage status in 1st element of event desc */
#define DEM_ENABLEPRESTORAGE_MASK    ((1UL << DEM_ENABLEPRESTORAGE_WIDTH) - 1UL)
#endif

#if (defined DEM_EVENTKIND_MASK)
#error DEM_EVENTKIND_MASK already defined
#endif
/** \brief Mask of Event kind in 1st element of event desc */
#define DEM_EVENTKIND_MASK           ((1UL << DEM_EVENTKIND_WIDTH) - 1UL)

#if (DEM_NUM_INDICATOR_LINKS > 0U)
#if (defined DEM_INDICATORUSED_MASK)
#error DEM_INDICATORUSED_MASK already defined
#endif
/** \brief Mask of Indicator status in 1st element of event desc */
#define DEM_INDICATORUSED_MASK       ((1UL << DEM_INDICATORUSED_WIDTH) - 1UL)
#endif

#if (defined DEM_IMMEDIATESTORAGE_MASK)
#error DEM_IMMEDIATESTORAGE_MASK already defined
#endif
/** \brief Mask of Immediate storage status in 1st element of event desc */
#define DEM_IMMEDIATESTORAGE_MASK    ((1UL << DEM_IMMEDIATESTORAGE_WIDTH) - 1UL)

#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#if (defined DEM_DTCCONFIDX_MASK )
#error DEM_DTCCONFIDX_MASK already defined
#endif
/** \brief Mask of DTCConfIdx in 1st element of event desc */
#define DEM_DTCCONFIDX_MASK     ((1UL << DEM_DTCCONFIDX_WIDTH) - 1UL)
#endif /* (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1) */

/* 2nd 32 bits of event description layout */

/* Dependent values: offset, mask (depends on configurable value width) */

#if (defined DEM_EVENTSIGNIFICANCE_MASK )
#error DEM_EVENTSIGNIFICANCE_MASK already defined
#endif
/** \brief  */
#define DEM_EVENTSIGNIFICANCE_MASK     ((1UL << DEM_EVENTSIGNIFICANCE_WIDTH) - 1UL)

#if (defined DEM_FFCLASSIDX_MASK)
#error DEM_FFCLASSIDX_MASK already defined
#endif
/** \brief Mask of FF class index in 2nd element of event desc */
#define DEM_FFCLASSIDX_MASK          ((1UL << DEM_FFCLASSIDX_WIDTH) - 1UL)

#if (defined DEM_FFRECINFO_MASK)
#error DEM_FFRECINFO_MASK already defined
#endif
/** \brief Mask of maximum FF number (if record numeration type is calculated)
 ** or index to freeze frame record numeration class (if record numeration
 ** type is configured) in 2nd element of event desc
 */
#define DEM_FFRECINFO_MASK           ((1UL << DEM_FFRECINFO_WIDTH) - 1UL)

#if (defined DEM_EDCLASSIDX_MASK)
#error DEM_EDCLASSIDX_MASK already defined
#endif
/** \brief Mask of ED class index in 2nd element of event desc */
#define DEM_EDCLASSIDX_MASK          ((1UL << DEM_EDCLASSIDX_WIDTH) - 1UL)

#if (defined DEM_OPCYCLEIDX_MASK)
#error DEM_OPCYCLEIDX_MASK already defined
#endif
/** \brief Mask of Operation cycle index in 2nd element of event desc */
#define DEM_OPCYCLEIDX_MASK          ((1UL << DEM_OPCYCLEIDX_WIDTH) - 1UL)

#if (defined DEM_AGINGCTRTHRESHOLD_MASK)
#error DEM_AGINGCTRTHRESHOLD_MASK already defined
#endif
/** \brief Mask of Aging cycle in 2nd element of event desc */
#define DEM_AGINGCTRTHRESHOLD_MASK         ((1UL << DEM_AGINGCTRTHRESHOLD_WIDTH) - 1UL)

#if (defined DEM_DTCGROUP_MASK)
#error DEM_DTCGROUP_MASK already defined
#endif
/** \brief Mask of DTC group in 2nd element of event desc */
#define DEM_DTCGROUP_MASK            ((1UL << DEM_DTCGROUP_WIDTH) - 1UL)

#if (defined DEM_EVENTCLASSDESCIDX_MASK)
#error DEM_EVENTCLASSDESCIDX_MASK already defined
#endif
/** \brief Mask of Event class index in 3nd element of event desc */
#define DEM_EVENTCLASSDESCIDX_MASK          ((1UL << DEM_EVENTCLASSDESCIDX_WIDTH) - 1UL)

/* 3rd 32 bits of event description layout */

#if (defined DEM_ENCONDIDX_MASK)
#error DEM_ENCONDIDX_MASK already defined
#endif
/** \brief Mask of Enable condition index in 3rd element of event desc */
#define DEM_ENCONDIDX_MASK           ((1UL << DEM_ENCONDIDX_WIDTH) - 1UL)

#if (defined DEM_ENCONDGRPIDX_MASK)
#error DEM_ENCONDGRPIDX_MASK already defined
#endif
/** \brief Mask of Enable condition group index in 3rd element of event desc */
#define DEM_ENCONDGRPIDX_MASK           ((1UL << DEM_ENCONDGRPIDX_WIDTH) - 1UL)

#if (defined DEM_MULTIEVENTTRIGGERINGIDX_MASK)
#error DEM_MULTIEVENTTRIGGERINGIDX_MASK already defined
#endif
/** \brief Mask of multi event triggering index element of event desc */
#define DEM_MULTIEVENTTRIGGERINGIDX_MASK    ((1UL << DEM_MULTIEVENTTRIGGERINGIDX_WIDTH) - 1UL)

#if (defined DEM_EVENTFAILURECLASSIDX_MASK)
#error DEM_EVENTFAILURECLASSIDX_MASK already defined
#endif
/** \brief Mask of Event failure class index in 3rd element of event desc */
#define DEM_EVENTFAILURECLASSIDX_MASK   ((1UL << DEM_EVENTFAILURECLASSIDX_WIDTH) - 1UL)

#if (defined DEM_PRIORITY_MASK)
#error DEM_PRIORITY_MASK already defined
#endif
/** \brief Mask of Internal priority in 3rd element of event desc */
#define DEM_PRIORITY_MASK            ((1UL << DEM_PRIORITY_WIDTH) - 1UL)

#if (defined DEM_DEBOUNCEALGO_MASK)
#error DEM_DEBOUNCEALGO_MASK already defined
#endif
/** \brief Mask of Debounce algorithm in 3rd element of event desc */
#define DEM_DEBOUNCEALGO_MASK        ((1UL << DEM_DEBOUNCEALGO_WIDTH) - 1UL)

#if (defined DEM_DEBOUNCEIDX_MASK)
#error DEM_DEBOUNCEIDX_MASK already defined
#endif
/** \brief Mask of Debounce algorithm index in 3rd element of event desc */
#define DEM_DEBOUNCEIDX_MASK         ((1UL << DEM_DEBOUNCEIDX_WIDTH) - 1UL)

#if (defined DEM_DTCFUNCTIONALUNIT_MASK)
#error DEM_DTCFUNCTIONALUNIT_MASK already defined
#endif
/** \brief Mask of DTC functional unit in 3rd element of event desc */
#define DEM_DTCFUNCTIONALUNIT_MASK   ((1UL << DEM_DTCFUNCTIONALUNIT_WIDTH) - 1UL)

#if (defined DEM_AGINGCYCLEIDX_MASK)
#error DEM_AGINGCYCLEIDX_MASK already defined
#endif
/** \brief Mask of Aging cycle index in 3rd element of event desc */
#define DEM_AGINGCYCLEIDX_MASK       ((1UL << DEM_AGINGCYCLEIDX_WIDTH) - 1UL)

#if (DEM_USE_CB_CLEAR_EVENT_ALLOWED == STD_ON)

#if (defined DEM_NO_STATUS_BYTE_CHANGE)
#error DEM_NO_STATUS_BYTE_CHANGE already defined
#endif
/** \brief Clear Event Allowed behavior macros */
/* if an event has this option configured then no bits will be reset when
 * Dem_CbClearEventAllowed returns E_OK and Allowed parameter is false */
#define DEM_NO_STATUS_BYTE_CHANGE         0x00U

#if (defined DEM_ONLY_THIS_CYCLE_AND_READINESS)
#error DEM_ONLY_THIS_CYCLE_AND_READINESS already defined
#endif
/* if this option is set, when Dem_CbClearEventAllowed returns E_OK and Allowed
 * parameter is false, Only this cycle and readiness bits will be cleared */
#define DEM_ONLY_THIS_CYCLE_AND_READINESS 0x8000U

#if (defined DEM_EVENT_ID_MASK_FOR_CLEAREV_BEHAVIOR )
#error DEM_EVENT_ID_MASK_FOR_CLEAREV_BEHAVIOR  already defined
#endif
/* to improve run time a dedicated mask with the value of the Complemented mask
 * is used */
#define DEM_EVENT_ID_MASK_FOR_CLEAREV_BEHAVIOR  0x7FFFU

#if (defined DEM_CLEAREV_BEHAVIOR_GET_EVENT_ID)
#error DEM_CLEAREV_BEHAVIOR_GET_EVENT_ID already defined
#endif
/* macro to extract an event id from a packed event id */
#define DEM_CLEAREV_BEHAVIOR_GET_EVENT_ID(PackedId)  ((PackedId) & (Dem_EventIdType)DEM_EVENT_ID_MASK_FOR_CLEAREV_BEHAVIOR)

#if (defined DEM_CLEAREV_BEHAVIOR_GET_BEHAVIOR)
#error DEM_CLEAREV_BEHAVIOR_GET_BEHAVIOR already defined
#endif
/* macro to extract clear event behavior from a packed event id */
#define DEM_CLEAREV_BEHAVIOR_GET_BEHAVIOR(PackedId)  ((PackedId) & DEM_ONLY_THIS_CYCLE_AND_READINESS)

#endif

/*------------------[Event Class]-------------------------------------------*/

#if (DEM_CALIBRATION_SUPPORT == STD_ON)
#if (defined DEM_GBI_EVENTCLASSDESCIDX)
#error DEM_GBI_EVENTCLASSDESCIDX already defined
#endif
/** \brief Returns the event class index
 *   Shall only be used by Dem_Gbi...() functions
 */
#define DEM_GBI_EVENTCLASSDESCIDX(EventId) \
  DEM_BIT_FIELD_VALUE_32( \
    Dem_EventDesc[(EventId)].EvConf2, \
    DEM_EVENTCLASSDESCIDX_OFFSET, \
    DEM_EVENTCLASSDESCIDX_MASK)
#endif

/* !LINKSTO Dem.EB.EventClass.FreezeFrameUpdate,1 */
#if (defined DEM_FFUPDATEEVENTCLASS_OFFSET)
#error DEM_FFUPDATEEVENTCLASS_OFFSET already defined
#endif
/** \brief Offset of FreezeFrameUpdate in Dem_EventClassDesc[].Bitfield
 *
 *  Used only if DEM_FREEZE_FRAME_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD
 */
#define DEM_FFUPDATEEVENTCLASS_OFFSET  1U

#if (defined DEM_FFUPDATEEVENTCLASS_MASK)
#error DEM_FFUPDATEEVENTCLASS_MASK already defined
#endif
/** \brief Mask of FreezeFrameUpdate in Dem_EventClassDesc[].Bitfield
 *
 *  Used only if DEM_FREEZE_FRAME_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD
 */
#define DEM_FFUPDATEEVENTCLASS_MASK  1U

#if (defined DEM_FFUPDATEEVENTCLASS_WIDTH)
#error DEM_FFUPDATEEVENTCLASS_WIDTH already defined
#endif
/** \brief Width of FreezeFrameUpdate in Dem_EventClassDesc[].Bitfield
 *
 *  Used only if DEM_FREEZE_FRAME_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD
 */
#define DEM_FFUPDATEEVENTCLASS_WIDTH    1U

/*------------------[Fault confirmation]------------------------------------*/

#if (defined DEM_INTERN_EVT_FAILCYC_CTR_THRESHOLD)
#error DEM_INTERN_EVT_FAILCYC_CTR_THRESHOLD is already defined
#endif
/** \brief Implementation-specific event failure cycle counter threshold
 **
 ** Note: The internal failure cycle counter is the same as the event failure
 ** cycle counter threshold which is configured.
 **/
#if (DEM_EVENTCLASS_SUPPORT == STD_OFF)
#define DEM_INTERN_EVT_FAILCYC_CTR_THRESHOLD(EventId, EventFailureClassIdx) \
  (Dem_EventFailureCycleCfg[(EventFailureClassIdx)].EventFailureCycleCounterThreshold)
#else
#define DEM_INTERN_EVT_FAILCYC_CTR_THRESHOLD(EventId, EventFailureClassIdx) \
  (Dem_EventClassDesc[DEM_GBI_EVENTCLASSDESCIDX(EventId)].EventFailureCycleCounterThreshold)
#endif

#if (defined DEM_STATUS_COUNTER_INDEX_SIZE)
#error DEM_STATUS_COUNTER_INDEX_SIZE is already defined
#endif
/** \brief Size of index table used to access the status counter entries
 ** in ::Dem_NvData.StatusCounter[] */
#define DEM_STATUS_COUNTER_INDEX_SIZE \
  ( (DEM_NUMBER_OF_EVENTS + (DEM_STATUS_COUNTER_GROUP_SIZE - 1U)) \
      / DEM_STATUS_COUNTER_GROUP_SIZE )

#if (defined DEM_IS_CYCLE_QUALIFIED)
#error DEM_IS_CYCLE_QUALIFIED is already defined
#endif
/** \brief Returns if the given operation cycle is qualified
 ** Note: Always returns true, if the given cycle is not the driving cycle. */
#if (DEM_OPCYC_OBD_DCY_USED == STD_ON)
#define DEM_IS_CYCLE_QUALIFIED(CycleId) \
  (((CycleId) != DEM_OPCYC_OBD_DCY_ID) ? TRUE : Dem_NvData.Dem_OpCycleDCYIsQualified)
#else
#define DEM_IS_CYCLE_QUALIFIED(CycleId) TRUE
#endif

#if (DEM_OPCYC_OBD_DCY_USED == STD_ON)
#if (defined DEM_RESET_DCY_QUALIFICATION)
#error DEM_RESET_DCY_QUALIFICATION is already defined
#endif
/** \brief Macro to reset the driving cycle qualification status */
#define DEM_RESET_DCY_QUALIFICATION() (Dem_NvData.Dem_OpCycleDCYIsQualified = FALSE)
#endif

/*------------------[OBD configuration element offsets & masks]-------------*/

/* !LINKSTO Dem_OBD_0001,2 */
#if (DEM_OBD_Support == STD_ON)
#if (defined DEM_MINRATIOEVENT_OFFSET)
#error DEM_MINRATIOEVENT_OFFSET already defined
#endif
/** \brief Offset of Min Ratio Event in Dem_OBDConfig.Dem_OBDEvConf1
 *  used if DEM_EVENTCLASS_SUPPORT == STD_OFF
 */
#define DEM_MINRATIOEVENT_OFFSET    0U

#if (defined DEM_MINRATIOEVENT_MASK)
#error DEM_MINRATIOEVENT_MASK already defined
#endif
/** \brief Mask of Min Ratio Event in Dem_OBDConfig.Dem_OBDEvConf1
 *  used if DEM_EVENTCLASS_SUPPORT == STD_OFF
 */
#define DEM_MINRATIOEVENT_MASK    1U

#if (defined DEM_MINRATIOEVENT_WIDTH)
#error DEM_MINRATIOEVENT_WIDTH already defined
#endif
/** \brief Width of Min Ratio Event in Dem_OBDConfig.Dem_OBDEvConf1
 *  used if DEM_EVENTCLASS_SUPPORT == STD_OFF
 */
#define DEM_MINRATIOEVENT_WIDTH    1U

#if (defined DEM_MINRATIOEVENTCLASS_OFFSET)
#error DEM_MINRATIOEVENTCLASS_OFFSET already defined
#endif
/** \brief Offset of Min Ratio Event in Dem_EventClassDesc[].Bitfield
  * used if DEM_EVENTCLASS_SUPPORT == STD_ON
  */
#define DEM_MINRATIOEVENTCLASS_OFFSET    0U

#if (defined DEM_MINRATIOEVENTCLASS_MASK)
#error DEM_MINRATIOEVENTCLASS_MASK already defined
#endif
/** \brief Mask of Min Ratio Event in Dem_EventClassDesc[].Bitfield
 *  used if DEM_EVENTCLASS_SUPPORT == STD_ON
 */
#define DEM_MINRATIOEVENTCLASS_MASK    1U

#if (defined DEM_MINRATIOEVENTCLASS_WIDTH)
#error DEM_MINRATIOEVENTCLASS_WIDTH already defined
#endif
/** \brief Width of Min Ratio Event in Dem_EventClassDesc[].Bitfield
 * used if DEM_EVENTCLASS_SUPPORT == STD_ON
 */
#define DEM_MINRATIOEVENTCLASS_WIDTH  1U

#if (defined DEM_OBD_READINESS_MASK)
#error DEM_OBD_READINESS_MASK already defined
#endif
/** \brief Mask of ReadinessGroup */
#define DEM_OBD_READINESS_MASK          0x0FU

#if (defined DEM_OBD_READINESS_WIDTH)
#error DEM_OBD_READINESS_WIDTH already defined
#endif
/** \brief Width of ReadinessGroup in Dem_OBDConfig.Dem_OBDEvConf1 */
#if (DEM_MAX_EVENTS_PER_READINESS_GROUP == 0U)
#define DEM_OBD_READINESS_WIDTH  4U
#else
#define DEM_OBD_READINESS_WIDTH  0U
#endif

#if (defined DEM_OBD_AGING_CYC_CNT_THRESHOLD_MASK)
#error DEM_OBD_AGING_CYC_CNT_THRESHOLD_MASK already defined
#endif
/** \brief Mask of DemOBDAgingCycleCounterThreshold in Dem_OBDConfig.Dem_OBDEvConf1 */
#define DEM_OBD_AGING_CYC_CNT_THRESHOLD_MASK         0xFFU

#if (defined DEM_OBD_AGING_CYC_CNT_THRESHOLD_WIDTH)
#error DEM_OBD_AGING_CYC_CNT_THRESHOLD_WIDTH already defined
#endif
/** \brief Width of DemOBDAgingCycleCounterThreshold in Dem_OBDConfig.Dem_OBDEvConf1 */
#define DEM_OBD_AGING_CYC_CNT_THRESHOLD_WIDTH         8U

#endif /* (DEM_OBD_Support == STD_ON) */

/*------------------[Development freeze frames]-----------------------------*/

#if (defined DEM_COMMON_DEVFF_A_CLASS_IDX)
#error DEM_COMMON_DEVFF_A_CLASS_IDX already defined
#endif
/** \brief Define for common part of development freeze frame A */
#if (DEM_COMMON_FREEZEFRAMES_USED == STD_ON)
#define DEM_COMMON_DEVFF_A_CLASS_IDX  Dem_CommonPartFFClassIdx[DEM_DEVFF_A]
#else
#define DEM_COMMON_DEVFF_A_CLASS_IDX  DEM_COMMON_DEVFFA_CLASS_IDX
#endif

#if ((DEM_MAX_NUMBER_DEVFFA_ENTRY > 0U) || (DEM_MAX_NUMBER_DEVFFB_ENTRY > 0U))
#if (defined DEM_DEVFF_VALID_RECNUM)
#error DEM_DEVFF_VALID_RECNUM already defined
#endif
/** \brief Verify only the record number validity for development freeze frame A and B */
/* !LINKSTO dsn.Dem.DevFF.Validation.RecordNumber,1 */
#define DEM_DEVFF_VALID_RECNUM(DTCOrigin, FFKind, EventId, RecordNumber) \
  ( ((DTCOrigin) == DEM_DTC_ORIGIN_PRIMARY_MEMORY) && \
    (Dem_EventDescDevFF[(EventId)][(FFKind)].DevFFNum == (RecordNumber)) && \
    ((RecordNumber) != (0U)) \
  )

#if (defined DEM_DEVFF_VALID_FFCLASS)
#error DEM_DEVFF_VALID_FFCLASS already defined
#endif
/** \brief Verify only the record number validity for development freeze frame A and B */
/* !LINKSTO dsn.Dem.DevFF.Validation.FFClass,1 */
#define DEM_DEVFF_VALID_FFCLASS(FFKind, EventId) \
  ( ( ((FFKind) == DEM_DEVFF_A) && \
        (DEM_COMMON_DEVFF_A_CLASS_IDX != DEM_FFCLS_NULL_IDX) ) || \
      (Dem_EventDescDevFF[(EventId)][(FFKind)].DevFFClassIdx != DEM_FFCLS_NULL_IDX) )
#endif

#if (defined DEM_DEVFF_VALID)
#error DEM_DEVFF_VALID already defined
#endif
/** \brief Verify record number validity and DevFFClassIdx for development freeze frame A and B */
/* !LINKSTO dsn.Dem.DevFF.Validation.RecordNumberAndFFClass,1 */
#if ((DEM_MAX_NUMBER_DEVFFA_ENTRY > 0U) || (DEM_MAX_NUMBER_DEVFFB_ENTRY > 0U))
#define DEM_DEVFF_VALID(DTCOrigin, FFKind, EventId, RecordNumber) \
  ( (DEM_DEVFF_VALID_RECNUM((DTCOrigin), (FFKind), (EventId), (RecordNumber))) && \
    (DEM_DEVFF_VALID_FFCLASS((FFKind), (EventId))) \
  )
#else
#define DEM_DEVFF_VALID(DTCOrigin, FFKind, EventId, RecordNumber) (0 == 1)
#endif

/*------------------[Regular Freeze Frame]----------------------------------*/

#if (defined DEM_REGULAR_FF_VALID_FFCLASS)
#error DEM_REGULAR_FF_VALID_FFCLASS already defined
#endif
/** \brief Verify that an event has assigned at least one FreezeFrame Class
 **  assigned (individual or common) */
 /* !LINKSTO dsn.Dem.RegularFF.Validation.FFClass,1 */
#if (DEM_COMMON_FREEZEFRAMES_USED == STD_ON)
#define DEM_REGULAR_FF_VALID_FFCLASS(EventId) \
  ( (Dem_GbiFFClassIdx((EventId)) != DEM_FFCLS_NULL_IDX) || \
    (Dem_CommonPartFFClassIdx[DEM_REGULAR_FF] != DEM_FFCLS_NULL_IDX) )
#else
#define DEM_REGULAR_FF_VALID_FFCLASS(EventId) \
  (Dem_GbiFFClassIdx((EventId)) != DEM_FFCLS_NULL_IDX)
#endif

#if (defined DEM_REGULAR_FF_VALID_RECNUM)
#error DEM_REGULAR_FF_VALID_RECNUM already defined
#endif
/** \brief Verify that an event has a valid RecordNumber assigned */
/* !LINKSTO dsn.Dem.RegularFF.Validation.RecordNumber,1 */
#define DEM_REGULAR_FF_VALID_RECNUM(EventId, RecordNumber) \
  ( Dem_CheckFFRecNumValid((EventId), (RecordNumber)) == TRUE )

#if (defined DEM_REGULAR_FF_VALID)
#error DEM_REGULAR_FF_VALID already defined
#endif
/** \brief Verify that an event has a valid Regular FF assigned (at least one
 **  FreezeFrame Class assigned individual or common, and a valid record number) */
/* !LINKSTO dsn.Dem.RegularFF.Validation.RecordNumberAndFFClass,1 */
#if (DEM_CALIBRATION_SUPPORT == STD_ON)
#define DEM_REGULAR_FF_VALID(EventId, RecordNumber) \
  ( (DEM_REGULAR_FF_VALID_RECNUM(EventId, RecordNumber)) && \
    (DEM_REGULAR_FF_VALID_FFCLASS((EventId))) )
#else
#define DEM_REGULAR_FF_VALID(EventId, RecordNumber) \
  ( DEM_REGULAR_FF_VALID_RECNUM(EventId, RecordNumber) )
#endif

#if (defined DEM_MIN_FF_RECORD_NUM)
#error DEM_MIN_FF_RECORD_NUM already defined
#endif
/** \brief Minimum value that can be assigned to a FF record
 **
 ** OBD FF (Record number 0x00U), is supported only if OBD is enabled */
#if (DEM_OBD_Support == STD_ON)
#define DEM_MIN_FF_RECORD_NUM                         0x00U
#else
#define DEM_MIN_FF_RECORD_NUM                         0x01U
#endif

/*--------------------------------------------------------------------------*/

#if (defined DEM_MAX_CLIENTID)
#error DEM_MAX_CLIENTID already defined
#endif
/** \brief ID assigned to the last diagnostic client */
#define DEM_MAX_CLIENTID                 (DEM_NUMBER_OF_CLIENTS - 1U)

#if (defined DEM_NUMBER_OF_SW_UNITS)
#error DEM_NUMBER_OF_SW_UNITS already defined
#endif
/** \brief Number of sw-units initialized with Dem_InitSwUnitFncPtr[] */
#define DEM_NUMBER_OF_SW_UNITS           7U

#if (defined DEM_MAX_EVENTID)
#error DEM_MAX_EVENTID already defined
#endif
/** \brief largest event Id configured in Dem */
#define DEM_MAX_EVENTID                  (DEM_NUMBER_OF_EVENTS - 1U)

#if (defined DEM_NVM_SID_WriteBlock)
#error DEM_NVM_SID_WriteBlock already defined
#endif
/** \brief Service Id of NvM_WriteBlock() */
#define DEM_NVM_SID_WriteBlock           0x07U

#if (defined DEM_NVM_SID_WriteAll)
#error DEM_NVM_SID_WriteAll already defined
#endif
/** \brief Service Id of NvM_WriteAll() */
#define DEM_NVM_SID_WriteAll             0x0DU

/*--------------------------------------------------------------------------*/

#if (defined DEM_NVM_NO_FORCE)
#error DEM_NVM_NO_FORCE already defined
#endif
/** \brief Nv storage limit: Do not force immediate storage */
#define DEM_NVM_NO_FORCE FALSE

#if (defined DEM_NVM_FORCE)
#error DEM_NVM_FORCE already defined
#endif
/** \brief Nv storage limit: Force immediate storage
 **
 ** Immediate storage will be performed for events with immediate storage
 ** disabed, also if limit was reached already. */
#define DEM_NVM_FORCE    TRUE

#if (defined DEM_EVENT_STATUS_UNCONFIRMED)
#error DEM_EVENT_STATUS_UNCONFIRMED already defined
#endif
/** \brief Internal event status "unconfirmed"
 **
 ** This macro is an internal extension of the type ::Dem_EventStatusType.
 **/
#define DEM_EVENT_STATUS_UNCONFIRMED      0x04U

#if (defined DEM_EVENT_STATUS_CONFIRMED)
#error DEM_EVENT_STATUS_CONFIRMED already defined
#endif
/** \brief Internal event status "confirmed"
 **
 ** This macro is an internal extension of the type ::Dem_EventStatusType.
 **/
#define DEM_EVENT_STATUS_CONFIRMED      0x05U

/*------------------[Common Freeze Frame]-----------------------------------*/

#if (defined DEM_NUM_FFKINDS)
#error DEM_NUM_FFKINDS already defined
#endif
/** \brief The number used for defining the size of Dem_CommonPartFFClassIdx array */
#define DEM_NUM_FFKINDS      3U

/*------------------[Common ED and FF and J1939FF Segments]-----------------*/
#if (defined DEM_ED_OR_FF_OR_J1939FF_CONFIGURED)
#error DEM_ED_OR_FF_OR_J1939FF_CONFIGURED already defined
#endif
/** \brief Macro to retrieve info if at least one ED, FF or J1939FF segment is configured.
 **
 ** In case of J1939 also the J1939 FF support switch, which
 ** enables the corresponding APIs, has to be considered.
 **/
#if ( (DEM_NUM_EDSEGS > 0U)              ||                                    \
      (DEM_NUM_FFSEGS > 0U)              ||                                    \
      ((DEM_NUM_J1939FFSPNS > 0U) && (DEM_J1939_FREEZEFRAME_SUPPORT == STD_ON))\
    )
#define DEM_ED_OR_FF_OR_J1939FF_CONFIGURED      STD_ON
#else
#define DEM_ED_OR_FF_OR_J1939FF_CONFIGURED      STD_OFF
#endif

#if (defined DEM_TRIG_CB_ON_EVDAT)
#error DEM_TRIG_CB_ON_EVDAT already defined
#endif
/** \brief Macro to determine if EventDataChanged callback shall be triggered. */
#if ( (DEM_USE_CB_TRIG_ON_EVDAT == STD_ON) && \
      (DEM_ED_OR_FF_OR_J1939FF_CONFIGURED == STD_ON) )
#define DEM_TRIG_CB_ON_EVDAT      STD_ON
#else
#define DEM_TRIG_CB_ON_EVDAT      STD_OFF
#endif

/*------------------[Debounce Counter Storage]------------------------------*/

#if (defined DEM_DEBOUNCE_CLASS_INVALID)
#error DEM_DEBOUNCE_CLASS_INVALID already defined
#endif
/** \brief Macro for events without debounce class.
 **
 ** This macro is equal to the maximum number of configured counter based debounce classes.
 ** Debounce counter based class indexes cannot be bigger than
 ** DEM_NUM_DEBOUNCE_COUNTER_CLASSES - 1U
 **/
#define DEM_DEBOUNCE_CLASS_INVALID        (DEM_NUM_DEBOUNCE_COUNTER_CLASSES)


#if (defined DEM_TIME_DEBOUNCE_CLASS_INVALID)
#error DEM_TIME_DEBOUNCE_CLASS_INVALID already defined
#endif
/** \brief Macro for events without debounce class.
 **
 ** This macro is equal to the maximum number of configured time based debounce classes.
 ** Debounce Time based class indexes cannot be bigger than
 ** DEM_TIME_DEBOUNCE_CLASS_INVALID - 1U
 **/
#define DEM_TIME_DEBOUNCE_CLASS_INVALID        (DEM_NUM_DEBOUNCE_TIME_CLASSES)

#if (defined DEM_DEBOUNCE_COUNTER_NVSTORAGE_MASK)
#error DEM_DEBOUNCE_COUNTER_NVSTORAGE_MASK already defined
#endif
/** \brief Mask to get debounce counter storage flag */
#if (DEM_NUM_DEBOUNCE_COUNTER_CLASSES <= 127U)
#define DEM_DEBOUNCE_COUNTER_NVSTORAGE_MASK         0x80U
#else
#define DEM_DEBOUNCE_COUNTER_NVSTORAGE_MASK         0x8000U
#endif

#if (defined DEM_DEBOUNCE_COUNTER_NVSTORAGE_SUPPORT)
#error DEM_DEBOUNCE_COUNTER_NVSTORAGE_SUPPORT already defined
#endif
/** \brief Macro to determine if debounce counter has storage support */
#define DEM_DEBOUNCE_COUNTER_NVSTORAGE_SUPPORT(Idx)                                    \
  ((Dem_DebounceCounterClassIdx[(Idx)] & DEM_DEBOUNCE_COUNTER_NVSTORAGE_MASK) == 0U ?  \
                                                                 FALSE : TRUE)

/*------------------[Bits for job mask of Dem_ProcessEvent]-----------------*/
#if (defined DEM_PROCESSEVENT_STATUSUPDATE)
#error DEM_PROCESSEVENT_STATUSUPDATE already defined
#endif
#define DEM_PROCESSEVENT_STATUSUPDATE           0x01U

#if (defined DEM_PROCESSEVENT_INDICATORUPDATE)
#error DEM_PROCESSEVENT_INDICATORUPDATE already defined
#endif
#define DEM_PROCESSEVENT_INDICATORUPDATE        0x02U

#if (defined DEM_PROCESSEVENT_ENTRYUPDATE)
#error DEM_PROCESSEVENT_ENTRYUPDATE already defined
#endif
#define DEM_PROCESSEVENT_ENTRYUPDATE            0x04U

#if (defined DEM_PROCESSEVENT_OBDENTRYUPDATE)
#error DEM_PROCESSEVENT_OBDENTRYUPDATE already defined
#endif
#define DEM_PROCESSEVENT_OBDENTRYUPDATE         0x08U

/*-------------[Functions IDs for Dem_InternalProcessEventReport]-----------*/
#if (defined DEM_FID_INTERNALSETEVENTSTATUS)
#error DEM_FID_INTERNALSETEVENTSTATUS already defined
#endif
#define DEM_FID_INTERNALSETEVENTSTATUS 0x01U

#if (defined DEM_FID_REPORTERRORSTATUSPREINIT)
#error DEM_FID_REPORTERRORSTATUSPREINIT already defined
#endif
#define DEM_FID_REPORTERRORSTATUSPREINIT 0x02U

/*------------------[DTC record update]-------------------------------------*/

#if (defined DEM_RECORD_UPDATE_LOCKED)
#error DEM_RECORD_UPDATE_LOCKED already defined
#endif
/** \brief Checks if DTC record update is locked for the current event */
#define DEM_RECORD_UPDATE_LOCKED(EventId) \
  (DEM_GET_MASTER_EVID(EventId) == Dem_EvIdOfLockedMemoryEntry)

/*------------------[ClearDTC]----------------------------------------------*/

#if (defined DEM_IS_CLEAR_IN_PROGRESS)
#error DEM_IS_CLEAR_IN_PROGRESS already defined
#endif
/** \brief Checks if the ClearDTC operation still processes RAM entries */
#define DEM_IS_CLEAR_IN_PROGRESS() \
  (DEM_CLEARDTC_STATE_PROCESSING_RAM == Dem_ClearDtcAsyncStatus.RunState)

#if (defined DEM_MAX_NUM_CHECK_CLEAR_EVENTS_PER_CYCLE)
#error DEM_MAX_NUM_CHECK_CLEAR_EVENTS_PER_CYCLE already defined
#endif
/** \brief Maximum number of checked events to be cleared per
 ** Dem_MainFunction() cycle on a ClearDTC request
 **
 ** Its value should be at least ::DEM_MAX_NUM_CLEAR_EVENTS_PER_CYCLE and
 ** not more than ::DEM_NUMBER_OF_EVENTS. */
#if (DEM_MAX_NUM_CLEAR_EVENTS_PER_CYCLE > DEM_NUMBER_OF_EVENTS)
#define DEM_MAX_NUM_CHECK_CLEAR_EVENTS_PER_CYCLE DEM_NUMBER_OF_EVENTS
#else
#if (DEM_MAX_NUM_CLEAR_EVENTS_PER_CYCLE > 128U)
#define DEM_MAX_NUM_CHECK_CLEAR_EVENTS_PER_CYCLE DEM_MAX_NUM_CLEAR_EVENTS_PER_CYCLE
#elif (DEM_NUMBER_OF_EVENTS < 128U)
#define DEM_MAX_NUM_CHECK_CLEAR_EVENTS_PER_CYCLE DEM_NUMBER_OF_EVENTS
#else
#define DEM_MAX_NUM_CHECK_CLEAR_EVENTS_PER_CYCLE 128U
#endif
#endif

/*----------------------[Permanent Memory entry status]---------------------*/

/* !LINKSTO Dem_OBD_0005,1 */
#if (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U)
#if (defined DEM_PERMANENT_MEMORY_EVENT_ID_MASK)
#error DEM_PERMANENT_MEMORY_EVENT_ID_MASK already defined
#endif
/** \brief Mask value for the EventId stored in the permanent memory entry
 ** (bits 0-12) */
#define DEM_PERMANENT_MEMORY_EVENT_ID_MASK                       0x1FFFU

#if (defined DEM_PERMANENT_MEMORY_PFC_CYCLE_COND_MASK)
#error DEM_PERMANENT_MEMORY_PFC_CYCLE_COND_MASK already defined
#endif
/** \brief Mask value for the "Pfc Cycle" flag of the permanent memory entry
 ** (bit 13) */
#define DEM_PERMANENT_MEMORY_PFC_CYCLE_COND_MASK                 0x2000U

#if (defined DEM_PERMANENT_MEMORY_PASSED_CYCLE_COND_MASK)
#error DEM_PERMANENT_MEMORY_PASSED_CYCLE_COND_MASK already defined
#endif
/** \brief Mask value for the "Passed Cycle" flag of the permanent memory
 ** entry (bit 14) */
#define DEM_PERMANENT_MEMORY_PASSED_CYCLE_COND_MASK              0x4000U

#if (defined DEM_SET_PERMANENT_MEMORY_EVENT_ID)
#error DEM_SET_PERMANENT_MEMORY_EVENT_ID already defined
#endif
/** \brief Macro to update the event Id of the permanent event memory entry */
#define DEM_SET_PERMANENT_MEMORY_EVENT_ID(Entry, EventId)                \
  do                                                                     \
  {                                                                      \
    DEM_CLR_MASK_16((Entry), DEM_PERMANENT_MEMORY_EVENT_ID_MASK);        \
    DEM_SET_MASK((Entry), (EventId));                                    \
  } while (0)

#if (defined DEM_GET_PERMANENT_MEMORY_EVENT_ID)
#error DEM_GET_PERMANENT_MEMORY_EVENT_ID already defined
#endif
/** \brief Macro to get the event Id of the permanent event memory entry */
#define DEM_GET_PERMANENT_MEMORY_EVENT_ID(Entry)                         \
  ((Dem_EventIdType)((Entry) & DEM_PERMANENT_MEMORY_EVENT_ID_MASK))

#if (defined DEM_SET_PERMANENT_MEMORY_PFC_CYCLE_COND)
#error DEM_SET_PERMANENT_MEMORY_PFC_CYCLE_COND already defined
#endif
/** \brief Macro to mark that "Pfc Cycle" condition to erase the permanent
 ** DTC after ClearDTC is satisfied (or is not relevant) */
#define DEM_SET_PERMANENT_MEMORY_PFC_CYCLE_COND(Entry)                   \
  DEM_SET_MASK((Entry), DEM_PERMANENT_MEMORY_PFC_CYCLE_COND_MASK)

#if (defined DEM_CLR_PERMANENT_MEMORY_PFC_CYCLE_COND)
#error DEM_CLR_PERMANENT_MEMORY_PFC_CYCLE_COND already defined
#endif
/** \brief Macro to mark that "Pfc Cycle" condition to erase the permanent
 ** DTC after ClearDTC is not satisfied */
#define DEM_CLR_PERMANENT_MEMORY_PFC_CYCLE_COND(Entry)                   \
  DEM_CLR_MASK_16((Entry), DEM_PERMANENT_MEMORY_PFC_CYCLE_COND_MASK)

#if (defined DEM_GET_PERMANENT_MEMORY_PFC_CYCLE_COND)
#error DEM_GET_PERMANENT_MEMORY_PFC_CYCLE_COND already defined
#endif
/** \brief Macro to check whether "Pfc Cycle" condition to erase the
 ** permanent DTC after ClearDTC is satisfied */
#define DEM_GET_PERMANENT_MEMORY_PFC_CYCLE_COND(Entry)                   \
  DEM_IS_BIT_SET((Entry), DEM_PERMANENT_MEMORY_PFC_CYCLE_COND_MASK)

#if (defined DEM_SET_PERMANENT_MEMORY_PASSED_CYCLE_COND)
#error DEM_SET_PERMANENT_MEMORY_PASSED_CYCLE_COND already defined
#endif
/** \brief Macro to mark that "Passed Cycle" condition to erase the permanent
 ** DTC after ClearDTC is satisfied */
#define DEM_SET_PERMANENT_MEMORY_PASSED_CYCLE_COND(Entry)                \
  DEM_SET_MASK((Entry), DEM_PERMANENT_MEMORY_PASSED_CYCLE_COND_MASK)

#if (defined DEM_CLR_PERMANENT_MEMORY_PASSED_CYCLE_COND)
#error DEM_CLR_PERMANENT_MEMORY_PASSED_CYCLE_COND already defined
#endif
/** \brief Macro to mark that "Passed Cycle" condition to erase the permanent
 ** DTC after ClearDTC is not satisfied */
#define DEM_CLR_PERMANENT_MEMORY_PASSED_CYCLE_COND(Entry)                \
  DEM_CLR_MASK_16((Entry), DEM_PERMANENT_MEMORY_PASSED_CYCLE_COND_MASK)

#if (defined DEM_GET_PERMANENT_MEMORY_PASSED_CYCLE_COND)
#error DEM_GET_PERMANENT_MEMORY_PASSED_CYCLE_COND already defined
#endif
/** \brief Macro to check whether "Passed Cycle" condition to erase the
 ** permanent DTC after ClearDTC is satisfied */
#define DEM_GET_PERMANENT_MEMORY_PASSED_CYCLE_COND(Entry)                \
  DEM_IS_BIT_SET((Entry), DEM_PERMANENT_MEMORY_PASSED_CYCLE_COND_MASK)

#endif /* DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U */

/*==================[type definitions]======================================*/

/*------------------[pointer types]-----------------------------------------*/

/** \brief Pointer to ::Dem_EventMemoryEntryType */
typedef P2VAR(Dem_EventMemoryEntryType, TYPEDEF, DEM_VAR_CLEARED)
  Dem_EventMemoryEntryPtrType;

/** \brief Pointer to const ::Dem_EventMemoryEntryType */
typedef P2CONST(Dem_EventMemoryEntryType, TYPEDEF, DEM_VAR_CLEARED)
  Dem_EventMemoryEntryPtrConstType;

/** \brief Pointer to variable element in ::Dem_NvData.StatusCounter[]
 ** (or ::DEM_CMBEV_FAILURE_CYC_COUNTER[]) */
typedef P2VAR(Dem_StatusCounterType, TYPEDEF, DEM_VAR_CLEARED)
  Dem_StatusCounterPtrType;

/** \brief Pointer to const ::Dem_EDSegmentType */
typedef P2CONST(Dem_EDSegmentType, TYPEDEF, DEM_VAR_CLEARED)
  Dem_EDSegmentPtrConstType;

/*------------------[definitions for debouncing]----------------------------*/

/** \brief Type used for the debounce class reference
 ** ::Dem_DebounceCounterClassIdx
 ** The most significant bit represents the storage flag of the counter. */
#if (DEM_NUM_DEBOUNCE_COUNTER_CLASSES <= 127U)
typedef uint8 Dem_DebounceCounterClassIdxType;
#else
typedef uint16 Dem_DebounceCounterClassIdxType;
#endif

#if (DEM_NUM_DEBOUNCE_TIME_CLASSES <= 255U)
typedef uint8 Dem_DebounceTimeClassIdxType;
#else
typedef uint16 Dem_DebounceTimeClassIdxType;
#endif

/** \brief Configuration description of counter based debouncing algorithm */
typedef struct
{
  uint16  CountDecStepSize;   /**< step size for decrementation (PREPASSED) */
  uint16  CountIncStepSize;   /**< step size for incrementation (PREFAILED) */
  sint16  CounterPassedThreshold;          /**< threshold for Passed status */
  sint16  CounterFailedThreshold;          /**< threshold for Failed status */
#if ( (DEM_FREEZE_FRAME_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD) || \
      (DEM_EXTENDED_DATA_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD) )
  sint16  CounterUnconfirmedThreshold;
                                      /**< threshold for Unconfirmed status */
#endif
  sint16  JumpDownValue;                               /**< Jump-down value */
  sint16  JumpUpValue;                                   /**< Jump-up value */
  uint8   DemDebounceBehavior;
                       /**< event bebounce counter-based algorithm behavior */
  boolean JumpDown;                           /**< Jump-down enabled switch */
  boolean JumpUp;                               /**< Jump-up enabled switch */
} Dem_DebounceCounterClassType;


/** \brief Configuration description of time based debouncing class algorithm */
typedef struct
{
  uint32          TimeFailedThreshold;
                         /**< "event failed" timeout in main function ticks */
  uint32          TimePassedThreshold;
                         /**< "event passed" timeout in main function ticks */
  uint8           DemDebounceBehavior;
                          /**< event debounce time-based algorithm behavior */
} Dem_DebounceTimeClassType;

/** \brief Status information for time based debouncing algorithm */
typedef struct
{
  uint32              InternalTimer;
     /**< remaining timer value in main function ticks, 0=timer not running */
  Dem_EventStatusType Direction;                       /**< timer direction */
  boolean             FreezeStatus;
     /**< state of event debounce timer, FALSE=timer not freeze,
                                                            TRUE=timer freezed */
} Dem_DebounceTimeStatusType;

/** \brief Configuration description of frequency based debouncing algorithm */
typedef struct
{
  uint32          TimeWindowDuration;
                        /**< duration of time window in main function ticks */
  uint16          ThresholdBeforeEvFailed;
                       /**< threshold for "failed" counter decreased by one */
  uint16          ThresholdBeforeEvPassed;
                       /**< threshold for "passed" counter decreased by one */
  Dem_EventIdType EventId;            /**< event id for backwards reference */
  uint8           DemDebounceBehavior;
                     /**< event debounce frequency-based algorithm behavior */
} Dem_DebounceFrequencyCfgType;

/** \brief Status information for frequency based debouncing algorithm */
typedef struct
{
  uint32              InternalTimer;
     /**< remaining timer value in main function ticks, 0=timer not running */
  uint16              PassedCounter;         /**< value of "passed" counter */
  uint16              FailedCounter;         /**< value of "failed" counter */
  Dem_EventStatusType Status;                        /**< debouncing status */
  boolean             FreezeStatus;
     /**< state of event debounce frequency, FALSE=timer not freeze,
                                                         TRUE=timer freezed */
} Dem_DebounceFrequencyStatusType;

/*------------------[definitions for Warning indicators]--------------------*/

/** \brief This type is used as index type for indicator cycle counter data
 ** arrays
 **
 ** Used to access IndicatorCycleCounter[], IndicatorCycleCounterRole[] and
 ** IndicatorCycleCounterWIRStatus[] of ::Dem_NvData.
 **
 ** Its size is derived from the number of warning indicator-link.
 */
#if (DEM_NUM_INDICATOR_COUNTER < 256U)
typedef uint8 Dem_CounterDataIdxType;
#elif (DEM_NUM_INDICATOR_COUNTER < 65536U)
typedef uint16 Dem_CounterDataIdxType;
#else
typedef uint32 Dem_CounterDataIdxType;
#endif

/** \brief Indicator cycle counter role type type */
typedef boolean Dem_IndicatorCounterDataRoleType;

/** \brief This type is used as index type for the indicator links
 **
 ** Used to access ::Dem_IndicatorLink[].
 ** In case of calibration-support used to access ::Dem_IndicatorClasses[].
 **
 ** Its size is derived from the number of warning indicator-links.
 */
#if (DEM_NUM_INDICATOR_LINKS < 256U)
typedef uint8 Dem_IndicatorIdxType;
#elif (DEM_NUM_INDICATOR_LINKS < 65536U)
typedef uint16 Dem_IndicatorIdxType;
#else
typedef uint32 Dem_IndicatorIdxType;
#endif

#if (DEM_INDICATORCLASS_SUPPORT == STD_ON)

/** \brief Type used for the warning indicator-class configuration */
typedef struct
{
  boolean                       Enabled;
  Dem_IndicatorIdType           IndicatorId;
  Dem_IndicatorStatusType       Behaviour;
  Dem_IndicatorCycleCounterType HealingCycleThreshold;
  Dem_IndicatorCycleCounterType FailureCycleThreshold;
#if (DEM_COMMON_OPERATION_CYCLE_SUPPORT == STD_OFF)
  Dem_OperationCycleIdType      HealingCycle;
  Dem_OperationCycleIdType      FailureCycle;
#endif
  boolean                       IsIndFailureCycleSrcEvent;
} Dem_IndicatorClassType;

/** \brief This type is used as index type for the indicator groups
 **
 ** Used to access ::Dem_IndicatorGroups[].
 **
 ** Its size is derived from the number of warning indicator-groups.
 */
#if (DEM_NUM_INDICATOR_GROUPS < 256U)
typedef uint8 Dem_IndicatorGrpIdxType;
#elif (DEM_NUM_INDICATOR_GROUPS < 65536U)
typedef uint16 Dem_IndicatorGrpIdxType;
#else
typedef uint32 Dem_IndicatorGrpIdxType;
#endif

#else /* (DEM_INDICATORCLASS_SUPPORT == STD_OFF) */

/** \brief This type is used as index type for the configuration healing
 **  cycle-counter information table
 **
 ** Used to access ::Dem_HealingCycleCounterInfo[].
 **
 ** Its size is derived from the number of unique healing cycles and
 ** threshold pair configured.
 */
#if (DEM_NUM_HEALINGCYC_COUNTER_INFO_ELEMENTS < 256U)
typedef uint8 Dem_HealingCycleCounterInfoIdxType;
#elif (DEM_NUM_HEALINGCYC_COUNTER_INFO_ELEMENTS < 65536U)
typedef uint16 Dem_HealingCycleCounterInfoIdxType;
#else
#error Too many healing cycles configured.
#endif

/** \brief This type is used as index type for the configuration failure
 ** cycle-counter information table
 **
 ** Used to access ::Dem_FailureCycleCounterInfo[].
 **
 ** Its size is derived from the number of unique failure cycles and
 ** threshold pair configured.
 */
#if (DEM_NUM_FAILURECYC_COUNTER_INFO_ELEMENTS < 256U)
typedef uint8 Dem_FailureCycleCounterInfoIdxType;
#elif (DEM_NUM_FAILURECYC_COUNTER_INFO_ELEMENTS < 65536U)
typedef uint16 Dem_FailureCycleCounterInfoIdxType;
#else
#error Too many failure cycles configured.
#endif

/** \brief Type defining the operation cycle reference */
typedef uint8 Dem_OperationCycleRefType;

/** \brief Type used for the warning indicator configuration description */
typedef struct
{
  Dem_IndicatorIdxType Number;
                        /**< Number of events assigned to this indicator */
  Dem_IndicatorIdxType StartIdx;
             /**< Index in ::Dem_IndicatorLink[], where the links for this
               * indicators begin - may be invalid if Number is 0 */
} Dem_IndicatorDescType;

/** \brief Type used for the warning indicator-link configuration list */
typedef struct
{
  Dem_EventIdType                    EventId;
                    /**< Event Id to which this indicator is linked to */
  Dem_IndicatorStatusType            Behaviour;
     /**< Indicator behaviour (which does not use ::DEM_INDICATOR_OFF) */
  Dem_HealingCycleCounterInfoIdxType HealingCycleCounterInfoIdx;
                         /**< Index in ::Dem_HealingCycleCounterInfo[] */
  Dem_FailureCycleCounterInfoIdxType FailureCycleCounterInfoIdx;
                         /**< Index in ::Dem_FailureCycleCounterInfo[] */
} Dem_IndicatorLinkType;

/** \brief Type used for the warning indicator cycle-counter info table */
typedef struct
{
  Dem_OperationCycleRefType  OperationCycleRef;
                           /**< Reference for failure/healing cycle source */
  Dem_IndicatorCycleCounterType   Threshold;
              /**< Threshold for indicator (failure/healing) cycle counter */
} Dem_CounterInfoType;

#endif /* (DEM_INDICATORCLASS_SUPPORT == STD_ON) */

/*-------------------------[Multi event triggering]-------------------------*/

typedef struct
{
#if (DEM_MULTI_EVENT_TRIGGERING_COUNT > 0U)
  Dem_EventIdType RootId;
#endif
  boolean Result;
} Dem_ReadErrorQueueReturnType;

#if (DEM_MULTI_EVENT_TRIGGERING_COUNT > 255U)
/** \brief Type for root error-queue entries
 **
 ** - e[x]: variable number of bits known at compile-time
 **
 ** Memory layout:
 ** xxxx xxxx xxxx xxxx
 ** eeee eeee eeee eeee */
typedef uint16 Dem_RootErrorQueueEntryType;
#else
/** \brief Type for root error-queue entries
 **
 ** - e[x]: variable number of bits known at compile-time
 **
 ** Memory layout:
 ** xxxx xxxx
 ** eeee eeee */
typedef uint8 Dem_RootErrorQueueEntryType;
#endif

/* Note: The range of this type depends on the
 * number of configured multi-triggering elements
 * in order to optimize the used RAM space for
 * the root error queue
 */
#if (DEM_MULTI_EVENT_TRIGGERING_COUNT > 255U)
/** \brief Type for root error-queue indices */
typedef uint16 Dem_RootErrorQueueIdxType;
/** \brief Type used to combine two root error-queue entries */
typedef uint32 Dem_RootErrorQueueEntryWiderType;
#else
/** \brief Type for root error-queue indices */
typedef uint8 Dem_RootErrorQueueIdxType;
/** \brief Type used to combine two root error-queue entries */
typedef uint16 Dem_RootErrorQueueEntryWiderType;
#endif

/** \brief This type is used by Dem_GbiMultiEventTriggeringIdx() to access
 ** index of Dem_MultiEventTriggeringClasses[].
 **
 ** Note: The range of this type is limited by the number
 ** of multi event triggering classes.
 */
#if (DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT > 255U)
typedef uint16 Dem_MultiEventTriggeringClassIdxType;
#else
typedef uint8 Dem_MultiEventTriggeringClassIdxType;
#endif

/** \brief This type is used by Dem_GetMultiEventTriggeringMasterIdx() to access
 ** index of Dem_MultiEventTriggeringMasterEventId[].
 **
 ** Note: The range of this type is limited by the user
 ** configuration of all multi event triggering configurations.
 */
#if (DEM_MULTI_EVENT_TRIGGERING_COUNT > 255U)
typedef uint16 Dem_MultiEventTriggeringMasterIdxType;
#else
typedef uint8 Dem_MultiEventTriggeringMasterIdxType;
#endif

/** \brief This type is used as start index of slave events
 ** used for multi event triggering.
 **
 ** Note: The range of this type is limited by the user
 ** configuration of slave events within all multi
 ** event triggering classes.
 */
#if (DEM_MULTI_EVENT_TRIGGERING_SLAVE_COUNT > 65535U)
#error Too many DemMultiEventTriggeringSlaveEventRef combinations configured
#elif (DEM_MULTI_EVENT_TRIGGERING_SLAVE_COUNT > 255U)
typedef uint16 Dem_MultiEventTriggeringSlaveIdxType;
#else
typedef uint8 Dem_MultiEventTriggeringSlaveIdxType;
#endif

/** \brief This type is used for the selection of
 ** multi event triggering behavior.
 */
typedef uint8 Dem_MultiEventTriggeringAltBehaviorType;

/** \brief Data type for multi event triggering */
typedef struct
{
  Dem_MultiEventTriggeringSlaveIdxType    SlaveStartIdx;
  Dem_MultiEventTriggeringSlaveIdxType    SlaveNextIdx;
  Dem_MultiEventTriggeringAltBehaviorType AlternativeBehavior;
} Dem_MultiEventTriggeringType;

/*------------------[definitions for Event Class]---------------------------*/

/** \brief Type for value of Aging cycles */
typedef uint8 Dem_AgingCyclesType;

/** \brief Type for Priority */
typedef uint8 Dem_PriorityType;

#if (DEM_EVENTCLASS_SUPPORT == STD_ON)
typedef struct
{
#if (DEM_MULTI_EVENT_TRIGGERING_COUNT > 0U)
  /* non-calibratable MultiEventTriggeringClassIdx */
  Dem_MultiEventTriggeringClassIdxType MultiEventTriggeringClassIdx;
#endif
#if (DEM_INDICATORCLASS_SUPPORT == STD_ON)
  /* calibratable Indicator class */
  Dem_IndicatorGrpIdxType IndicatorClassIdx;
#endif
  /* calibratable DemAgingCycleCounterThreshold: value of 0 means DemAgingAllowed = false */
  Dem_AgingCyclesType AgingCycleCounterThreshold;
#if (DEM_VCC_OCC5_USED == STD_ON)
  /* calibratable DemOBDAgingCycleCounterThreshold: value of 0 means DemAgingAllowed = false */
  Dem_AgingCyclesType OBDAgingCycleCounterThreshold;
#endif
  /* calibratable DemEventFailureCycleCounterThreshold */
  Dem_FailureCycleCounterType EventFailureCycleCounterThreshold;
  /* calibratable DemEventPriority */
  Dem_PriorityType EventPriority;
#if (DEM_COMMON_OPERATION_CYCLE_SUPPORT == STD_ON)
  /* !LINKSTO dsn.Dem.CommonOperationCycle.Dem_EventClassDesc,1 */
  /* calibrate common operation cycle is used as aging cycle, event failure cycle,
   * indicator failure cycle, indicator healing cycle */
  uint8 CommonOperationCycle;
#endif
#if (DEM_AGINGALLOWED_CONVENIENT_CALIBRATION == STD_ON)
  /* !LINKSTO Dem.AgingAllowedSeperateEntry.Calibration,1 */
  /* calibratable DemAgingAllowed */
  boolean AgingAllowed;
#endif
#if ((DEM_OBD_Support == STD_ON) || (DEM_FREEZE_FRAME_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD))
  /*
   * Bit 0: DemMinRatioEvent     <- calibratable
   * Bit 1: DemFreezeFrameUpdate <-    "    "
   */
  uint8 Bitfield;
#endif
#if (DEM_NUM_ENCONDGROUPS > 0U)
  /* calibratable DemEnableConditionGroupRef */
  Dem_EnCondGrpIdxType EnableConditionGroupRef;
#endif
} Dem_EventClassDescType;
#endif

/*------------------[definitions for Data Element type]---------------------*/

/** \brief Type for the configured maximum data element size of a single PID inside the OBD
 ** freeze frame data.
 ** This maximum size is derived from one of the PID class which contains highest size of all
 ** referenced PID data elements (DemPidDataElementClassRef).
 **
 ** Note: The range of this type is limited by the user
 ** configuration of DemDataElementDataSize.
 */
#if (DEM_MAX_SIZE_PID_CLASS > 255U)
typedef uint16 Dem_OBDFFPidSizeType;
#else
typedef uint8 Dem_OBDFFPidSizeType;
#endif

/** \brief Type for the configured maximum data element index of a single PID inside the OBD
 ** freeze frame data.
 ** This maximum index is derived from one of the PID class which contains highest index value of
 ** all referenced PID data elements (DemPidDataElementClassRef).
 **
 ** Note: The range of this type is limited by the user
 ** configuration of DemDataElementClass.
 */
#if (DEM_MAX_INDEX_PID_CLASS > 255U)
typedef uint16 Dem_OBDFFDataElementOffsetType;
#else
typedef uint8 Dem_OBDFFDataElementOffsetType;
#endif

/** \brief General pointer to function for read data element operations */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_GeneralFuncType) (void);
/** \brief C/RTE-Callback function prototype for getting Client-server
 ** data element values
 **
 ** Note: In case of ::E_NOT_OK is returned by data value callback function,
 ** the Dem fills the missing data with the padding value 0xFF, reports the
 ** development error ::DEM_E_NODATAAVAILABLE to the DET and continuous his
 ** normal operation.
 */
/** \brief Pointer to function for read uint8 CS data element operations */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrReadData_uint8) (
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Data);
/** \brief Pointer to function for read CS uint8 data element operations
 ** with EventId parameter */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrReadDataWithEventID_uint8) (
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Data,
  Dem_EventIdType                        EventId);

#if (DEM_SR_SUPPORT == STD_ON)
/** \brief Pointer to function for read uint8 data element operations */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_FuncPtrReadData_uint8) (
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Data);
/** \brief Pointer to function for read uint16 data element operations */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_FuncPtrReadData_uint16) (
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) Data);
/** \brief Pointer to function for read uint32 data element operations */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_FuncPtrReadData_uint32) (
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA) Data);
#endif

/** \brief Union containing the types of pointers to functions for read data element operations.
 ** The union is used in order to save memory, since every data element is using only one type
 ** of callback function pointer
 */
/* Deviation MISRAC2012-1 */
typedef union
{
  /** \brief Rte_Read operation for general data element type, required for
   ** the initialization of the union **/
  Dem_GeneralFuncType  Rte_Read_DataElement_general;
  /** \brief Callback operation for CS data element type                        **/
  Dem_CbFuncPtrReadData_uint8  Callback;
  /** \brief Callback operation for CS data element type with EventId parameter **/
  Dem_CbFuncPtrReadDataWithEventID_uint8  CallbackWithEventId;
#if (DEM_SR_SUPPORT == STD_ON)
  /** \brief Rte_Read operation for SR UINT8 data element type                  **/
  Dem_FuncPtrReadData_uint8  Rte_Read_DataElement_uint8;
  /** \brief Rte_Read operation for SR UINT16 data element type                 **/
  Dem_FuncPtrReadData_uint16 Rte_Read_DataElement_uint16;
  /** \brief Rte_Read operation for SR UINT32 data element type                 **/
  Dem_FuncPtrReadData_uint32 Rte_Read_DataElement_uint32;
#endif
} Dem_VariableFunctionPointerDataElementType;

/** \brief Layout information of external data elements
 **
 ** This does not include data elements of type DemInternalDataElementClass.
 */
typedef struct
{
  const Dem_VariableFunctionPointerDataElementType ReadFunction;
                                         /**< Data value callback function */
  const uint8 Size;                              /**< Size of data element */
  const Dem_DataElementDataType DataType;
                                         /**< Data type of the DataElement */
#if (DEM_SR_SUPPORT == STD_ON)
  const Dem_SRDataElementEndiannessType Endianness;
                                  /**< Data endianness of the data element */
#endif
} Dem_DataElementType;

/*------------------[definitions for FF class types]------------------------*/

/** \brief Layout information of freeze frame classes */
typedef struct
{
  CONSTP2CONST(Dem_FFSegIdxType, AUTOMATIC, DEM_CONST) FFSegIdx;
        /**< Indexes to freeze frame segments (array - ::Dem_FFSegmentType) */
  const Dem_NumFFSegsType NumFFSegs;
                                /**< Number of freeze frame segments (DIDs) */
} Dem_FFClassType;

/*------------------[definitions for FF record numeration class types]------*/

/** \brief Layout information of freeze frame record numeration classes */
typedef struct
{
  CONSTP2CONST(Dem_FFIdxType, AUTOMATIC, DEM_CONST) Dem_FFRecNumClassIdx;
                                    /**< Pointer to array of record numbers */
  const Dem_FFIdxType NumFFRecs;    /**< Number of freeze frame records */
} Dem_FFRecNumerationClassType;

/*---------[Dem_FFRecNumClassIdxType]---------------------------------------*/

/** \brief Number of freeze frame records class index type */
typedef uint8 Dem_FFRecNumClassIdxType;

#if (DEM_USE_ADVANCED_EVENT_DISPLACEMENT == STD_ON)
/* !LINKSTO dsn.Dem.Displacement.Advanced.Encapsulation,1 */
/*-------------------[definitions for passive table type]-------------------*/
/* !LINKSTO dsn.Dem.Displacement.Dem_AdvDisplPassiveTableLinePassiveEventsType,1 */
typedef struct
{
  CONSTP2CONST(Dem_EventIdType, TYPEDEF, DEM_CONST)
    PassiveEventId;
  /**< passive events of passive table (array - ::Dem_AdvDisplPassiveEventType) */
  uint8 NumPassiveEvents;
  /**< Number of passive events per line */
} Dem_AdvDisplPassiveTableLinePassiveEventsType;
/**< Type for passive table, used in advanced event displacement **/
#endif /* (DEM_USE_ADVANCED_EVENT_DISPLACEMENT == STD_ON) */

/*---------------[definitions for notifications messages]-------------------*/

/** \brief Data type for DTC status mask change */
typedef struct
{
  Dem_EventIdType       EventId;
  Dem_DTCStatusMaskType OldStatusMask;
  Dem_DTCStatusMaskType NewStatusMask;
} Dem_DTCMaskChangedType;

/** \brief Pointer type for DTC status mask change */
typedef P2VAR(Dem_DTCMaskChangedType, TYPEDEF, DEM_VAR_CLEARED)
  Dem_DTCMaskChangedPtrType;

/** \brief Data type for notification "OnEventStatusChanged" */
typedef struct
{
  Dem_EventIdType       EventId;
  Dem_DTCStatusMaskType OldStatusMask;
  Dem_DTCStatusMaskType NewStatusMask;
#if (DEM_NUM_CMB_DTCS > 0U)
  boolean               DisplacedEvent;
#endif
} Dem_EventStatusChangedMsgType;

/** \brief Pointer type for notification "OnEventStatusChanged" */
typedef P2VAR(Dem_EventStatusChangedMsgType, TYPEDEF, DEM_VAR_CLEARED)
  Dem_EventStatusChangedMsgPtrType;

/*------------------[pointer types]-----------------------------------------*/

/** \brief Pointer to ::Dem_EntryDataType */
typedef P2VAR(Dem_EntryDataType, TYPEDEF, DEM_VAR_CLEARED)
  Dem_EntryDataPtrType;

/** \brief Pointer to const ::Dem_EntryDataType */
typedef P2CONST(Dem_EntryDataType, TYPEDEF, DEM_VAR_CLEARED)
  Dem_EntryDataPtrConstType;

/*---------------[definitions for event/DTC description types]--------------*/

#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_DISABLED )
/** \brief Static event/DTC description type
 **
 ** The 'bit packing scheme' is used. Access to the values is possible with
 ** getter functions.
 */
typedef struct
{
  uint32 EvConf1;
  /**< 1. Word of the event description bit-package:
   *
   * - d[24]: UdsDTC               fixed size
   * - o[2]:  DTCOrigin            fixed size
   * - s[2]:  DTCSeverity          fixed size
   * - r[1]:  EnablePrestorage     var size (unused if no event has FF prestorage enabled)
   * - k[1]:  EventKind            fixed size
   * - u[1]:  IndicatorUsed        var size (unused if no event has a DemIndicatorAttribute container configured)
   * - i[1]:  ImmediateStorage     fixed size
   *
   * Memory layout:
   * xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
   * iukr ssoo  dddd dddd  dddd dddd  dddd dddd
   */

  uint32 EvConf2;
  /**< 2. Word of the event description bit-package:
   *
   * - q[1]:  EvSignificance       fixed size
   * - t[11]: FFClassIdx           var size
   * - n[4]:  FFRecInfo            var size
   * - e[4]:  EDClassIdx           var size
   * - o[2]:  OpCycleIdx           var size (unused if calibration and common operation cycle is enabled)
   * - h[6]:  AgingCycleThreshold  var size (unused if calibration is enabled)
   * - g[3]:  DTCGroup             var size
   * - c[7]:  EventClassIdx        var size (unused if calibration is disabled)
   *
   * Memory layout:
   * xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
   * gggh hhhh  hhoo eeee  nnnn tttt  tttt tttq (calibration off)
   * cccc cccg  ggoo eeee  nnnn tttt  tttt tttq (calibration on)
   */

  uint32 EvConf3;
  /**< 3. Word of the event description bit-package:
   *
   * - e[6]: EnCondGrpIdx          var size (unused if calibration is enabled)
   * - f[5]: EventFailureClassIdx  var size
   * - p[3]: Priority              var size (unused if calibration is enabled)
   * - d[2]: DebounceAlgo          fixed size
   * - y[6]: DebounceIdx           var size (unused if monitor based debouncing algorithm class is used)
   * - u[8]: DTCFuncUnit           var size
   * - a[2]: AgingCycleIdx         var size
   *
   * Memory layout:
   * xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
   * aauu uuuu  uuyy yyyy  ddpp pfff  ffee eeee (calibration off)
   * xxxx xxxx  xaau uuuu  uuuy yyyy  yddf ffff (calibration on)
   */
#if ( (DEM_EVENTCLASS_SUPPORT == STD_OFF) && \
      (DEM_MULTI_EVENT_TRIGGERING_COUNT > 0U) )
  uint16 EvConf4;
  /**< 4. Word of the event description bit-package:
   *
   * - m[13]: MultiEventTriggeringClassIdx  var size (unused if calibration is enabled)
   *
   * Memory layout:
   * xxxx xxxx  xxxx xxxx
   * xxxm mmmm  mmmm mmmm (calibration off)
   * xxxx xxxx  xxxx xxxx (calibration on)
   */
#endif
} Dem_EventDescType;
#else
/** \brief Static DTC description type
 **
 ** The 'bit packing scheme' is used. Access to the values is possible with
 ** getter functions.
 */
typedef struct
{
  uint32 DTCConf1;
  /**< 1. Word of the DTC description bit-package:
   *
   * - d[24]: UdsDTC               fixed size
   * - o[2]:  DTCOrigin            fixed size
   * - s[2]:  DTCSeverity          fixed size
   * - i[1]:  ImmediateStorage     fixed size
   * - x[3]:  free for future use
   *
   * Memory layout:
   * xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
   * xxxi ssoo  dddd dddd  dddd dddd  dddd dddd
   */

  uint32 DTCConf2;
  /**< 2. Word of the DTC description bit-package:
   *
   * - p[3]: Priority              var size
   * - t[7]: FFClassIdx            var size
   * - n[2]: FFRecInfo             var size
   * - e[4]: EDClassIdx            var size
   * - a[2]: AgingCycleIdx         var size
   * - h[6]: AgingCycleThreshold   var size
   * - u[1]: DTCFuncUnit           var size
   * - g[3]: DTCGroup              var size
   * - q[1]: EvSignificance        fixed size
   * - x[3]: free for future use
   *
   * Memory layout:
   * xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
   * xxxq gggu  hhhh hhaa  eeee nntt  tttt tppp
   */
} Dem_DTCDescType;

/** \brief Static event description type
 **
 ** The 'bit packing scheme' is used. Access to the values is possible with
 ** getter functions.
 */
typedef struct
{
  uint32 EvConf1;
  /**< 1. Word of the event description bit-package:
   *
   * - k[1]: EventKind              fixed size
   * - u[1]: IndicatorUsed          var size (unused if no event has a DemIndicatorAttribute container configured)
   * - r[1]: EnablePrestorage       var size (unused if no event has FF prestorage enabled)
   * - d[2]: DebounceAlgo           fixed size
   * - y[6]: DebounceIdx            var size (unused if monitor based debouncing algorithm class is used)
   * - e[6]: EnCondGrpIdx           var size (unused if calibration is enabled)
   * - f[5]: EventFailureClassIdx   var size
   * - o[2]: OpCycleIdx             var size (unused if calibration and common operation cycle is enabled)
   * - p[8]: DTCConfIdx             var size
   *
   * Memory layout:
   * xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
   * pppp pppp  ooff fffe  eeee eyyy  yyyd druk (calibration off)
   * xxxx xxpp  pppp ppoo  ffff fyyy  yyyd druk (calibration on)
   */
#if ( (DEM_EVENTCLASS_SUPPORT == STD_OFF) && \
      (DEM_MULTI_EVENT_TRIGGERING_COUNT > 0U) )
  uint16 EvConf2;
  /**< 2. Word of the event description bit-package:
   *
   * - m[13]: MultiEventTriggeringClassIdx  var size (unused if calibration is enabled)
   *
   * Memory layout:
   * xxxx xxxx  xxxx xxxx
   * xxxm mmmm  mmmm mmmm (calibration off)
   * xxxx xxxx  xxxx xxxx (calibration on)
   */
#endif
} Dem_EventDescType;

/** \brief Type for generated array Dem_CmbDTCEvLnk */
typedef uint16 Dem_CmbDTCEvLnkType;
#endif /* (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_DISABLED ) */

/*----------------[Event Failure Cycle Cfg Type]-----------------------------*/

#if ( (DEM_COMMON_OPERATION_CYCLE_SUPPORT == STD_OFF) || \
      (DEM_EVENTCLASS_SUPPORT == STD_OFF) )
/** \brief Type for event failure cycle configuration */
typedef struct
{
#if (DEM_COMMON_OPERATION_CYCLE_SUPPORT == STD_OFF)
  Dem_OperationCycleIdType    EventFailureCycleIdx;   /**< Failure cycle Id */
#endif
#if (DEM_EVENTCLASS_SUPPORT == STD_OFF)
  Dem_FailureCycleCounterType EventFailureCycleCounterThreshold;
                       /**< Number of failure cycles for fault confirmation */
#endif
} Dem_EventFailureCycleCfgType;
#endif

/*------------------[definitions for DTC selection]-------------------------*/

typedef struct
{
  uint32                  DTC;                 /**< Single DTC or DTC group */
  Dem_EventIdType         EventId;
            /**< Id of the first event, matching the DTC selection criteria */
  Dem_DTCOriginType       DTCOrigin;           /**< Event memory of the DTC */
  Dem_DTCFormatType       DTCFormat;                 /**< Format of the DTC */
} Dem_DTCInfoType;

typedef struct
{
  Dem_DTCInfoType        DTCInfo;
                           /**< DTC selection criteria and matching eventId */
  Dem_SelectorStatusType SelectorStatus;
                  /**< Current status/result of the DTC selection operation */
} Dem_DTCSelectionType;

/*----------------[Type for freeze/reset FDC]--------------------------------*/

/* !LINKSTO dsn.Dem.DebounceAlgorithm.BehaviorType,1 */
typedef uint8 Dem_DebounceBehaviorType;

#ifndef DEM_DEBOUNCE_FREEZE
/** \brief DemDebounceBehavior algorithm: Freeze value for event debouncing */
#define DEM_DEBOUNCE_FREEZE                0x00U
#endif

#ifndef DEM_DEBOUNCE_RESET
/** \brief DemDebounceBehavior algorithm: Reset value for event debouncing */
#define DEM_DEBOUNCE_RESET                 0x01U
#endif

#ifndef DEM_DEBOUNCE_CONTINUE
/** \brief DemDebounceBehavior algorithm: Continue debouncing */
#define DEM_DEBOUNCE_CONTINUE              0x02U
#endif

/*------------------[callback types]----------------------------------------*/

/** \brief Type defining the C/RTE-callback properties of an event */
typedef uint8 Dem_CbPropertyType;

/** \brief Identifier type for the callback functions */
typedef Dem_EventIdType Dem_CbIndexType;

/** \brief Type defining the callback function lookup tables */
typedef struct
{
  Dem_EventIdType EventId;                     /**< event */
  Dem_CbIndexType CallbackIdx; /**< Index of the callback */
} Dem_CbLookupTableType;

/** \brief Function pointer type for generic "InitMonitor callback" function
 **
 ** This prototype is identical for C- and RTE-callbacks. */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrInitMonitorType) (
  Dem_InitMonitorReasonType InitMonitorReason);

/** \brief Function pointer type for generic "TriggerOnEventStatus C-callback"
 ** function */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_CbFuncPtrTrigOnEvStType) (
  Dem_EventIdType             EventId,
  Dem_EventStatusExtendedType EventStatusOld,
  Dem_EventStatusExtendedType EventStatusNew);

/** \brief Function pointer type for generic "TriggerOnEventStatus RTE-
 ** callback" function */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_RteFuncPtrTrigOnEvStType) (
#if (DEM_DEFAULT_ASR_SERVICE_API == DEM_SERVICE_API_ASR42)
  Dem_UdsStatusByteType EventStatusByteOld,
  Dem_UdsStatusByteType EventStatusByteNew);
#else
  Dem_EventStatusExtendedType EventStatusOld,
  Dem_EventStatusExtendedType EventStatusNew);
#endif

/** \brief Function pointer type for generic "TriggerOnDTCStatus callback"
 ** function
 **
 ** This prototype is identical for C- and RTE-callbacks. */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrTrigOnDTCStType) (
  uint32 DTC,
  uint8  DTCStatusOld,
  uint8  DTCStatusNew);

/** \brief Function pointer type for generic "TriggerOnEventData C-callback"
 ** function */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_CbFuncPtrTrigOnEvDatType) (
  Dem_EventIdType EventId);

/** \brief Function pointer type for generic "TriggerOnEventData RTE-callback"
 ** function */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_RteFuncPtrTrigOnEvDatType) (
  void);

/** \brief Function pointer type for generic "GetFaultDetectionCounter
 ** callback" function
 **
 ** This prototype is identical for C- and RTE-callbacks. */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrGetFDCType) (
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)
    FaultDetectionCounter);

/** \brief Function pointer type for generic "ClearEventAllowed callback"
 ** function
 **
 ** This prototype is identical for C- and RTE-callbacks. */
typedef
  P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrClearEventAllowedType) (
    P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) Allowed);

/** \brief Function pointer type for generic "ReadDataElement C-callback"
 ** function */
typedef
  P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrReadDataElementType) (
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Buffer);

/** \brief Function pointer type for generic "ReadDataElement RTE-callback"
 ** function */
typedef
  P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_RteFuncPtrReadDataElementType) (
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Data);

/** \brief Function pointer type for generic "Reset Counters" function */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_DebounceResetFctPtrType) (
  Dem_EventIdType EventId);

/** \brief Function pointer type for generic "Freeze Counters" function
 ** used for time based and frequency based event debouncing */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_DebounceFreezeFctPtrType) (
  Dem_EventIdType EventId);

/** \brief Function pointer type for generic "DebounceEvent" function */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_DebounceEventFctPtrType) (
  Dem_EventIdType                                      EventId,
  P2VAR(Dem_EventStatusType, AUTOMATIC, DEM_APPL_DATA) EventStatus);

/** \brief Function pointer type for generic "GetFDC" function */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_DebounceGetFDCFctPtrType) (
  Dem_EventIdType                                                EventId,
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)                         FDC);

#if (DEM_USE_TRIGGER_DEBOUNCE_BEHAVIOR == STD_ON)
/** \brief Function pointer type for generic "GetDebounceBehavior" function */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_DebounceGetBehaviorFctPtrType) (
  Dem_EventIdType                                           EventId,
  P2VAR(Dem_DebounceBehaviorType, AUTOMATIC, DEM_APPL_DATA) DebounceBehavior);
#endif

#if ( (DEM_INIT_MONITOR_REENABLED_SUPPORT == STD_ON) && \
      (DEM_USE_CB_INIT_MONITOR == STD_ON) )
/** \brief Type for handling the asynchronous calling of InitMonitorForEvent
 */
typedef struct
{
  Dem_CbIndexType NextCbIdx;
                 /**< next index for accessing Dem_CbLookupTableInitMonitor */
  boolean         DoProcess;
         /**< Indicates that Dem_ProcessInitMonitorReenable shall be called */
} Dem_InitMonitorReenableStateType;

#endif
/*--------------------------------------------------------------------------*/

/** \brief Type for debouncing function pointer table entries */
typedef struct
{
  Dem_DebounceResetFctPtrType       ResetFct;
               /**< reset status (Dem_ClearDTC, Dem_SetOperationCycleState) */
  Dem_DebounceFreezeFctPtrType      FreezeFct;
                              /**< freeze internal debounce timer/frequency */
  Dem_DebounceEventFctPtrType       DebounceEventFct;
            /**< debounce event (Dem_ReportErrorStatus, Dem_SetEventStatus) */
  Dem_DebounceGetFDCFctPtrType      GetFDCFct;
                                  /**< return fault detection counter value */
#if (DEM_USE_TRIGGER_DEBOUNCE_BEHAVIOR == STD_ON)
  Dem_DebounceGetBehaviorFctPtrType GetBehaviorFct;
                                              /**< return debounce behavior */
#endif
} Dem_DebounceFctPtrTableType;

#if (DEM_NUM_ENCONDGROUPS > 0)
/** \brief This type is used as index type for the enable condition links
 **
 ** Used to access ::Dem_EnCondToEvIdLink[].
 **
 ** Its size is derived from the different enable condition 'groups' (assigned
 ** to the events).
 */
#if (DEM_NUM_ENCONDGRP_LINKS < 256U)
typedef uint8 Dem_EnCondLnkType;
#elif (DEM_NUM_ENCONDGRP_LINKS < 65536U)
typedef uint16 Dem_EnCondLnkType;
#else
#error Too many enable conditions assigned.
#endif
#endif  /* (DEM_NUM_ENCONDGROUPS > 0) */

/** \brief Status of the DTC Filter */
typedef struct
{
  uint16                     NextItem;            /**< Next Item to read (event id or idx) */
  Dem_DTCStatusMaskType      DTCStatusMask;                 /**< Filter mask on DTC status */
  Dem_DTCKindType            DTCKind;                                     /**< Kind of DTC */
  Dem_DTCFormatType          DTCFormat;                          /**< output-format of DTC */
  Dem_DTCOriginType          DTCOrigin;                                 /**< Origin of DTC */
  boolean                    FilterWithSeverity;           /**< Use severity for filtering */
  Dem_DTCSeverityType        DTCSeverityMask;                 /**< Severity to filter with */
  boolean                    FilterForFDC;                      /**< Use FDC for filtering */
  /* !LINKSTO dsn.Dem.ASR431.DTCFilterType.IsSet,1 */
  boolean                    IsSet;
#if (DEM_ORDERED_DTC_REPORTING_USED == STD_ON)
  boolean                    OccOrdering;                  /**< TRUE: Output to be ordered */
  uint8                      EventsInMemory;               /**< Number of events in memory */
#endif
} Dem_DTCFilterType;

/** \brief Status of the Stored DTC Filter */
typedef struct
{
  uint8                  DTCOriginIdx;   /**< index of memory origin of DTC */
  Dem_DataKindType       DataKind;                        /**< Kind of data */
  Dem_SizeEvMemEntryType NextEntryIdx;       /**< Index of DTC to read next */
} Dem_StoredDTCFilterType;

#if (DEM_J1939_SUPPORT == STD_ON)
/** \brief Status of the J1939 DTC Filter */
typedef struct
{
  uint16                          NextItem;             /**< Next Item to read (event id or idx) */
  Dem_J1939DcmDTCStatusFilterType J1939DTCStatusFilter; /**< Filter on DTC status */
  Dem_DTCKindType                 DTCKind;              /**< Kind of DTC */
  uint8                           Node;                 /**< NM Node */
} Dem_J1939DTCFilterType;
#endif

#if (DEM_J1939_FREEZEFRAME_SUPPORT==STD_ON)
/** \brief Status of the J1939 Freeze Frame Filter */
typedef struct
{
  uint16                               NextItem;        /**< Next Item to read (event id or idx) */
  Dem_J1939DcmSetFreezeFrameFilterType FreezeFrameKind; /**< Kind of J1939 Freeze Frame */
  uint8                                Node;            /**< NM Node */
  boolean                              IsFilterValid;   /**< Flag used to check FreezeFrameKind */
} Dem_J1939FreezeFrameFilterType;
#endif

/** \brief Status of the Freeze Frame Record Filter */
typedef struct
{
  Dem_SizeEvMemEntryType     EntryIdx;            /**< Entry index used by FF record filter */
  uint8                      RecNumIdx;           /**< Record number index used by FF record filter */
  Dem_DTCFormatType          DTCFormat;           /**< The output-format of DTC */
#if (DEM_NUM_OF_PIDS_IN_OBDFF > 0U)
  boolean                    ObdFFConsidered;     /**< Flag used to recognize whether the OBD FF
                                                       records were considered already by a previous call of the API
                                                       Dem_GetNextFilteredRecord() */
#endif
#if (DEM_DEV_FREEZE_FRAME_USED == STD_ON)
#if ((DEM_MAX_NUMBER_DEVFFA_ENTRY > 0U) || (DEM_MAX_NUMBER_DEVFFB_ENTRY > 0U))
  boolean DevFFConsidered[DEM_NUM_OF_DEVFF_KIND]; /**< Flags used to recognize whether the development FF records were
                                                       considered already by a previous call of the
                                                       API Dem_GetNextFilteredRecord() */
#endif
#endif
  boolean                    RecordFilterIsSet;   /**< Flag used to detect if the FF record filter is set */
} Dem_RecordFilterType;

/*------------------[Immediate storag event memory entry block types]-------*/

/** \brief Global block status type referring NvM write status */
typedef uint8 Dem_NvMBlockStatusType;

#if (defined DEM_NVM_IDLE)
#error DEM_NVM_IDLE already defined
#endif
/** \brief Dem Nvm state: No dataset processed */
#define DEM_NVM_IDLE    0U

#if (defined DEM_NVM_WAITING)
#error DEM_NVM_WAITING already defined
#endif
/** \brief Dem Nvm state: One gate entry prepared to be written */
#define DEM_NVM_WAITING 1U

#if (defined DEM_NVM_PENDING)
#error DEM_NVM_PENDING already defined
#endif
/** \brief Dem Nvm state: Writing gate entry */
#define DEM_NVM_PENDING 2U

/** \brief Local NvM status referring each individual gate entry */
typedef struct {
  /** \brief NvM block write status */
  Dem_NvMBlockStatusType Status;
  /** \brief Event memory entry index of related event */
  uint8 PendingEntryIdx;
} Dem_NvMGateEntryInfoType;

/*------------------[ClearDTC types]----------------------------------------*/

/** \brief Run state type of an asynchronous ClearDTC processing */
typedef uint8 Dem_ClearDtcRunStateType;

/** \brief Internal data type to define if event status and/or event data are
 ** modified */
typedef struct
{
  /** \brief Event status modified flag */
  boolean EvSt;
#if (DEM_CLEAR_DTC_BEHAVIOR == DEM_CLRRESP_NONVOLATILE_FINISH)
  /** \brief Event data modified flag */
  boolean EvMemEntry;
#endif
} Dem_EventModifiedType;

#if ( (DEM_NUM_CMB_DTCS > 0U) && \
      (DEM_USE_CB_CLEAR_EVENT_ALLOWED == STD_ON) )
/** \brief Internal data type to define ClearEventAllowed callback result */
typedef struct
{
  /** \brief Clear event behavior */
  uint16 Behavior;
  /** \brief Flag indicating if clearance of the event is allowed */
  boolean Allowed;
} Dem_ClearEventAllowedType;
#endif

/** \brief Status of an asynchronous ClearDTC processing */
typedef struct
{
  /** \brief Next EventId to be cleared */
  Dem_EventIdType NextEventId;
#if (DEM_NUM_CMB_DTCS > 0U)
  /** \brief Index of next combined event to be cleared */
  Dem_CmbDTCEvLnkType NextCmbEvIdx;
#if (DEM_USE_CB_CLEAR_EVENT_ALLOWED == STD_ON)
  /** \brief Result of last ClearEventAllowed callback */
  Dem_ClearEventAllowedType ClearEventAllowed;
#endif
#endif
  /** \brief Event status/data modified flag */
  Dem_EventModifiedType AnyEventModified;
  /** \brief Client ID of the client which has locked/started
   ** the current clearing process */
  uint8 ClientId;
  /** \brief State of the ClearDTC processing */
  Dem_ClearDtcRunStateType RunState;
#if (DEM_CLEAR_DTC_BEHAVIOR == DEM_CLRRESP_NONVOLATILE_FINISH)
  /** \brief Origin of entries to be cleared */
  uint8 OriginIdx;
  /** \brief Write state of event entry block */
  Dem_NvMBlockStatusType EventMemWrite;
#endif
  /** \brief Write state of Dem status block (containing the event status bytes) */
  Dem_NvMBlockStatusType EventStatusWrite;
#if (DEM_CLEAR_DTC_BEHAVIOR == DEM_CLRRESP_NONVOLATILE_TRIGGER)
  /** \brief Flag to re-trigger status block from its NvM single block callback */
  boolean RetriggerEventStatusWrite;
#endif
  /** \brief Result of the clearing operation */
  Std_ReturnType OperationResult;
} Dem_ClearDtcAsyncStatusType;


#if ((DEM_J1939_SUPPORT == STD_ON) && (DEM_J1939_CLEAR_DTC_SUPPORT == STD_ON))
/** \brief Filter of an asynchronous J1939 ClearDTC processing */
typedef struct
{
  /** \brief J1939ClearDtc filter */
  Dem_J1939DcmSetClearFilterType Dem_J1939DTCTypeFilter;
  /** \brief J1939ClearDtc node */
  uint8 Dem_J1939Node;
} Dem_J1939ClearDTCFilterType;
#endif

/*--------------------------------------------------------------------------*/

/** \brief Structure collecting information for delayed status notifications */
typedef struct
{
  /** \brief Notification data "OnEventStatusChanged" for a replaced event */
  Dem_EventStatusChangedMsgType ReplacedEventMsg;
#if ((DEM_USE_CB_TRIG_ON_STATUS_CHANGE == STD_ON) || (DEM_NUM_CMB_DTCS > 0U))
  /** \brief Notification data "OnEventStatusChanged" for a new event */
  Dem_EventStatusChangedMsgType ProcessedEventMsg;
#endif
#if (DEM_TRIG_CB_ON_EVDAT == STD_ON)
  /** \brief Notification data "EventDataChanged" for a new event */
  Dem_EventIdType TriggerOnEventData;
#endif /* (DEM_TRIG_CB_ON_EVDAT == STD_ON) */
#if ( (DEM_EXTENDED_DATA_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD) && \
      (DEM_SUPPORT_FIM_ON_FDC_TRESHOLD == STD_ON) )
  /** \brief Notification data "TriggerFimOnUnconfirmed" */
  Dem_EventIdType TriggerFimOnUnconfirmedData;
#endif
} Dem_EventNotificationDataType;

/** \brief Pointer to a Dem_EventNotificationData */
typedef P2VAR(Dem_EventNotificationDataType, AUTOMATIC, AUTOMATIC)
  Dem_EventNotificationDataPtrType;

/*------------[ OBD specific event configuration ]--------------------------*/

/* !LINKSTO Dem_OBD_0001,2 */
#if (DEM_OBD_Support == STD_ON)
/* !LINKSTO dsn.Dem_OBD_0017,1 */
/** \brief OBD configuration structure
 **
 ** Structure stores the OBD specific configuration parameters
 ** for each configured event.
 ** For 'Dem_OBDEvConf1' the 'bit packing scheme' is used.
 ** Access to the values is possible with the getter functions:
 ** - Dem_GbiMinRatioEvent().
 */
typedef struct
{
  /* !LINKSTO dsn.Dem.OBD.config.ObdDTC.0001,1 */
  uint16 Dem_ObdDTC; /**< configured DemObdDTC for each event */
  /* !LINKSTO dsn.Dem.OBD.config.OBDEvConf1.0001,2,
              dsn.Dem.OBD.config.OBDEvConf1.0002,1,
              dsn.Dem.OBD.config.OBDEvConf1.DemEventOBDReadinessGroup.0001,3
     !id src.Dem.typedef.Dem_OBDConfigType.Dem_OBDEvConf1 */
  uint16 Dem_OBDEvConf1;
  /**< event description bit-package:
   *
   * - r: DemMinRatioEvent (max 1 bit)
   * - g: DemEventOBDReadinessGroup (bit 1-4)
   * - a: DemOBDAgingCycleCounterThreshold (bit 5- bit 12)
   * - x: reserved for future use
   *
   * Memory layout:
   * fedc ba98  7654 3210
   * xxxa aaaa  aaag gggr */
} Dem_OBDConfigType;
#endif

/*----------------------[ Permanent Memory types ]--------------------------*/

/* !LINKSTO Dem_OBD_0005,1 */
#if (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U)
/** \brief Type for the entry in the permanent memory */
typedef uint16 Dem_PermanentMemoryEntryType;
#endif

/*------------[ J1939 specific event configuration ]--------------------------*/

#if (DEM_J1939_SUPPORT == STD_ON)

/** \brief J1939 configuration structure
 **
 ** Structure stores the J1939 specific configuration parameters
 ** for each configured event.
 */
typedef struct
{
  uint32 Dem_J1939DTCValue; /**< configured Dem_J1939DTCValue for each event */
  uint8 Dem_J1939NodeId; /**< J1939 Nm node ID */
#if (DEM_J1939_FREEZEFRAME_SUPPORT==STD_ON)
  Dem_J1939FFClassIdxType Dem_J1939FFClassIdx ; /**< configured J1939 Freeze Frame Class Index */
#endif /* DEM_J1939_FREEZEFRAME_SUPPORT==STD_ON */
} Dem_J1939ConfigType;
#endif

/*------------------[definitions for PID class type]------------------------*/

/** \brief Type for the configured overall index of data element classes
 ** It includes total index of external data elements both CS and SR
 **
 ** Note: The range of this type is limited by the user
 ** configuration of DemDataElementClass.
 */
#if (DEM_NUM_EXT_DATAELEMENTS > 255U)
typedef uint16 Dem_OBDFFDataElementIdxType;
#else
typedef uint8 Dem_OBDFFDataElementIdxType;
#endif

/* !LINKSTO dsn.Dem.OBD.PidClassType,1 */
/** \brief Layout information of PID class */
typedef struct
{
  CONSTP2CONST(Dem_OBDFFDataElementOffsetType, AUTOMATIC, DEM_CONST)
    ObdFFPidDataElementOffset;
                    /**< Start-bytes of data elements inside PIDs in OBD FF */
  CONSTP2CONST(uint8, AUTOMATIC, DEM_CONST) ObdFFPidDataElementSize;
                    /**< Size of data elements inside PIDs in OBD FF */
  CONSTP2CONST(Dem_OBDFFDataElementIdxType, AUTOMATIC, DEM_CONST)
    DemPidDataElementIdx;
                    /**< Indexes to data elements */
  Dem_OBDFFPidSizeType Size;
                    /**< Size of stored PID in OBD FF in byte */
  Dem_NumDataElementsType NumSegDataElements;
                    /**< Number of data elements in PID */
  uint8 ParameterId;
                    /**< PID */
} Dem_PidClassType;


/*------------------[Type for job mask of Dem_ProcessEvent]-----------------*/
typedef uint8 Dem_ProcessEventJobMaskType;

typedef struct
{
#if (DEM_MULTI_EVENT_TRIGGERING_COUNT > 0U)
  Dem_EventIdType RootId;      /**< root event identifier */
#endif
  Dem_EventIdType EventId;          /**< event identifier */
} Dem_EventInfoType;

/*------------------[Type for status counter index]-------------------------*/

/* !LINKSTO dsn.Dem.StatusBitBehavior.StatusCounterIndexType,1 */
/** \brief Status counter index type into ::Dem_NvData.StatusCounter[] */
#if (DEM_STATUS_COUNTER_SIZE < 256U)
typedef uint8 Dem_StatusCounterIndexType;
#else
typedef uint16 Dem_StatusCounterIndexType;
#endif

/*------------------[Type for BSW Distribution]-----------------------------*/

#if (DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING == STD_ON)
/** \brief Type containing event Id and event status information necessary
 ** to be stored in satellite local queues
 **
 ** Note: Type is available only if DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING is enabled
 */
typedef struct
{
  Dem_EventIdType EventId; /**< event identifier */
  Dem_EventStatusType EventStatus; /**< status of the event */
} Dem_LocalBswEventQueueType;

/** \brief Type of pointer to exclusive area entry function
 **
 ** Note: Type is available only if DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING is enabled
 */
typedef P2FUNC(void, DEM_CODE, Dem_EnterExclusiveAreaFctPtrType)(void);

/** \brief Type of pointer to exclusive area exit function
 **
 ** Note: Type is available only if DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING is enabled
 */
typedef P2FUNC(void, DEM_CODE, Dem_ExitExclusiveAreaFctPtrType)(void);

/** \brief Type of pointer to SchM_Send_Dem_1_Core_[]_ReportErrorStatusProvide function
 **
 ** Note: Type is available only if DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING is enabled
 */
typedef
  P2FUNC(Std_ReturnType, RTE_CODE, Dem_SchMSendReportErrorStatusToMasterFctPtrType)
    (P2CONST(Dem_EventReportInfoType, AUTOMATIC, RTE_APPL_DATA) data);

/** \brief Type containing pointer to functions relevant for satellite contexts
 **
 ** Note: Type is available only if DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING is enabled
 */
typedef struct
{
  Dem_EnterExclusiveAreaFctPtrType EnterExclusiveArea; /**< exclusive area entry of satellite */
  Dem_ExitExclusiveAreaFctPtrType ExitExclusiveArea; /**< exclusive area exit of satellite */
  Dem_SchMSendReportErrorStatusToMasterFctPtrType SchMSendReportErrorStatusToMaster; /**< SchM_Send function */
} Dem_SatelliteFncPtrType;
#endif

/*==================[external function declarations]========================*/

#define DEM_START_SEC_CODE
#include <Dem_MemMap.h>
/** \brief Function to initialize the data elements of Data Record Selector
 **
 ** \return none
 **
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DEM_CODE) Dem_InitDataRecordSelector(void);

/** \brief Function to reset the current FF/ED selection, if any
 **
 ** \param[in] ClientId     Unique client id, assigned to the instance of the
 **                         calling module.
 **
 ** \return none
 **
 ** \Reentrancy{Reentrant for different client IDs. Non reentrant for the same
 **  client ID.}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE)Dem_ResetDataRecordSelector(uint8 ClientId);

/** \brief Check if DTC matches a DTC group Id
 **
 ** \param[in]  DTC
 ** \param[in]  DTCFormat
 ** \param[out] GroupIdx
 **
 ** \return Boolean
 ** \retval TRUE  DTC matches a DTC group Id
 ** \retval FALSE DTC does not match any DTC group Id
 */
/* !LINKSTO Dem.ASR431.SWS_Dem_01061,1 */
extern FUNC(boolean, DEM_CODE) Dem_IsDTCGroupValue(
  uint32                             DTC,
  Dem_DTCFormatType                  DTCFormat,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) GroupIdx);

/** \brief Function to initialize internal DTC Filter values.
 **
 ** \Reentrancy{Non-Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InitDTCFilter(void);

/** \brief This function initializes the data elements of the SW-Unit Record
 **  Filter to appropriate default values. It is called during the
 **  initialization of Dem.
 **
 ** \Reentrancy{Non-Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InitRecordFilter(void);

/** \brief This function initializes the data elements of the SW-Unit
 **  DTC Memory Filter to appropriate default values. It is called during the
 **  initialization of Dem.
 **
 ** \Reentrancy{Non-Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InitDTCMemoryFilter(void);

/** \brief Function to initialize the data elements of DTC Selector.
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
*/
extern FUNC(void, DEM_CODE) Dem_InitDTCSelector(void);

/** \brief Process clearing of all events related to a DTC or DTC group
 **
 ** This function needs to be called cyclically from the Dem_MainFunction
 ** context as long as the RAM clearing operation is in progress i.e., as
 ** long as Dem_ClearDtcAsyncStatus.RunState is equal to
 ** DEM_CLEARDTC_STATE_PROCESSING_RAM.
 **
 ** \return none
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ProcessClearDTC(void);

/** \brief Provides DTC selection related information of a diagnostic client.
 **
 ** This function is called by the DTC selection dependent APIs and it returns
 ** all the information related to the DTC selection of a client.
 **
 ** \param[in]  ClientId      Unique client ID, assigned to the instance of
 **                           the calling module.
 ** \param[out] DTCSelection  Buffer to receive the DTC selection related
 **                           information.
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_GetDTCSelection(
  uint8                                           ClientId,
  P2VAR(Dem_DTCSelectionType, AUTOMATIC, DEM_VAR) DTCSelection);

/** \brief Stores the DTC selection criteria for a diagnostic client.
 **
 ** This function stores the DTC selection criteria for the respective client
 ** so that it is available for later use by the dependent APIs of
 ** Dem_SelectDTC().
 **
 ** \param[in] ClientId       Unique client ID, assigned to the instance of
 **                           the calling module.
 ** \param[in] DTC            Defines the DTC in respective format or group of
 **                           DTCs.
 ** \param[in] DTCFormat      Defines the input-format of the DTC.
 ** \param[in] DTCOrigin      The event memory of the DTC or group of DTCs.
 ** \param[in] MappingVariant This parameter controls the mapping to one of
 **                           the supported event memories, dependent on
 **                           whether the DTCOrigin value complies to ASR431
 **                           (Dcm interface) or ASR42 (CDD interface).
 **
 ** \Reentrancy{Reentrant for different client IDs, non reentrant for the same
 **    client ID.}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_SetDTCSelectionCriteria(
  uint8                    ClientId,
  uint32                   DTC,
  Dem_DTCFormatType        DTCFormat,
  Dem_DTCOriginType        DTCOrigin,
  Dem_DTCOriginMappingType MappingVariant);

/** \brief Performs the DTC selection and returns the result.
 **
 ** This function searches for a DTC matching the last placed DTC selection
 ** criteria is existing and returns the result of the search.
 **
 ** \param[in]  ClientId  Unique client ID, assigned to the instance of the
 **                       calling module.
 ** \param[out] EventId   Id of the event matching the DTC selection criteria.
 **
 ** \return Status of the last placed DTC selection request of type
 **         Dem_SelectorStatusType
 ** \retval DEM_DTC_SELECTOR_WRONG_DTC              No matching DTC found
 ** \retval DEM_DTC_SELECTOR_WRONG_DTC_ORIGIN       Requested DTC origin does
 **                                                 not exist
 ** \retval DEM_DTC_SELECTOR_DTC_GROUP              Selection of a DTC group
 ** \retval DEM_DTC_SELECTOR_SINGLE_DTC_EVID_CACHED Selection of a single DTC
 **
 ** \Reentrancy{Reentrant for different client IDs, non reentrant for the same
 **    client ID.}
 ** \Synchronicity{Synchronous}
 */
extern FUNC (Dem_SelectorStatusType, DEM_CODE) Dem_DoDTCSelection(
  uint8                                      ClientId,
  P2VAR(Dem_EventIdType, AUTOMATIC, DEM_VAR) EventId);

/** \brief Initializes the Event Memory Processor's internal data elements.
 **
 ** \Reentrancy{Non-Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InitEventMemoryProcessor(void);

#if (DEM_NUM_EXT_DATAELEMENTS > 0U)
/** \brief Read data and size of an external DataElement. This function checks if the
 ** data element is CS (Rte ReadFunction or C-Callback) or SR (Rte ReadFunction).
 **
 ** \param[in]     DataElementIndex Index of the external data element in the
 **                                 internal structure
 ** \param[in]     EventId          The Id of the event which triggered the capture
 **                                 of the Event Related Data
 ** \param[out]    DestBuffer       Buffer where the data read from the DataElement
 **                                 shall be written
 **
 ** \return Result of reading the data element
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_ReadExternalDataElement(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC)                 DestBuffer,
  Dem_DataElementIdxType                             DataElementIndex,
  Dem_EventIdType                                    EventId);
#endif

#if (DEM_MAX_NUMBER_PRESTORED_FF > 0U)
/** \brief Function to get the index of a prestored freeze frame
 **
 ** This is done by searching in the event description array.
 **
 ** ATTENTION: If an event ID where prestorage of freeze frames is disabled
 ** is given, the index of the last event where prestorage is enabled is
 ** returned.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Index of the prestored freeze frame
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_GetPFFIndex(
  Dem_EventIdType EventId);
#endif

#if (DEM_EVENT_DISABLING_SUPPORT == STD_ON)
/** \brief Function to get the availability of a dedicated event
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Returns information whether an event is available or not
 **         TRUE  -> event is available
 **         FALSE -> event is not available
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_GbiEvAvailable(Dem_EventIdType EventId);
#endif

#if ( (DEM_NUM_CMB_DTCS > 0U) && \
      (DEM_AVAILABILITY_SUPPORT == DEM_EVENT_AVAILABILITY) )
/** \brief Function to get the availability of an event or of the event
 ** combination where the given EventId belongs to
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Returns information whether an event or any event of an event
 **         combination is available
 **         TRUE  -> event or at least one event of the event combination is
 **                  available
 **         FALSE -> event is not available or none of the combined events
 **                  is available
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_IsAnyEvAvailable(Dem_EventIdType EventId);
#endif

#if (DEM_NUM_INDICATOR_LINKS > 0U)
/** \brief Function which processes the failure cycle counter
 **
 ** It is used by Dem_ProcessIndicator().
 **
 ** \param[in] IndicatorIdx  0 < IndicatorIdx <= DEM_NUM_INDICATOR_LINKS
 ** \param[in] EventId
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ProcessIndicatorOnCriteria(
  Dem_IndicatorIdxType IndicatorIdx,
  Dem_EventIdType      EventId);
#endif

/* !LINKSTO Dem_OBD_0005,1 */
#if (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U)
/** \brief Function provides the information of the indicator status by received EventId
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Boolean value indicating the current status of indicator
 ** \retval TRUE   Indicator assigned to EventId is active
 ** \retval FALSE  Indicator assigned to EventId is not active
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(boolean, DEM_CODE) Dem_IsEventsMILIndicatorActive(
  Dem_EventIdType EventId);

#if (DEM_NUM_CMB_DTCS > 0U)
/** \brief Function provides the information of the indicator status
 **        in group of combined events where EventId belongs.
 **        EventId itself is excluded from the analysis.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Boolean value indicating the current status of indicator
 ** \retval TRUE   Indicator of at least one combined event is active
 ** \retval FALSE  Indicator of all combined events is not active
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(boolean, DEM_CODE) Dem_IsCmbEventsMILIndicatorActive(
  Dem_EventIdType EventId);
#endif
#endif /* (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U) */

/** \brief Function to search for an entry in the event memory by the given
 ** event Id
 **
 ** This function checks the EvEntryExists status for the given event Id.
 ** If an entry exists, it starts a linear search for the entry in the
 ** corresponding memory origin.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[out] FoundEntry Event memory entry of event with given event Id
 ** \param[out] FoundEntryIdx Entry index of found event memory entry
 **
 ** \return Result of the searching
 ** \retval TRUE  entry exists
 ** \retval FALSE no entry exists
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_SearchForEntry(
  Dem_EventIdType                                          EventId,
  P2VAR(Dem_EventMemoryEntryPtrType, AUTOMATIC, AUTOMATIC) FoundEntry,
  P2VAR(Dem_SizeEvMemEntryType, AUTOMATIC, AUTOMATIC)      FoundEntryIdx);

/** \brief Internal function to modify the EvEntryExists status bit for the given
 ** event Id and combined events, if any.
 **
 ** This function must be called within the same critical section where the event
 ** memory entry is allocated or released to consistently update the EvEntryExists
 ** status bit in the Dem_EvMemEntryExists bit-array i.e. to ensure data integrity.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EvEntryExitsStatus  This parameter must be set to TRUE if an event
 **                                memory entry was allocated and must be set to
 **                                FALSE if the event memory entry was released.
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \pre This function shall be called from within a critical section only.
 */
extern FUNC(void, DEM_CODE) Dem_SetEvEntryExists(
  Dem_EventIdType EventId,
  boolean         EvEntryExitsStatus);

/** \brief Internal function to initialize the Dem_EvMemEntryExists bit-array
 ** that holds a flag per event which indicates whether an memory entry exits
 ** for the event or not.
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InitEvEntryExists(void);

/** \brief Clear an event memory entry
 **
 ** This function clears an event memory entry including its freeze frames and
 ** extended data.
 **
 ** \param[in] EvMemEntry  Pointer to entry which shall be cleared.
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ClearEventEntry(
  Dem_EventMemoryEntryPtrType EvMemEntry);

/** \brief Function to get the size of the event memory entry data
 ** (IntVal's + ED + FFs)
 **
 ** This function returns the size of an event memory entry's data. It must
 ** be used only to calculate the full size of the data e.g. when accessing
 ** event memory entries.
 **
 ** Depending on argument MaximalSize the configured FF size or the
 ** maximal FF size is used.
 **
 ** \param[in] EventId           0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] MaximalSize       Select between FF size (FALSE) and
 **                              maximal FF size (TRUE)
 **
 ** \return Size of entry data
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeEntryDataType, DEM_CODE) Dem_EvMemEntrySize(
  Dem_EventIdType EventId,
  boolean         MaximalSize);

/** \brief Function to get a pointer to the internal value entry data of an
 ** event memory entry
 **
 ** \param[in] EvMemEntry must be valid and must NOT be NULL
 **
 ** \return Pointer to the internal value entry data
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC_P2VAR(Dem_EntryDataType, DEM_VAR_CLEARED, DEM_CODE)
  Dem_IntValEntryData(Dem_EventMemoryEntryPtrConstType EvMemEntry);

#if (DEM_NUM_EDSEGS > 0U)
/** \brief Function to get a pointer to the ED entry data of an event memory
 ** entry
 **
 ** ED class must not be the ::Dem_NullEDClass for this event.
 **
 ** \param[in] EvMemEntry must be valid and must NOT be NULL
 **
 ** \return Pointer to the ED entry data
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC_P2VAR(Dem_EntryDataType, DEM_VAR_CLEARED, DEM_CODE)
  Dem_EDEntryData(Dem_EventMemoryEntryPtrConstType EvMemEntry);
#endif

#if (DEM_NUM_FFSEGS > 0U)
/** \brief Function to get a pointer to the specified FF-record entry data of
 ** an event memory entry
 **
 ** FF class must not be the ::Dem_NullFFClass for this event.
 **
 ** \param[in] EvMemEntry
 ** \param[in] FFClass
 ** \param[in] FFIndex
 **
 ** \return Pointer to the FF-record entry data
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC_P2VAR(Dem_EntryDataType, DEM_VAR_CLEARED, DEM_CODE) Dem_FFEntryData(
  Dem_EventMemoryEntryPtrConstType               EvMemEntry,
  P2CONST(Dem_FFClassType, AUTOMATIC, DEM_CONST) FFClass,
  Dem_FFIdxType                                  FFIndex);

/** \brief Function to check if the requested freeze frame record number is
 ** valid
 **
 ** \param[in] EventId
 ** \param[in] RecordNumber
 **
 ** \return Boolean value indicating whether the requested freeze frame record
 **         number is valid
 ** \retval TRUE  the requested freeze frame record number is valid
 ** \retval FALSE the requested freeze frame record number is invalid
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_CheckFFRecNumValid(
  Dem_EventIdType EventId,
  uint8           RecordNumber);

/** \brief Function to check if the freeze frame record for the requested
 ** freeze frame record number is stored for the event
 **
 ** \param[in] EvMemEntry
 ** \param[in] RecordNumber
 **
 ** \return Index of the requested freeze frame record number if the record is
 **         stored, number of stored freeze frame records otherwise
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(uint8, DEM_CODE) Dem_CheckFFRecNumStored(
  Dem_EventMemoryEntryPtrConstType EvMemEntry,
  uint8                            RecordNumber);
#endif /* DEM_NUM_FFSEGS > 0U */

/** \brief Root-Error-Queue-Access-Function to write the next entry
 **
 ** \param[in] RootId  0 < RootId <= DEM_MAX_EVENTID
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \pre This function shall be in the context of Dem_WriteErrorQueueEntry()
 **      after writing a valid QueueEntry and before the update of
 **      Dem_ErrorQueueWriteIdx
 */
#if (DEM_MULTI_EVENT_TRIGGERING_COUNT > 0U)
extern FUNC(void, DEM_CODE) Dem_WriteRootErrorQueueEntry(
  Dem_EventIdType RootId);

/** \brief Root-Error-Queue-Access-Function to read the latest entry
 **
 ** \param[in] QueueEntry entry in the Error-Queue
 **
 ** \return DemEventIdType RootId of the entry retrieved from
 **           the error queue
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \pre This function shall be in the context of Dem_ReadErrorQueueEntry()
 **      after retrieving a valid QueueEntry and before the update of
 **      Dem_ErrorQueueReadIdx
 */
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_ReadRootErrorQueueEntry(
    Dem_ErrorQueueEntryType QueueEntry);
#endif

/** \brief Error-Queue-Access-Function to invalidate specific entries
 **
 ** This function invalidates (set entry to ::DEM_EVENT_ID_INVALID) all
 ** entries with the specified event Id.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InvalidateErrorQueueEntry(
  Dem_EventIdType EventId);

/** \brief Error-Queue-Access-Function to read the latest entry
 **
 ** This function always reads and removed the next entry from the
 ** error-queue.
 **
 ** \param[out] QueueEntry
 **
 ** \return Dem_ReadErrorQueueReturnType structure containing latest read
 **           RootId if multi-event triggering feature is enabled
 **           and value indication success
 ** \retval RootId field 0 < RootId <= DEM_MAX_EVENTID
 ** \retval Result field is TRUE entry read from error-queue
 ** \retval Result field is FALSE no entry read from error-queue
 **           as the error-queue is empty
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_ReadErrorQueueReturnType, DEM_CODE) Dem_ReadErrorQueueEntry(
  P2VAR(Dem_ErrorQueueEntryType, AUTOMATIC, AUTOMATIC) QueueEntry);

/** \brief Error-Queue-Access-Function to write the next entry
 **
 ** \param[in] EventInfo Structure containing:
 **              0 < EventId <= DEM_MAX_EVENTID, always
 **              0 < RootId <= DEM_MAX_EVENTID, if multi event triggering
 **              is enabled
 ** \param[in] EventStatus  Status of event to queue. Normally, either
 **              ::DEM_EVENT_STATUS_FAILED or ::DEM_EVENT_STATUS_PASSED, but
 **              if ::DEM_EXTENDED_DATA_CAPTURE is set to
 **              ::DEM_TRIGGER_ON_FDC_THRESHOLD, a status of
 **              ::DEM_EVENT_STATUS_UNCONFIRMED is also possible.
 ** \param[in] FirstFailed if this is the first entry in the queue
 **                        with event failed/confirmed
 **
 ** \return Boolean value indication success
 ** \retval TRUE  an event Id was inserted to the error-queue
 ** \retval FALSE the error-queue was full
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_WriteErrorQueueEntry(
  Dem_EventInfoType   EventInfo,
  Dem_EventStatusType EventStatus,
  boolean             FirstFailed);

#if (DEM_NUM_FAILURECYCLES > 0U)
/** \brief This function updates the event failure counter if event memory
 ** entry exists, creates or updates the failure counter buffer otherwise
 **
 ** Note: If indicated by parameter HandleCDTC it also sets the CDTC status
 **       bit.
 **
 ** \param[in] EventId     1 < EventId <= DEM_MAX_EVENTID
 ** \param[in] HandleCDTC  Boolean indicating, if CDTC bit shall be updated
 **
 ** \return Boolean indicating the failure counter has reached
 **         the failure threshold or not
 ** \retval TRUE  the failure counter reached the threshold
 ** \retval FALSE the failure counter didn't reach the threshold
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \pre This function shall be called from within a critical section
 */
extern FUNC(boolean, DEM_CODE) Dem_IncrementFailureCounter(
  Dem_EventIdType EventId,
  boolean         HandleCDTC);
#endif /* (DEM_NUM_FAILURECYCLES > 0U) */

#if (DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT_FAULT_CONFIRMATION == STD_ON)
/** \brief Function to reset event memory independent status counter
 **
 ** \param[in] EventId 1 < EventId <= DEM_MAX_EVENTID
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ResetStatusCounter(Dem_EventIdType EventId);

/** \brief Function to get the reference to status counter for fault confirmation
 **
 ** \param[in] EventId 1 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Pointer to the status counter.
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \pre This function must only be called for events with fault confirmation enabled.
 */
extern FUNC_P2VAR(Dem_StatusCounterType, DEM_VAR_CLEARED, DEM_CODE)
  Dem_GetStatusCounterReference(Dem_EventIdType EventId);
#endif

/** \brief Internal function to report event status
 **
 ** This helper function is called by the Dem_InternalProcessEventReport()
 **
 ** \param[in] EventInfo Structure containing:
 **              0 < EventId <= DEM_MAX_EVENTID, always
 **              0 < RootId <= DEM_MAX_EVENTID, if multi event triggering
 **              is enabled
 ** \param[in] EventStatus
 **
 ** \return E_NOT_OK if EventStatus is invalid or error-queue is full, E_OK
 **         otherwise
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_InternalSetEventStatus(
  Dem_EventInfoType   EventInfo,
  Dem_EventStatusType EventStatus);

/** \brief Internal function to wrap multi-event triggering functionality
 **
 ** This helper function is called by the APIs Dem_ReportErrorstatus(),
 ** Dem_SetEventStatus() and Dem_MainFunction().
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 ** \param[in] FunctionId Function which has to be called consequent to
 **                       the module initialization state
 **
 ** \return E_NOT_OK if EventStatus is invalid or error-queue is full, E_OK
 **         otherwise
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_InternalProcessEventReport(
  Dem_EventIdType     EventId,
  Dem_EventStatusType EventStatus,
  uint8               FunctionId);

/** \brief Function to process the debouncing of an event
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 ** \param[out] DebounceResult
 **
 ** \return TRUE if debouncing has qualified the event, FALSE otherwise.
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_DebounceEvent(
  Dem_EventIdType                                  EventId,
  P2VAR(Dem_EventStatusType, AUTOMATIC, AUTOMATIC) EventStatus,
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC)      DebounceResult);

/** \brief Process event status reports for SWC events
 **
 ** This function is called by Dem_InternalSetEventStatus() to further
 ** process event status reports, individually for SWC events.
 **
 ** \param[in] EventInfo Structure containing:
 **              0 < EventId <= DEM_MAX_EVENTID, always
 **              0 < RootId <= DEM_MAX_EVENTID, if multi event triggering
 **              is enabled
 ** \param[in] EventStatus
 ** \param[out] SetSwcEventStatusResult
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InternalSetSwcEventStatus(
  Dem_EventInfoType                           EventInfo,
  Dem_EventStatusType                         EventStatus,
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) SetSwcEventStatusResult);

/** \brief Process event status reports for BSW events
 **
 ** This function is called by Dem_InternalSetEventStatus() to further
 ** process event status reports, individually for SWC events.
 **
 ** \param[in] EventInfo Structure containing:
 **              0 < EventId <= DEM_MAX_EVENTID, always
 **              0 < RootId <= DEM_MAX_EVENTID, if multi event triggering
 **              is enabled
 ** \param[in] EventStatus
 ** \param[out] SetBswEventStatusResult
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InternalSetBswEventStatus(
    Dem_EventInfoType                         EventInfo,
  Dem_EventStatusType                         EventStatus,
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) SetBswEventStatusResult);

/** \brief Function to update the status-byte of the event
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_UpdateEventStatusOnQualification(
  Dem_EventIdType             EventId,
  Dem_EventStatusType         EventStatus
#if (DEM_NUM_INDICATOR_LINKS > 0U)
  ,
  boolean                     EventWIRUpdate
#endif /* DEM_NUM_INDICATOR_LINKS */
);

#if (DEM_NUM_CMB_DTCS > 0U)
/** \brief Function to update the combined status-byte of the combined DTC
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID - EventId of an event involved in the combination
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_UpdateCmbDTCStatus(Dem_EventIdType EventId);

/** \brief Function to find the FDC of a combined DTC which is the max FDC of the combined events.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID - EventId of an event involved in the combination
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetFDCOfCmbDTC(
  Dem_EventIdType     EventId,
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)
    FaultDetectionCounter);

/** \brief Function to reset the combined events status.
 ** Used when a cmb event is aged or displaced.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID -
 ** EventId of an event involved in the combination
 ** \param[in] CurrentEventStatusChanged
 ** Was the current event status changed
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ResetStatusForCmbEvents(
  Dem_EventIdType EventId,
  boolean         CurrentEventStatusChanged);
#endif

#if (DEM_NUM_BSW_EVENTS > 0U)
/** \brief Function to process the status of diagnostic events of BSW during pre-Init phase
 **
 ** \param[in] EventInfo Structure containing:
 **              0 < EventId <= DEM_MAX_EVENTID, always
 **              0 < RootId <= DEM_MAX_EVENTID, if multi event triggering
 **              is enabled
 ** \param[in] EventStatus  Monitor test result
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ReportErrorStatusPreInit(
      Dem_EventInfoType EventInfo,
      Dem_EventStatusType EventStatus);
#endif

/** \brief Error-Queue-Access-Function to get the most recent
 ** entry status of an event Id in the error queue
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[out] PreviousEntryStatus  Returns the previous status of
 **               the queued entry. Normally, either
 **               ::DEM_EVENT_STATUS_FAILED or ::DEM_EVENT_STATUS_PASSED, but
 **               if ::DEM_EXTENDED_DATA_CAPTURE is set to
 **               ::DEM_TRIGGER_ON_FDC_THRESHOLD, a status of
 **               ::DEM_EVENT_STATUS_UNCONFIRMED is also possible.
 **
 ** \return Boolean value indicating presence of event Id in error-queue
 ** \retval TRUE  an event Id was already present in the error-queue
 ** \retval FALSE event Id was not present in the error-queue
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_CheckErrorQueueEntry(
  Dem_EventIdType                                  EventId,
  P2VAR(Dem_EventStatusType, AUTOMATIC, AUTOMATIC) PreviousEntryStatus);

/** \brief Error-Queue-Access-Function to get the most recent
 ** entry status of an event Id in the error queue
 **
 ** \param[in] EventInfo Structure containing:
 **              0 < EventId <= DEM_MAX_EVENTID, always
 **              0 < RootId <= DEM_MAX_EVENTID, if multi event triggering
 **              is enabled
 ** \param[in] EventStatus
 ** \param[in] OldDTCStatusMask original status before processing
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_CheckErrorReQueueEntry(
  Dem_EventInfoType           EventInfo,
  Dem_EventStatusType         EventStatus,
  Dem_EventStatusExtendedType OldDTCStatusMask,
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) SetBswEventStatusResult);

/** \brief Error-Queue-Access-Function to to check if the most recent event
 **  entry is existing with the requested status
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EntryStatus
 **
 ** \return Boolean value indicating presence of event Id in error-queue
 ** \retval TRUE  an event Id with requested status was already present in the
 **               error-queue
 ** \retval FALSE event Id was not present in the error-queue with requested
 **               status
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_CheckErrorQueueEntryForStatus(
  Dem_EventIdType     EventId,
  Dem_EventStatusType EntryStatus);

#if (DEM_NUM_FFSEGS > 0U)
/** \brief Function to get the size of a freeze frame by the given freeze
 ** frame class
 **
 ** \param[in] FFKind  Kind of freeze frame
 ** \param[in] IndividPartFFClass  Class of individual freeze frame part
 **
 ** \return Size of the freeze frame class
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeFFType, DEM_CODE) Dem_SizeOfFF(
  Dem_FFKindType                                 FFKind,
  P2CONST(Dem_FFClassType, AUTOMATIC, DEM_CONST) IndividPartFFClass);

/** \brief Function to get the size of a freeze frame by the given freeze
 ** frame segment
 **
 ** \param[in] FFSegment
 **
 ** \return Size of the freeze frame segment
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeFFType, DEM_CODE) Dem_SizeOfFFSegment(
  P2CONST(Dem_FFSegmentType, AUTOMATIC, DEM_CONST) FFSegment);

/** \brief Function to get the number of DIDs per freeze frame by the given
 ** freeze frame class
 **
 ** Since DIDs assigned to a freeze frame class may re-calibrated, this is
 ** encapsulated by a helper function.
 **
 ** \param[in] FFKind  Kind of freeze frame
 ** \param[in] IndividPartFFClass  Class of individual freeze frame part
 **
 ** \return Number of DIDs
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_NumFFSegsType, DEM_CODE) Dem_GetNumFFSegs(
  Dem_FFKindType                                 FFKind,
  P2CONST(Dem_FFClassType, AUTOMATIC, DEM_CONST) IndividPartFFClass);
#endif

#if (DEM_NUM_EDSEGS > 0U)
/** \brief Function to get the size of an extended data by the given extended
 ** data class
 **
 ** \param[in] EDClass
 **
 ** \return Size of the extended data class
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeEDType, DEM_CODE) Dem_SizeOfED(
  P2CONST(Dem_EDClassType, AUTOMATIC, DEM_CONST) EDClass);

/** \brief Function to get the size of an extended data by the given extended
 ** data segment
 **
 ** \param[in] EDSegment
 **
 ** \return Size of the extended data segment
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeEDType, DEM_CODE) Dem_SizeOfEDSegment(
  P2CONST(Dem_EDSegmentType, AUTOMATIC, DEM_CONST) EDSegment);

#if (DEM_USE_MAPPED_INT_DATA_ELEMENTS == STD_ON)
/** \brief Function to get the size of internal values mapped to an extended
 ** data segment
 **
 ** \param[in] EDSegment
 **
 ** \return Size of mapped internal values. This along with the size returned
 **         by Dem_SizeOfEDSegment() gives the size required for storing the
 **         assembled extended data segment (record).
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeEDType, DEM_CODE) Dem_SizeOfMapIntValSegment(
  P2CONST(Dem_EDSegmentType, AUTOMATIC, DEM_CONST) EDSegment);
#endif

/** \brief Function to assemble the extended data record to translate and
 ** transfer internal data-structures into correct output-buffer format/layout
 **
 ** \param[in] EventId Id of the event for which the EDR is requested.
 ** \param[in] EDSegment
 ** \param[in] EDStartByte
 ** \param[in] DestBuffer
 ** \param[in] EvMemEntry  Pointer to event memory entry. Can be NULL_PTR if
 **                         the EDR is always available.
 **
 ** \return Size of the extended data segment without considering the
 **         size of mapped internal values
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeEntryDataType, DEM_CODE) Dem_AssembleExtendedDataSeg(
  Dem_EventIdType                                  EventId,
  P2CONST(Dem_EDSegmentType, AUTOMATIC, DEM_CONST) EDSegment,
  Dem_EDStartByteType                              EDStartByte,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)           DestBuffer,
  Dem_EventMemoryEntryPtrConstType                 EvMemEntry);

/** \brief Function to get the index of an extended data segment by the given
 ** extended data number
 **
 ** \param[in] EDClass
 ** \param[in] Number  ED record number
 **
 ** \return Index of the extended data segment
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_EDSegIdxType, DEM_CODE) Dem_FindEDNumIndex(
  P2CONST(Dem_EDClassType, AUTOMATIC, DEM_CONST) EDClass,
  uint8                                          Number);
#endif /* DEM_NUM_EDSEGS > 0U */

#if (DEM_USE_INT_VAL_AREA == STD_ON)
/** \brief Function to get the size of internal values in an event
 **
 ** \param[in] EventId
 **
 ** \return Size of internal values (mapped or unmapped). This can be used
 **         by Dem_FFEntryData(), Dem_EDEntryData() and Dem_EvMemEntrySize()
 **         as they are uneffected with whether the internal value is
 **         mapped or not.
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(uint8, DEM_CODE) Dem_SizeOfIntValArea(Dem_EventIdType EventId);
#endif

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)
/** \brief Function to check if a changed entry has to be stored immediately
 **
 ** This function is the first step of a two step approach used for
 ** store immediate functionality. The complete functionality of this function is
 ** protected by exclusive area.
 ** It checks if immediate storage is required, transfers the event
 ** memory entry into gate-entry and updates the NvM gate status.
 ** If the gate cannot be prepared, it marks the event memory entry as
 ** to be written persistently during shutdown.
 **
 ** \param[in] OriginalEventId  if event memory entry is displaced then this
 **                    corresponds to the event Id of the entry which was
 **                    displaced by a new event, otherwise it corresponds to
 **                    the event Id of the updated event.
 **                    During displacement the current event Id can be
 **                    derived from the event memory entry.
 ** \param[in] EvMemEntryPtr  pointer to the selected entry
 ** \param[in] EvMemEntryIdx  index of the selected entry
 ** \param[in] ForceWrite  specifies if the entry needs to be stored
 **                    immediately independent from configuration
 **
 **/
extern FUNC(void, DEM_CODE) Dem_CheckForImmediateEntryStorage(
  Dem_EventIdType             OriginalEventId,
  Dem_EventMemoryEntryPtrType EvMemEntryPtr,
  Dem_SizeEvMemEntryType      EvMemEntryIdx,
  boolean                     ForceWrite);

/** \brief Function to store given entry to the NvRAM by using the gate-entry
 **
 ** This function has to be called while the entry related to the given index
 ** is protected against modification.
 **
 ** \param[in] OriginIdx
 ** \param[in] EntryIdx
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DEM_CODE) Dem_StoreImmediately(
  uint8                  OriginIdx,
  Dem_SizeEvMemEntryType EntryIdx);

#if (DEM_CLEAR_DTC_BEHAVIOR != DEM_CLRRESP_VOLATILE)
/** \brief Function to trigger the NvM write of the event status bytes
 **
 ** This function checks if the status block can be written persistently.
 ** It calls NvM_WriteBlock() and if it fails because of an error, it
 ** reschedules the block to be written on shutdown (no retry by Dem module).
 **
 ** \return Std_ReturnType result of NvM_WriteBlock for status block
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(Std_ReturnType, DEM_CODE) Dem_TriggerNvmWriteEventStatus(void);
#endif

/** \brief Function to check a NvM gate status and trigger a new NvM write
 **
 ** This function is the second step of the two step approach
 ** used by the immediate storage functionality.
 **
 ** This function checks all gate entries if one has been prepared to be
 ** written persistently. It calls NvM_WriteBlock() and if it fails because
 ** of an error, it reschedules the block to be written on shutdown (no retry
 ** by Dem module).
 ** Function is accessing data which has to be protected by Critical Section.
 ** We know from client that there are scenarios in which this function is
 ** called multiple times. Because run time given by the entry/exit
 ** critical section is consisent in comparison to the Dem code, function
 ** is designed to have as few as possible entries/exits in critical sections.
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DEM_CODE) Dem_CheckForTriggerNvmWriteGateEntry(void);
#endif /* DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON */

#if (DEM_USE_AGING == STD_ON)
/** \brief Clear aged event from event memory
 **
 ** \param[in] EventId
 ** \param[in] EvMemEntry
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ClearAgedEventEntry(
  Dem_EventIdType             EventId,
  Dem_EventMemoryEntryPtrType EvMemEntry);
#endif

/* !LINKSTO Dem_OBD_0005,1 */
#if (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U)
/** \brief This function is used to notify about a ClearDTC request affecting
 ** an entry in the primary memory, so that the status of the permanent memory
 ** entry for the same event, if any, can be appropriately updated.
 **
 ** \return void
 **
 ** \param[in] EventId          1 <= EventId < DEM_MAX_EVENTID
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem_OBD_0083,1 */
extern FUNC(void, DEM_CODE) Dem_PermanentMemoryNotifyClear(
  Dem_EventIdType EventId);

/** \brief This function is used for storing a new EventId
 **        in permanent memory
 **
 ** \return Std_ReturnType value indication success
 ** \retval E_OK       Event was stored in permanent memory
 ** \retval E_NOT_OK   Event was not stored in permanent memory
 **
 ** \param[in] EventId          1 <= EventId < DEM_MAX_EVENTID
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem_OBD_0027,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_PermanentMemoryAddEntry(
  Dem_EventIdType EventId);

/** \brief This function is used for removing the EventId
 **        from permanent memory due to healing of the MIL.
 **
 ** \return Std_ReturnType value indication success
 ** \retval E_OK       Event was removed from permanent memory
 ** \retval E_NOT_OK   Event was not part of permanent memory
 **
 ** \param[in] EventId          1 <= EventId < DEM_MAX_EVENTID
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \pre This function shall be called from within a critical section only.
 */
/* !LINKSTO Dem_OBD_0040,1 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_PermanentMemoryRemoveEntry(
  Dem_EventIdType EventId);

/** \brief This function is used checks for permanent faults after code clear
 **        if the conditions are fulfilled to leave the permanent memory and
 **        fills up empty spaces in the permanent memory with other events
 **        committing the MIL.
 **
 ** \return none
 **
 ** \param[in] none
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO Dem_OBD_0044,1 */
extern FUNC(void, DEM_CODE) Dem_PermanentMemoryStatusUpdate(void);

#endif /* (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U) */

#if (DEM_OBDFF_SUPPORT_KIND == DEM_OBDFF_SINGLE)
/** \brief This function handles the storage and update of the OBD freeze frame
 **
 ** NOTE: The EventId given to this function must be an OBD relevant EventId
 **       that has an OBD DTC configured. This has to be checked before calling this function.
 **
 ** \param[in] EventId    0 < EventId <= DEM_MAX_EVENTID
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ProcessSingleOBDFreezeFrame(
  Dem_EventIdType EventId);

/** \brief Function to clear the OBD freeze frame
 **
 ** This function shall be called regardless of the DTC kind.
 **
 ** \param[in] EventId  event ID of event whose OBD FF shall be cleared
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
/* !LINKSTO dsn.Dem.OBD.Dem_ClearSingleOBDFreezeFrame,2 */
extern FUNC(void, DEM_CODE) Dem_ClearSingleOBDFreezeFrame(Dem_EventIdType EventId);

/** \brief Function to reset the non-volatile Dem data for the OBD freeze frame
 ** NOTE: No explicit reset for Multiple OBD FF Nv data
 **       the reset of event memory entry is sufficient
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
/* !LINKSTO dsn.Dem.OBD.Dem_ResetSingleOBDFreezeFrameNvData,1 */
extern FUNC(void, DEM_CODE) Dem_ResetSingleOBDFreezeFrameNvData(void);
#elif (DEM_OBDFF_SUPPORT_KIND == DEM_OBDFF_MULTIPLE)

/** \brief This function handles the storage and update of multiple OBD freeze frame
 **
 ** NOTE: The EventId given to this function must be an OBD relevant EventId
 **       that has an OBD DTC configured. This has to be checked before calling this function.
 **
 ** \param[in] EventId    Id of the event which triggered the capture of OBD Freeze Frame
 ** \param[in] EventMemoryEntryIdx    The index of the event memory entry which triggered the
 **                                   capture of OBD Freeze Frame.
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ProcessMultipleOBDFreezeFrameEntry(
  Dem_EventIdType         EventId,
  Dem_SizeEvMemEntryType  EventMemoryEntryIdx);

/** \brief Check if an OBD Freeze Frame can be selected for reporting in service $02 or $19 04
 **
 ** \param[out] SelectedEntryIndex   The index of the Event Entry which will report
 **                                  the OBD Freeze Frame.
 ** \param[in] SelectForReport   Parameter indicating if this function was called
 **                              by an API for reporting an OBD Freeze Frame.
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_SelectEntryOfOBDFreezeFrameEvent(
  P2VAR(Dem_SizeEvMemEntryType, AUTOMATIC, DEM_APPL_DATA) SelectedEntryIndex,
  boolean                                                 SelectForReport);
#endif /* (DEM_OBDFF_SUPPORT_KIND == DEM_OBDFF_MULTIPLE) */


#if (DEM_SUPPRESSION_SUPPORT == DEM_DTC_SUPPRESSION)
/** \brief Internal function to set the suppression status of a specific DTC.
 **
 ** \param[in] DTC  Diagnostic Trouble Code
 ** \param[in] DTCFormat  Defines the input-format of the provided DTC value.
 ** \param[in] SuppressionStatus  This parameter specifies whether
 **                     the respective DTC shall be disabled (TRUE)
 **                     or enabled (FALSE).
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed or event entry for this DTC still exists
 **
 ** \ServiceID{::DEM_SID_SetDTCSuppression}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_InternalSetDTCSuppression(
  uint32            DTC,
  Dem_DTCFormatType DTCFormat,
  boolean           SuppressionStatus);
#endif /* (DEM_SUPPRESSION_SUPPORT == DEM_DTC_SUPPRESSION) */

#if ( (DEM_NUM_J1939FFSPNS > 0U) && (DEM_J1939_FREEZEFRAME_SUPPORT==STD_ON) )

/** \brief Function to get the size of a J1939 freeze frame by the given J1939 freeze
 ** frame class
 **
 ** \param[in] J1939FFClass  Class of freeze frame
 **
 ** \return Size of the freeze frame class
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeJ1939FFType, DEM_CODE) Dem_SizeOfJ1939FF(
  P2CONST(Dem_J1939FFClassType, AUTOMATIC, DEM_CONST) J1939FFClass);
/** \brief Get J1939FF-class-index from ::Dem_EventDesc by using index
 **
 ** \param[in] EventId  related event id
 **
 ** \return Index of the J1939FF class
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_J1939FFClassIdxType, DEM_CODE) Dem_GbiJ1939FFClassIdx(Dem_EventIdType EventId);

/** \brief Function which processes the J1939 freeze frame data of a reported event
 **
 ** It is used by Dem_ProcessEventEntry().
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EvMemEntryPtr  Pointer to event memory entry where to store
 **                           data
 **
 ** \return Boolean value indicating if a J1939 freeze frame was stored/updated
 ** \retval TRUE J1939 freeze frame was stored/updated
 ** \retval FALSE J1939 freeze frame was not stored/updated
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_ProcessEventEntryJ1939FFData(
  Dem_EventIdType             EventId,
  Dem_EventMemoryEntryPtrType EvMemEntryPtr);

  /** \brief Function to copy J1939 freeze frame data destination buffer
 **
 ** \param[in] EventId
 ** \param[in] BufSize
 ** \param[out] DestBuffer
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE )
  Dem_CollectJ1939FFInfo(
    Dem_EventIdType                         EventId,
    P2VAR(Dem_EventMemoryEntryPtrType, AUTOMATIC, AUTOMATIC) EvMemEntry,
    P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) BufSize,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer);
#endif /* (DEM_NUM_J1939FFSPNS > 0U) && (DEM_J1939_FREEZEFRAME_SUPPORT==STD_ON) */
/*------------------[Getter-Functions for the Event Descriptions]-----------*/

#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
/** \brief Retrieves the index of the associated DTC in Dem_DTCDesc[].
 */
extern FUNC(Dem_DTCConfIdxType, DEM_CODE) Dem_GbiDTCConfIdx(Dem_EventIdType EventId);
#endif

/** \brief Retrieves the Uds DTC from Dem_EventDesc.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return DEM_NO_DTC if no UDS DTC is assigned to the event, otherwise the assigned
 **         UDS DTC value
 */
extern FUNC(uint32, DEM_CODE) Dem_GbiUdsDTC(Dem_EventIdType EventId);

/** \brief Get UDS DTC value from configured callout function if ::DEM_USE_DYNAMIC_DTCS
 ** is enabled, else from ::Dem_EventDesc by using index
 **
 ** This function reads the assigned UDS DTC regardless of the event availability
 ** and the DTC suppression status.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return DEM_NO_DTC if no UDS DTC is assigned to the event, otherwise the assigned
 **         UDS DTC value
 */
extern FUNC(uint32, DEM_CODE) Dem_GetUdsDTC(Dem_EventIdType EventId);

/** \brief Get UDS DTC value from configured callout function if ::DEM_USE_DYNAMIC_DTCS
 ** is enabled, else from ::Dem_EventDesc by using index if the event is enabled and
 ** the DTC is not suppressed
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return DEM_NO_DTC if the event is not available or no UDS DTC is assigned to
 **         the event or if the UDS DTC is suppressed, otherwise the assigned
 **         UDS DTC value
 */
extern FUNC(uint32, DEM_CODE) Dem_GetVisibleUdsDTC(Dem_EventIdType EventId);

/** \brief Get DTC value from Dem_GetVisibleObdDTC() if OBD support is enabled and
 ** if DTCFormat is DEM_DTC_FORMAT_OBD, or from Dem_GetVisibleUdsDTC() for the given
 ** event or lowest available event of the event combination where EventId belongs to
 ** if DTCFormat is DEM_DTC_FORMAT_UDS
 **
 ** This function handles single and combined events. For combined events, the search
 ** for a visible DTC starts with the master event i.e. the lowest configured event id
 ** of the event combination.
 ** Event combination is currently only supported for UDS DTCs.
 **
 ** \param[in] DTCFormat  Selects the DTC format.
 ** \param[in] EventId    0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return DEM_NO_DTC if the given event or no event of the event combination is
 ** available or if no DTC is assigned to the event or any of the available combined
 ** events or if the DTC is suppressed, otherwise the assigned DTC value of the
 ** given event/lowest combined event
 */
extern FUNC(uint32, DEM_CODE) Dem_GetVisibleCmbDTC(
  Dem_DTCFormatType DTCFormat,
  Dem_EventIdType   EventId);

#if (DEM_J1939_SUPPORT == STD_ON)
/** \brief Get J1939 DTC value from ::Dem_J1939Config by using index.
 **
 ** This function reads the assigned J1939 DTC regardless of the event availability
 ** and the DTC suppression status.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return DEM_NO_DTC if no J1939 DTC is assigned to the event, otherwise the assigned
 **         J1939 DTC value
 */
extern FUNC(uint32, DEM_CODE) Dem_GetJ1939DTC(Dem_EventIdType EventId);
#endif

#if ((DEM_J1939_SUPPORT == STD_ON) && (DEM_J1939_READING_DTC_SUPPORT == STD_ON))
/** \brief Trigger J1939 Dcm callback in case this event has references a DTC with J1939 value.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 */
extern FUNC(void, DEM_CODE) Dem_CbTriggerJ1939Dcm(Dem_EventIdType EventId);
#endif

#if (DEM_J1939_SUPPORT == STD_ON)
/** \brief Function to check if an event will be deleted.
 **
 ** \param[in]  DTCTypeFilter
 ** \param[in]  Node
 ** \param[in]  EventId
 **
 ** \return Result of the check
 ** \retval TRUE  Check passed; the event state matches the filter and will be deleted
 ** \retval FALSE  Check failed; the event state doesn't match the filter and won't be deleted
 */

FUNC(boolean, DEM_CODE) Dem_J1939DcmClearFilterCheck(
  Dem_J1939DcmSetClearFilterType   DTCTypeFilter,
  uint8                            Node,
  Dem_EventIdType                  EventId);
#endif
/* !LINKSTO Dem_OBD_0001,2 */
#if (DEM_OBD_Support == STD_ON)
/** \brief Get OBD DTC value from ::Dem_OBDConfig by using index.
 **
 ** This function reads the assigned OBD DTC regardless of the event availability
 ** and the DTC suppression status.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return DEM_NO_DTC if no OBD DTC is assigned to the event, otherwise the assigned
 **         OBD DTC value
 */
extern FUNC(uint32, DEM_CODE) Dem_GetObdDTC(Dem_EventIdType EventId);

/** \brief Get OBD DTC value from ::Dem_OBDConfig by using index if the event is enabled
 ** and the DTC is not suppressed
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return DEM_NO_DTC if the event is not available or no OBD DTC is assigned to
 **         the event or if the OBD DTC is suppressed, otherwise the assigned
 **         OBD DTC value
 */
extern FUNC(uint32, DEM_CODE) Dem_GetVisibleObdDTC(Dem_EventIdType EventId);
#endif /* (DEM_OBD_Support == STD_ON) */

/** \brief Get DTC kind from ::Dem_EventDesc by using index
 **
 ** Note: returns ::DEM_DTC_KIND_ALL_DTCS, always since no OBD support
 */
extern FUNC(Dem_DTCKindType, DEM_CODE) Dem_GbiDTCKind(
  Dem_EventIdType EventId);

/** \brief Get DTC value from Dem_GetVisibleObdDTC() if OBD support is enabled and
 ** if DTCFormat is DEM_DTC_FORMAT_OBD, or from Dem_GetVisibleUdsDTC() if DTCFormat
 ** is DEM_DTC_FORMAT_UDS
 **
 ** \param[in] DTCFormat  Selects the DTC format.
 ** \param[in] EventId    0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return DEM_NO_DTC if no DTC is assigned to the event or if the DTC is
 **         suppressed, otherwise the DTC value
 */
extern FUNC(uint32, DEM_CODE) Dem_GetVisibleDTC(
  Dem_DTCFormatType DTCFormat,
  Dem_EventIdType   EventId);

/** \brief Get DTC-origin from ::Dem_EventDesc by using index */
/* !LINKSTO dsn.Dem.EventMemories.GbiOrigin,1 */
extern FUNC(Dem_DTCOriginType, DEM_CODE) Dem_GbiDTCOrigin(
  Dem_EventIdType EventId);

/** \brief Get DTC-origin index from ::Dem_EventDesc by using index */
/* !LINKSTO dsn.Dem.EventMemories.GbiOriginIdx,1 */
extern FUNC(uint8, DEM_CODE) Dem_GbiDTCOriginIdx(Dem_EventIdType EventId);

/** \brief Get DTC-group-index from ::Dem_EventDesc by using index */
extern FUNC(uint8, DEM_CODE) Dem_GbiDTCGroupIdx(Dem_EventIdType EventId);

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)
/** \brief Get enable-immediate storage-flag from ::Dem_EventDesc by using
 ** index */
extern FUNC(boolean, DEM_CODE) Dem_GbiImmediateStorage(
  Dem_EventIdType EventId);
#endif

/** \brief Get DTC-severity from ::Dem_EventDesc by using index
 **
 ** Note: returns ::DEM_SEVERITY_NO_SEVERITY, if no DTC is assigned to the event
 */
extern FUNC(Dem_DTCSeverityType, DEM_CODE) Dem_GbiDTCSeverity(
  Dem_EventIdType EventId);

/** \brief Get DTC functional unit from ::Dem_EventDesc by using index
 **
 ** Note: returns 0, if no DTC is assigned to the event
 */
extern FUNC(uint8, DEM_CODE) Dem_GbiDTCFunctionalUnit(
  Dem_EventIdType EventId);

/** \brief Get FF-class-index from ::Dem_EventDesc by using index */
extern FUNC(Dem_FFClassIdxType, DEM_CODE) Dem_GbiFFClassIdx(
  Dem_EventIdType EventId);

/** \brief Get Event Significance from ::Dem_EventDesc by using index */
extern FUNC(Dem_EvSignificanceType, DEM_CODE) Dem_GbiEvSignificance(
  Dem_EventIdType EventId);

#if (DEM_NUM_FFSEGS > 0U)
/** \brief Get maximal-FF-count from ::Dem_EventDesc by using index */
extern FUNC(Dem_FFIdxType, DEM_CODE) Dem_GbiMaxNumFFRecs(
  Dem_EventIdType EventId);
#endif /* (DEM_NUM_FFSEGS > 0U) */
#if (DEM_FREEZE_FRAME_REC_NUMERATION_TYPE == DEM_FF_RECNUM_CONFIGURED)
/** \brief Get FF record numeration class index from ::Dem_EventDesc by using
 ** index */
extern FUNC(Dem_FFRecNumClassIdxType, DEM_CODE) Dem_GbiFFRecNumClassIdx(
  Dem_EventIdType EventId);
#endif /* (DEM_FREEZE_FRAME_REC_NUMERATION_TYPE == DEM_FF_RECNUM_CONFIGURED) */

/** \brief Get ED-class-index from ::Dem_EventDesc by using index */
extern FUNC(Dem_EDClassIdxType, DEM_CODE) Dem_GbiEDClassIdx(
  Dem_EventIdType EventId);

/** \brief Get operation-cycle-index from ::Dem_EventDesc or ::Dem_EventClass
 **        by using index */
extern FUNC(Dem_OperationCycleIdType, DEM_CODE) Dem_GbiOpCycleIdx(
  Dem_EventIdType EventId);

#if ( (DEM_NUM_INDICATOR_LINKS != 0) && \
      (DEM_EXTENDED_DATA_CAPTURE != DEM_TRIGGER_ON_FDC_THRESHOLD) )
/** \brief Get indicator healing cycle from ::Dem_IndicatorClasses or
 **        ::Dem_EventDesc by using index */
extern FUNC(Dem_OperationCycleIdType, DEM_CODE) Dem_GbiIndicatorHealingCycleIdx(
  Dem_EventIdType      EventId,
  Dem_IndicatorIdxType IndicatorIdx);
#endif

#if (DEM_NUM_INDICATOR_LINKS != 0)
/** \brief Get indicator failure cycle from ::Dem_IndicatorClasses or
 **        ::Dem_EventDesc by using index */
extern FUNC(Dem_OperationCycleIdType, DEM_CODE) Dem_GbiIndicatorFailureCycleIdx(
  Dem_EventIdType      EventId,
  Dem_IndicatorIdxType IndicatorIdx);
#endif

#if (DEM_USE_AGING == STD_ON)
/** \brief Get aging-cycles from ::Dem_EventDesc by using index */
extern FUNC(Dem_AgingCyclesType, DEM_CODE) Dem_GbiNumAgingCycles(
  Dem_EventIdType EventId);
#endif

#if (DEM_NUM_AGINGCYCLES > 0U)
/** \brief Get aging-cycle-index from ::Dem_EventDesc or ::Dem_EventClass
 **        by using index */
extern FUNC(Dem_OperationCycleIdType, DEM_CODE) Dem_GbiAgingCycleIdx(
  Dem_EventIdType EventId);
#endif

/** \brief Get Event failure class index from ::Dem_EventDesc by using index */
extern FUNC(uint16, DEM_CODE) Dem_GbiEventFailureClassIdx(
  Dem_EventIdType EventId);

#if (DEM_NUM_FAILURECYCLES > 0U)
/** \brief Get Event failure cycle from ::Dem_EventDesc or ::Dem_EventClass
 **        by using index */
extern FUNC(Dem_OperationCycleIdType, DEM_CODE) Dem_GbiEventFailureCycleIdx(
  Dem_EventIdType EventId,
  uint16          EventFailureClassIdx);
#endif

#if (DEM_NUM_ENCONDGRP_SINGLEREF > 0)
/** \brief Get enable condition group index from ::Dem_EventDesc or
 ** ::Dem_EventClassDesc by using index */
extern FUNC(Dem_EnCondGrpIdxType, DEM_CODE) Dem_GbiEnCondGrpIdx(
  Dem_EventIdType EventId);
#endif

#if (DEM_MULTI_EVENT_TRIGGERING_COUNT > 0U)
/** \brief Get multi-event triggering master id index
 **  from ::Dem_MultiEventTriggeringMasterEventId using binary-search
 */
extern FUNC(Dem_MultiEventTriggeringMasterIdxType, DEM_CODE)
  Dem_GetMultiEventTriggeringMasterIdx(Dem_EventIdType EventId);

/** \brief Get multi-event triggering index from ::Dem_EventDesc by using index */
extern FUNC(Dem_MultiEventTriggeringClassIdxType, DEM_CODE)
  Dem_GbiMultiEventTriggeringIdx(Dem_EventIdType EventId);

/** \brief Get pointer to multi-event triggering class element */
extern FUNC_P2CONST(Dem_MultiEventTriggeringType, AUTOMATIC, DEM_CODE)
  Dem_GetMultiEventTriggering(Dem_EventIdType EventId);

/** \brief Finds and return the next event in a multi event triggering table
 ** to be processed
 **
 ** \param[in]    RootId        0 < RootId <= DEM_MAX_EVENTID
 ** \param[in]    LastRetVal    Result of the last event check
 **                             used for stopping in case of exclusive replacement
 ** \param[inout] LastEventId   0 < LastEventId <= DEM_MAX_EVENTID
 **                             Pointer to last processed event id
 **
 ** \return DEM_EVENT_ID_INVALID if no further events to process found,
 **         otherwise the event id
 **
 ** \pre This function must only be called for RootId which is master event
 ** in multi event triggering configuration.
 */
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_FindNextDependentEvent(
  const Dem_EventIdType                        RootId,
  const Std_ReturnType                         LastRetVal,
  P2VAR(Dem_EventIdType, AUTOMATIC, AUTOMATIC) LastEventId
);
#endif /* DEM_MULTI_EVENT_TRIGGERING_COUNT > 0U */

#if (DEM_INDICATORCLASS_SUPPORT == STD_ON)
/** \brief Get indicator-class-index from ::Dem_EventDescClass by using index */
extern FUNC(Dem_IndicatorGrpIdxType, DEM_CODE)
  Dem_GbiIndicatorClassIndex(Dem_EventIdType EventId);
#else
#if (DEM_NUM_INDICATOR_LINKS > 0U)
/** \brief Get indicator-used-flag from ::Dem_EventDesc by using index */
extern FUNC(boolean, DEM_CODE) Dem_GbiIndicatorUsed(
  Dem_EventIdType EventId);
#endif
#endif

#if ((DEM_USE_EVENT_DISPLACEMENT == STD_ON) || (DEM_NUM_OF_PIDS_IN_OBDFF > 0U))
/** \brief Get priority from ::Dem_EventDesc by using index */
extern FUNC(Dem_PriorityType, DEM_CODE) Dem_GbiPriority(
  Dem_EventIdType EventId);
#endif

#if ((DEM_DEV_ERROR_DETECT == STD_ON) || (DEM_MAX_NUMBER_PRESTORED_FF > 0U))
/** \brief Get enable-prestorage-flag from ::Dem_EventDesc by using index */
extern FUNC(boolean, DEM_CODE) Dem_GbiEnablePrestorage(
  Dem_EventIdType EventId);
#endif

/** \brief Get debounce algorithm from ::Dem_EventDesc by using index */
extern FUNC(Dem_DebounceType, DEM_CODE) Dem_GbiDebounceAlgo(
  Dem_EventIdType EventId);

#if (DEM_NUM_DEBOUNCE_COUNTER > 0U)
/** \brief Get debounce class index from ::Dem_EventDesc by using index */
extern FUNC(Dem_DebounceCounterClassIdxType, DEM_CODE) Dem_GbiDebounceCounterClassIdx(
  Dem_EventIdType Index);
#endif

#if ((DEM_NUM_DEBOUNCE_COUNTER > 0U) || (DEM_NUM_DEBOUNCE_COUNTER_PERM > 0U))
/** \brief Get debounce status index */
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_GbiDebounceStatusIdx(
  Dem_EventIdType EventId);
#endif

#if ((DEM_NUM_DEBOUNCE_TIME > 0U) || (DEM_NUM_DEBOUNCE_FREQUENCY > 0U))
/** \brief Get debounce index */
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_GbiDebounceIdx(
  Dem_EventIdType EventId);
#endif

#if (DEM_NUM_DEBOUNCE_TIME > 0U)
/** \brief Get Time debounce Class index */
extern FUNC(Dem_DebounceTimeClassIdxType, DEM_CODE) Dem_GbiDebounceTimeClassIdx(
  Dem_EventIdType Index);
#endif

/** \brief Get Event-kind from ::Dem_EventDesc by using index */
extern FUNC(Dem_EventKindType, DEM_CODE) Dem_GbiEventKind(
  Dem_EventIdType EventId);

/* !LINKSTO Dem_OBD_0001,2 */
#if (DEM_OBD_Support == STD_ON)
/** \brief Get Min Ratio information of Event */
/* !LINKSTO dsn.Dem.OBD.config.OBDEvConf1.MinRatioEvent.0002,1 */
extern FUNC(boolean, DEM_CODE) Dem_GbiMinRatioEvent(Dem_EventIdType EventId);

#if (DEM_MAX_EVENTS_PER_READINESS_GROUP == 0U)
/** \brief Function to get the ReadinessGroup of an Event */
/* !LINKSTO dsn.Dem.OBDPidSupport.Dem_GbiOBDReadinessGroup_01,2 */
extern FUNC(Dem_EventOBDReadinessGroupType, DEM_CODE) Dem_GbiOBDReadinessGroup(
  Dem_EventIdType EventId);
#endif /* (DEM_MAX_EVENTS_PER_READINESS_GROUP == 0U) */

#if (DEM_VCC_OCC5_USED == STD_ON)
/** \brief Function to get the OBD Aging CYcle Counter Threshold of an Event */
extern FUNC(uint8, DEM_CODE) Dem_GbiOBDAgingCycleCounterThreshold(
  Dem_EventIdType EventId);
#endif /* (DEM_VCC_OCC5_USED == STD_ON) */
#endif /* (DEM_OBD_Support == STD_ON) */

#if (DEM_FREEZE_FRAME_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD)
extern FUNC(boolean, DEM_CODE)
  Dem_GbiFreezeFrameUpdate(Dem_EventIdType EventId);
#endif /* (DEM_FREEZE_FRAME_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD) */

#if (DEM_NUM_INDICATOR_LINKS > 0U)
/** \brief Internal function for reading the status of an indicator.
 **
 ** This function shall be used to read the indicator-status derived from the
 ** event status as a summary of all assigned events.
 **
 ** \param[in] IndicatorId  Number of indicator
 **
 ** \return Status of the indicator, like on, off, blinking.
 ** \retval DEM_INDICATOR_OFF         Indicator off mode
 ** \retval DEM_INDICATOR_CONTINUOUS  Indicator continuously on mode
 ** \retval DEM_INDICATOR_BLINKING    Indicator blinking mode
 ** \retval DEM_INDICATOR_BLINK_CONT  Indicator blinking or continuously on mode
 ** \retval DEM_INDICATOR_SLOW_FLASH  Indicator slow flash mode
 ** \retval DEM_INDICATOR_FAST_FLASH  Indicator fast flash mode
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_IndicatorStatusType, DEM_CODE) Dem_InternalGetIndicatorStatus(
  Dem_IndicatorIdType IndicatorId, boolean NeedOnlyOnOffStatus);
#endif

/*------------------[Interface Dem <--> SW-Components / BSW modules]--------*/

#if (DEM_USE_CB_INIT_MONITOR == STD_ON)
/** \brief Wrapper-Function to call init-monitor-for-event functions
 **
 ** Dem_CbInitMonitorForEvent shall be enabled only if
 ** either RTE callback or C callback is configured for Init Monitor.
 **
 ** This must be done by a wrapper, because it depends on configuration.
 **
 ** \param[in] EventId  0 < EventId < DEM_NUMBER_OF_EVENTS
 ** \param[in] InitMonitorKind
 **
 ** \pre This function must only be called with consistent input-data of
 ** Dem_CbProperty[] and Dem_CbLookupTableInitMonitor[].
 */
extern FUNC(void, DEM_CODE) Dem_CbInitMonitorForEvent(
  Dem_EventIdType           EventId,
  Dem_InitMonitorReasonType InitMonitorReason);
#endif

#if (DEM_USE_CB_TRIG_ON_STATUS_CHANGE == STD_ON)
/** \brief Wrapper-Function to call trigger-on-event-status functions
 **
 ** Dem_CbTriggerOnEventStatus shall be enabled only if
 ** either RTE callback or C callback is configured for Trigger on Event or DTC.
 **
 ** This must be done by a wrapper, because it depends on configuration.
 **
 ** \param[in] EventId  0 < EventId < DEM_NUMBER_OF_EVENTS
 ** \param[in] OldDTCStatusMask
 ** \param[in] NewDTCStatusMask
 */
extern FUNC(void, DEM_CODE) Dem_CbTriggerOnEventStatus(
  Dem_EventIdType       EventId,
  Dem_DTCStatusMaskType OldDTCStatusMask,
  Dem_DTCStatusMaskType NewDTCStatusMask);
#endif

#if (DEM_USE_CB_TRIG_ON_EVDAT == STD_ON)
/** \brief Wrapper-Function to call event-data-changed functions
 **
 ** Dem_CbTriggerOnEventData shall be enabled only if
 ** either RTE callback or C callback is configured for
 ** TriggerOnEventDataChanged, or basic RTE support is enabled.
 **
 ** This must be done by a wrapper, because it depends on configuration.
 **
 ** \param[in] EventId  0 < EventId < DEM_NUMBER_OF_EVENTS
 */
extern FUNC(void, DEM_CODE) Dem_CbTriggerOnEventData(
  Dem_EventIdType EventId);
#endif

#if (DEM_USE_CB_GET_FDC == STD_ON)
/** \brief Wrapper-Function to call get-fault-detection-counter functions
 **
 ** Dem_CbGetFaultDetectionCounter shall be enabled only if
 ** either RTE callback or C callback is configured for FDC.
 **
 ** This must be done by a wrapper, because it depends on configuration.
 **
 ** \param[in] EventId  0 < EventId < DEM_NUMBER_OF_EVENTS
 ** \param[out] FDC
 **
 ** \return E_OK if FDC could be acquired, E_NOT_OK otherwise
 **
 ** \pre This function must only be called with consistent input-data of
 ** Dem_CbProperty[] and Dem_CbLookupTableGetFDC[].
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_CbGetFaultDetectionCounter(
  Dem_EventIdType                                                EventId,
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)                         FDC);
#endif

/*------------------[functions for debouncing]------------------------------*/

#if (DEM_NUM_DEBOUNCE_TIME > 0U)
/** \brief "Tick" the timers used for time based debouncing
 **
 ** Dem_DebounceTimeTimerTick shall be enabled only if
 ** time based debounced events is configured.
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_DebounceTimeTimerTick(void);
#endif /* (DEM_NUM_DEBOUNCE_TIME > 0U) */

#if (DEM_NUM_DEBOUNCE_FREQUENCY > 0U)
/** \brief "Tick" the timers used for frequency based debouncing
 **
 ** Dem_DebounceFrequencyTimerTick shall be enabled only if
 ** frequency based debounced events is configured..
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_DebounceFrequencyTimerTick(void);
#endif /* (DEM_NUM_DEBOUNCE_FREQUENCY > 0U) */

#if (DEM_NUM_INDICATOR_LINKS > 0U)
/** \brief Function to check the condition for set WIR-status-bit of event
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus  status of event, either ::DEM_EVENT_STATUS_PASSED
 **              or ::DEM_EVENT_STATUS_FAILED
 ** \param[in] FirstFailed if this is the first failed
 **
 ** \return Boolean value indicating whether the condition for set WIR-status-bit
 **         (bit 7) is satisfied or not.
 ** \retval TRUE  condition for set WIR-status-bit is satisfied
 ** \retval FALSE condition for set WIR-status-bit is not satisfied
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(boolean, DEM_CODE) Dem_CheckForEventWIRUpdate(
  Dem_EventIdType     EventId,
  Dem_EventStatusType EventStatus,
  boolean             FirstFailed);

/** \brief Function to check the condition for set WIR-status-bit of event
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] IndicatorIdx Index of Indicator
 ** \param[in] FirstFailed if this is the first failed
 **
 ** \return Boolean value indicating whether the condition for set WIR-status-bit
 **         (bit 7) is satisfied or not.
 ** \retval TRUE  condition for set WIR-status-bit is satisfied
 ** \retval FALSE condition for set WIR-status-bit is not satisfied
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(boolean, DEM_CODE) Dem_ProcessIndicatorFailureCycleCounter(
  Dem_IndicatorIdxType IndicatorIdx,
  Dem_EventIdType      EventId,
  boolean              FirstFailed);
#endif /* (DEM_NUM_INDICATOR_LINKS > 0U) */

/** \brief This function executes the pending jobs for the event processing.
 **        This includes the update of the EventStatus,
 **        the processing of the event data
 **        and, if configured, the processing OBD freeze frame.
 **
 ** \param[in] EventInfo Structure containing:
 **              0 < EventId <= DEM_MAX_EVENTID, always
 **              0 < RootId <= DEM_MAX_EVENTID, if multi event triggering
 **              is enabled
 ** \param[in] EventStatus  Status of event. Normally, either
 **              ::DEM_EVENT_STATUS_FAILED or ::DEM_EVENT_STATUS_PASSED, but
 **              if ::DEM_EXTENDED_DATA_CAPTURE is set to
 **              ::DEM_TRIGGER_ON_FDC_THRESHOLD, a status of
 **              ::DEM_EVENT_STATUS_UNCONFIRMED is also possible.
 ** \param[in] FirstFailed Whether this is the first failed.
 ** \param[in] Jobs Bitmask specify the jobs have to be handled
 ** \param[in] Notification collecting information for delayed status notifications
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ProcessEvent(
  Dem_EventInfoType                EventInfo,
  Dem_EventStatusType              EventStatus,
  boolean                          FirstFailed,
  Dem_ProcessEventJobMaskType      Jobs,
  Dem_EventNotificationDataPtrType Notification);

#if ( (DEM_USE_CB_TRIG_ON_STATUS_CHANGE == STD_ON) || \
      (DEM_TRIG_CB_ON_EVDAT == STD_ON) )
/** \brief Function to send event status notification messages
 **
 ** This function is used by Dem_MainFunction and Dem_InternalSetSwcEventStatus
 ** to notify (callback) all registered clients about event status changes
 ** done in Dem_ProcessEvent()
 **
 ** \param[in] Notification  Event status and trigger for messages
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ProcessEventNotifications(
  Dem_EventNotificationDataPtrType Notification);
#endif

#if (DEM_GET_DTCBYOCCURRENCETIME_SUPPORT == STD_ON)
/** \brief Function to store event status by occurrence time kind
 **
 ** This function is used by Dem_ProcessEvent(), Dem_InternalSetSwcEventStatus()
 ** and Dem_MainFunction() to store eventIds corresponding to the occurrence kind.
 ** It checks if the current event is stored in primary memory and if the eventId
 ** has an UdsDTC than it stores the eventId corresponding to the occurrence kind.
 **
 ** \param[in] EventId
 ** \param[in] FirstOccurKind First failed/detected confirmed DTC depending
 **                       on the context in which is called.
 ** \param[in] MostRecentOccurKind Most recent failed/detected confirmed DTC depending
 **                        on the context in which is called.
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE)  Dem_UpdateEventIdOccurKinds(
  Dem_EventIdType EventId, Dem_DTCRequestType FirstOccurKind,
  Dem_DTCRequestType MostRecentOccurKind);
#endif

#if (DEM_USE_TRIGGER_DEBOUNCE_BEHAVIOR == STD_ON)
/* !LINKSTO Dem.DebounceBehavior.TriggerDebounceAlgorithm,1 */
/** \brief Function used to handle the reset/freeze of time-,
 **        frequency-based event debouncing depending on the configured
 **        debounce algorithm: RESET or FREEZE.
 **
 ** This function is used for time- and frequency-based debouncing when
 ** the algorithm behavior is configured RESET or FREEZE. CONTINUE is only
 ** relevant for backward compatibility.
 **
 ** This interface exists only if there is at least one event configured with
 ** time-, or frequency-based event debouncing and algorithm behavior is set to
 ** RESET or FREEZE.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_TriggerDebounceAlgorithmBehavior(
  Dem_EventIdType EventId);
#endif

#if (DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING == STD_ON)

/** \brief Function accesses the satellite instance identified by CoreId and
 ** queues the report into the satellite's FIFO list
 **
 ** This function is used to queue BSW event reports received during
 ** ::DEM_PREINITIALIZED state.
 **
 ** \param[in] CoreId  0 <= CoreId < ::DEM_NUMBER_OF_CORES
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 **
 ** \return TRUE data is queued
 **         FALSE data is not queued
 **
 ** \Reentrancy{Non-Reentrant} Must be called inside satellite exclusive area
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_QueueBswEventReportOnSatellite(
  CoreIdType          CoreId,
  Dem_EventIdType     EventId,
  Dem_EventStatusType EventStatus);

/** \brief Function checks if the satellite BSW event report queue is empty
 **
 ** This function is used to check if the satellite instance has synchronized
 ** its queued reports with the master instance already.
 **
 ** \param[in] CoreId  0 <= CoreId < ::DEM_NUMBER_OF_CORES
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 **
 ** \return Boolean TRUE all data is send to master instance from current satellite instance
 **                 FALSE not all data is send to master instance from current satellite instance
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_IsSatelliteQueueEmpty(CoreIdType CoreId);
#endif /* DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING == STD_ON */

/** \brief Mapping of DTCOrigin values
 **
 ** Function for mapping the requested DTCOrigin value to one of the supported
 ** event memories, dependent on whether the DTCOrigin value
 ** complies to ASR43 (Dcm interface) or ASR42 (SW-C/CDD interface).
 **
 ** \param[in] DTCOrigin - Requested event memory origin
 ** \param[in] MappingVariant - Selects the DTCOrigin/event memory mapping variant
 **
 ** \return DTCOrigin - Mapped memory origin or DEM_DTC_ORIGIN_INVALID
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_DTCOriginType, DEM_CODE) Dem_GetMappedDTCOrigin(
  Dem_DTCOriginType         DTCOrigin,
  Dem_DTCOriginMappingType  MappingVariant);

/** \brief Initializes the Event Report Verifier's internal data elements.
 **
 ** \params None
 **
 ** \return void
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InitEventReportVerifier(void);

#if ( (DEM_INIT_MONITOR_REENABLED_SUPPORT == STD_ON) && \
      (DEM_USE_CB_INIT_MONITOR == STD_ON) )
/** \brief Function for calling at most DEM_MAX_NUM_INIT_MONITOR_PER_CYCLE
 ** InitMonitorForEvent callbacks per invocation
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ProcessInitMonitorReenable(void);
#endif

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)
/** \brief Trigger NvM write and update result of event clear process
 **
 ** \param[in]  AnyEventModified
 ** \param[in]  ServiceId
 **
 ** \return Updated result of clear event process
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_TriggerNvmWrite(
  P2CONST(Dem_EventModifiedType, AUTOMATIC, AUTOMATIC) AnyEventModified,
  uint8                                                ServiceId);
#endif

#if (DEM_J1939_SUPPORT == STD_ON)
/** \brief Get J1939 DTC value from configured
 **
 ** Internal function to read the assigned J1939 DTC regardless of the event availability
 ** and the DTC suppression status.
 ** This function shall be used instead of the external wrapper Dem_GetUdsDTC().
 **
 ** \param[in] EventId  0 < EventId < DEM_NUMBER_OF_EVENTS
 **
 ** \return DEM_NO_DTC if no J1939 DTC is assigned to the event, otherwise the assigned
 **         J1939 DTC value
 */
extern FUNC(uint32, DEM_CODE) Dem_InternalGetJ1939DTC(Dem_EventIdType EventId);
#endif

/** \brief Function to shift entry data
 **
 ** \param[in] EntryData
 ** \param[in] Offset
 ** \param[in] Width
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ShiftData(
  Dem_EntryDataPtrType  EntryData,
  Dem_SizeEntryDataType Offset,
  Dem_SizeEntryDataType Width);

#define DEM_STOP_SEC_CODE
#include <Dem_MemMap.h>

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

#define DEM_START_SEC_CONST_8
#include <Dem_MemMap.h>

#if ( (DEM_GENERAL_OBD == STD_ON) && (DEM_OBD_Support_Kind != DEM_OBD_NO_OBD_SUPPORT) )
#if( (DEM_J1939_SUPPORT == STD_ON) && (DEM_J1939_READINESS1_SUPPORT == STD_ON) && (DEM_OBD_ENGINE_TYPE == DEM_IGNITION_COMPRESSION)   )

extern CONST(Dem_EventOBDReadinessGroupType, DEM_CONST)
  Dem_J1939ReadinessGroupCompressionMap[8];

#endif
#endif /* DEM_GENERAL_OBD == STD_ON && DEM_OBD_Support_Kind != DEM_OBD_NO_OBD_SUPPORT */

/** \brief Array holding the number of available slots for development
 **   freeze frames A and B */
extern CONST(uint8, DEM_CONST) Dem_SizeDevFFMem[DEM_NUM_OF_DEVFF_KIND];

#if (DEM_MAX_EVENTS_PER_READINESS_GROUP > 0U)

/** \brief Array holding the list OBD readiness groups in the order of usage
 ** inside PID01 and PID41
 **/
extern CONST(Dem_EventOBDReadinessGroupType, DEM_CONST)
  Dem_OBDReadinessGroupMap[DEM_NUM_OBD_RDY_GROUPS];

#endif

#define DEM_STOP_SEC_CONST_8
#include <Dem_MemMap.h>

#if (DEM_MAX_EVENTS_PER_READINESS_GROUP > 0U)
#define DEM_START_SEC_CONST_16
#include <Dem_MemMap.h>

/** \brief Array holding the Events Id's for every OBD readiness group */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_OBDReadinessGroup
    [DEM_NUM_OBD_RDY_GROUPS][DEM_MAX_EVENTS_PER_READINESS_GROUP];

#define DEM_STOP_SEC_CONST_16
#include <Dem_MemMap.h>
#endif

#define DEM_START_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

/** \brief Array holding the pointers to the array of data of stored
 **   freeze frame A and B
 */
extern CONSTP2VAR(uint8, DEM_CONST, DEM_VAR_CLEARED)
  Dem_DevFFData[DEM_NUM_OF_DEVFF_KIND];

/** \brief Array holding the pointers to the 3 event memories */
extern CONSTP2VAR(Dem_EventMemoryEntryType, DEM_CONST, DEM_VAR_CLEARED)
  Dem_EventMem[DEM_MAXNUM_ORIGINS];

/** \brief Array holding the pointers to the 3 event mem. entry data areas */
extern CONSTP2VAR(Dem_EntryDataType, DEM_CONST, DEM_VAR_CLEARED)
  Dem_EntryData[DEM_MAXNUM_ORIGINS];

/** \brief Array holding the pointers to the 3 event mem. entry data free
 ** positions
 */
extern CONSTP2VAR(Dem_SizeEntryDataType, DEM_CONST, DEM_VAR_CLEARED)
  Dem_EntryDataFreePos[DEM_MAXNUM_ORIGINS];

/** \brief Array holding the pointers to the array of eventIds of stored
 **   freeze frame A and B
 */
extern CONSTP2VAR(Dem_EventIdType, DEM_CONST, DEM_VAR_CLEARED)
  Dem_DevFFEventId[DEM_NUM_OF_DEVFF_KIND];

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

/*------------------[Enable conditions configuration]-----------------------*/

#if (DEM_NUM_ENCONDGROUPS > 0U)
#define DEM_START_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

/** \brief Enable Condition Id / Event Id mapping table
 **
 ** EventId -> EnCondLink[StartIdx..Num] -> EnCondStatus
 **
 ** Number of elements: ::DEM_NUM_ENABLECONDITIONS / no ROM-variable
 */
extern CONST(Dem_EnCondLnkType, DEM_CONST)
  Dem_EnCondToEvIdLink[DEM_NUM_ENABLECONDITIONS + 1U];

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

#define DEM_START_SEC_CONST_8
#include <Dem_MemMap.h>

/** \brief Enable condition group links
 **
 ** accessed via Dem_SetEnableCondition()
 */
extern CONST(Dem_EnCondGrpType, DEM_CONST)
  Dem_EnCondGrpLink[DEM_NUM_ENCONDGRP_LINKS];

#define DEM_STOP_SEC_CONST_8
#include <Dem_MemMap.h>
#endif

/*------------------[Multi event triggering configuration]------------------*/

#if (DEM_MULTI_EVENT_TRIGGERING_COUNT > 0U)
#define DEM_START_SEC_CONST_16
#include <Dem_MemMap.h>

/** \brief Configuration table for multi-event triggering classes
 **
 ** Number of elements: ::DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT / no ROM-variable
 */
extern CONST(Dem_MultiEventTriggeringType, DEM_CONST)
  Dem_MultiEventTriggeringClasses[DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT];

/** \brief Configuration table for multi-event triggering slave event ids
 **
 **  EventId -> MultiEventTriggering[StartIdx..NextIdx] -> MultiEventTriggeringSlaveEventId
 **
 ** Number of elements: ::DEM_MULTI_EVENT_TRIGGERING_SLAVE_COUNT / no ROM-variable
 */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_MultiEventTriggeringSlaveEventId[DEM_MULTI_EVENT_TRIGGERING_SLAVE_COUNT];

/** \brief Configuration table for multi-event triggering master event ids
 **
 ** Number of elements: ::DEM_MULTI_EVENT_TRIGGERING_COUNT / no ROM-variable
 */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_MultiEventTriggeringMasterEventId[DEM_MULTI_EVENT_TRIGGERING_COUNT];

#define DEM_STOP_SEC_CONST_16
#include <Dem_MemMap.h>
#endif

/*------------------[Warning indicators configuration]----------------------*/

#if (DEM_INDICATORCLASS_SUPPORT == STD_ON)

#if (DEM_NUM_INDICATOR_LINKS > 0U)
#define DEM_START_SEC_CALIB_8
#include <Dem_MemMap.h>

/** \brief Configuration description table for warning indicator classes
 **
 ** Number of elements: ::DEM_NUM_INDICATOR_LINKS / no ROM-variable
 */
extern CONST(Dem_IndicatorClassType, DEM_CONST)
  Dem_IndicatorClasses[DEM_NUM_INDICATOR_LINKS];

#define DEM_STOP_SEC_CALIB_8
#include <Dem_MemMap.h>
#endif

#if (DEM_NUM_INDICATOR_GROUPS > 0U)
#define DEM_START_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

/** \brief Configuration table for warning indicator class groups
 **
 ** Number of elements: ::DEM_NUMBER_OF_INDICATOR_GROUPS / no ROM-variable
 */
extern CONST(Dem_IndicatorIdxType, DEM_CONST)
  Dem_IndicatorGroups[DEM_NUM_INDICATOR_GROUPS];

#if (DEM_EVENTCLASS_SUPPORT == STD_OFF)
extern CONST(Dem_IndicatorGrpIdxType, DEM_CONST)
  Dem_EventIndicatorClassIdx[DEM_NUMBER_OF_EVENTS];
#endif

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>
#endif
#else /* (DEM_INDICATORCLASS_SUPPORT == STD_OFF) */

#define DEM_START_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

#if (DEM_NUMBER_OF_INDICATORS > 0U)
/** \brief Configuration description table for warning indicators
 **
 ** Number of elements: ::DEM_NUMBER_OF_INDICATORS / no ROM-variable
 */
extern CONST(Dem_IndicatorDescType, DEM_CONST)
  Dem_IndicatorDesc[DEM_NUMBER_OF_INDICATORS];
#endif

#if (DEM_NUM_INDICATOR_LINKS > 0U)
/** \brief Configuration link table for warning indicator-link
 **
 ** Number of elements: ::DEM_NUM_INDICATOR_LINKS / no ROM-variable
 */
extern CONST(Dem_IndicatorLinkType, DEM_CONST)
  Dem_IndicatorLink[DEM_NUM_INDICATOR_LINKS];
#endif

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

#define DEM_START_SEC_CONST_8
#include <Dem_MemMap.h>

#if (DEM_NUM_HEALINGCYC_COUNTER_INFO_ELEMENTS > 0U)
/** \brief Configuration table for healing cycle-counter information
 **
 ** Number of elements: ::DEM_NUM_HEALINGCYC_COUNTER_INFO_ELEMENTS / no ROM-variable
 */
extern CONST(Dem_CounterInfoType, DEM_CONST)
  Dem_HealingCycleCounterInfo[DEM_NUM_HEALINGCYC_COUNTER_INFO_ELEMENTS];
#endif

#if (DEM_NUM_FAILURECYC_COUNTER_INFO_ELEMENTS > 0U)
/** \brief Configuration table for failure cycle-counter information
 **
 ** Number of elements: ::DEM_NUM_FAILURECYC_COUNTER_INFO_ELEMENTS / no ROM-variable
 */
extern CONST(Dem_CounterInfoType, DEM_CONST)
  Dem_FailureCycleCounterInfo[DEM_NUM_FAILURECYC_COUNTER_INFO_ELEMENTS];
#endif

#define DEM_STOP_SEC_CONST_8
#include <Dem_MemMap.h>
#endif /* (DEM_INDICATORCLASS_SUPPORT == STD_ON) */

/*--------------------------------------------------------------------------*/

#define DEM_START_SEC_CALIB_16
#include <Dem_MemMap.h>

#if (DEM_NUM_DEBOUNCE_COUNTER_CLASSES > 0U)
/** \brief Configuration description table for counter based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_COUNTER_CLASSES / no ROM-variable
 */
extern CONST(Dem_DebounceCounterClassType, DEM_CONST)
  Dem_DebounceCounterClass[DEM_NUM_DEBOUNCE_COUNTER_CLASSES];
#endif

#if (DEM_NUM_DEBOUNCE_COUNTER > 0U)
/** \brief Configuration of debounce class reference
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_COUNTER / no ROM-variable
 */
extern CONST(Dem_DebounceCounterClassIdxType, DEM_CONST)
  Dem_DebounceCounterClassIdx[DEM_NUM_DEBOUNCE_COUNTER];
#endif

#if (DEM_NUM_DEBOUNCE_TIME_CLASSES > 0U)
/** \brief Configuration description table for time based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_TIME_CLASSES / no ROM-variable
 */
extern CONST(Dem_DebounceTimeClassType, DEM_CONST)
  Dem_DebounceTimeClass[DEM_NUM_DEBOUNCE_TIME_CLASSES];
#endif

#if (DEM_NUM_DEBOUNCE_TIME_CLASSES > 0U)
/** \brief Configuration of debounce class reference
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_TIME / no ROM-variable
 */
extern CONST(Dem_DebounceTimeClassIdxType, DEM_CONST)
  Dem_DebounceTimeClassIdx[DEM_NUM_DEBOUNCE_TIME];
#endif

#define DEM_STOP_SEC_CALIB_16
#include <Dem_MemMap.h>

#define DEM_START_SEC_CONST_32
#include <Dem_MemMap.h>

#if (DEM_NUM_DEBOUNCE_TIME > 0U)
/** \brief Configuration description table for time based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_TIME / no ROM-variable
 */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_DebounceTimeCfg[DEM_NUM_DEBOUNCE_TIME];
#endif

#if (DEM_NUM_DEBOUNCE_FREQUENCY > 0U)
/** \brief Configuration description table for frequency based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_FREQUENCY / no ROM-variable
 */
extern CONST(Dem_DebounceFrequencyCfgType, DEM_CONST)
  Dem_DebounceFrequencyCfg[DEM_NUM_DEBOUNCE_FREQUENCY];
#endif

#define DEM_STOP_SEC_CONST_32
#include <Dem_MemMap.h>

#if ( (DEM_NUM_FAILURECYCLES > 0U) && \
      ( (DEM_COMMON_OPERATION_CYCLE_SUPPORT == STD_OFF) || \
        (DEM_EVENTCLASS_SUPPORT == STD_OFF) ) )

#define DEM_START_SEC_CONST_8
#include <Dem_MemMap.h>

/** \brief Configuration description for fault confirmation */
extern CONST(Dem_EventFailureCycleCfgType, DEM_CONST)
  Dem_EventFailureCycleCfg[DEM_NUM_FAILURECYCLES];

#define DEM_STOP_SEC_CONST_8
#include <Dem_MemMap.h>
#endif

#if (DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT_FAULT_CONFIRMATION == STD_ON)
#define DEM_START_SEC_CONST_16
#include <Dem_MemMap.h>

/** \brief Status counter mapping table
 **
 ** access usage:
 ** EventId -> StatusCounterIndex[GroupIdx] -> StatusCounter[FirstIdxInGroup + Offset]
 **
 ** Number of elements: ::DEM_STATUS_COUNTER_INDEX_SIZE / no ROM-variable
 */
extern CONST(Dem_StatusCounterIndexType, DEM_CONST)
  Dem_StatusCounterIndex[DEM_STATUS_COUNTER_INDEX_SIZE];

#define DEM_STOP_SEC_CONST_16
#include <Dem_MemMap.h>
#endif

#define DEM_START_SEC_CONST_8
#include <Dem_MemMap.h>

/** \brief Event callback property table */
extern CONST(Dem_CbPropertyType, DEM_CONST)
  Dem_CbProperty[DEM_NUMBER_OF_EVENTS];

#define DEM_STOP_SEC_CONST_8
#include <Dem_MemMap.h>

#define DEM_START_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

#if (DEM_NUM_FFSEGS > 0U)
/** \brief Freeze frame segments (DIDs)
 **
 ** Number of elements: ::DEM_NUM_FFSEGS
 */
extern CONST(Dem_FFSegmentType, DEM_CONST) Dem_FFSegment[DEM_NUM_FFSEGS];
#endif

#if (DEM_NUM_EDSEGS > 0U)
/** \brief Extended data segments (Records)
 **
 ** Number of elements: ::DEM_NUM_EDSEGS
 */
extern CONST(Dem_EDSegmentType, DEM_CONST) Dem_EDSegment[DEM_NUM_EDSEGS];
#endif

#if (DEM_NUM_EXT_DATAELEMENTS > 0U)
/** \brief External Data Elements
 **
 ** Number of elements: ::DEM_NUM_EXT_DATAELEMENTS
 */
extern CONST(Dem_DataElementType, DEM_CONST)
  Dem_DataElement[DEM_NUM_EXT_DATAELEMENTS];
#endif

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)
/** \brief Gate-entry data to be read from/ written to NvM block */
extern Dem_GateEntryDataPtrVoidType Dem_GateEntryData[DEM_MAXNUM_ORIGINS];

/** \brief Struct containing gate-entry base and data to be read from /
 ** written to NvM block */
extern Dem_NvGateEntryDataPtrVoidType Dem_NvGateEntryData[DEM_MAXNUM_ORIGINS];

/** \brief Array of NvM block Id's on event memories */
extern CONST(NvM_BlockIdType, DEM_CONST)
  Dem_NvDataBlockId[DEM_MAXNUM_ORIGINS];
#endif /* DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON */

#if ( (DEM_NUM_J1939FFSPNS > 0U) && (DEM_J1939_FREEZEFRAME_SUPPORT==STD_ON) )
/** \brief J1939 Freeze frame SPNs
 **
 ** Number of SPNs: ::DEM_NUM_J1939FFSPNS
 */
extern CONST(Dem_DataElementIdxType, DEM_CONST) Dem_J1939FFSPNs[DEM_NUM_J1939FFSPNS];

/** \brief Array containing all J1939 freeze frame classes
 **
 ** Number of elements: ::DEM_NUM_J1939FFCLS
 */
extern CONST(Dem_J1939FFClassType, DEM_CONST)
    Dem_J1939FFClass[DEM_NUM_J1939FFCLS];
#endif
/*-----------------[Generic-Functiontable]----------------------------------*/

#if (DEM_CB_TABLE_INIT_MONITOR_SIZE != 0U)
/** \brief Generic callback function pointer table for InitMonitor */
extern CONST(Dem_CbFuncPtrInitMonitorType, DEM_CONST)
  Dem_CbFuncPtrInitMonitor[DEM_CB_TABLE_INIT_MONITOR_SIZE];
#endif

#if (DEM_CB_TABLE_TRIG_ON_DTCST_SIZE != 0U)
/** \brief Generic callback function pointer table for TriggerOnDTCStatus */
extern CONST(Dem_CbFuncPtrTrigOnDTCStType, DEM_CONST)
  Dem_CbFuncPtrTrigOnDTCSt[DEM_CB_TABLE_TRIG_ON_DTCST_SIZE];
#endif

#if (DEM_CB_TABLE_GET_FDC_SIZE != 0U)
/** \brief Generic callback function pointer table for GetFaultDetectionCounter */
extern CONST(Dem_CbFuncPtrGetFDCType, DEM_CONST)
  Dem_CbFuncPtrGetFDC[DEM_CB_TABLE_GET_FDC_SIZE];
#endif

/*-----------------[C-Functiontable]----------------------------------------*/

#if (DEM_C_CALLBACK_TABLE_TRIG_ON_EVST_SIZE != 0U)
/** \brief C-Callback function pointer table for TriggerOnEventStatus */
extern CONST(Dem_CbFuncPtrTrigOnEvStType, DEM_CONST)
  Dem_CbFuncPtrTrigOnEvSt[DEM_C_CALLBACK_TABLE_TRIG_ON_EVST_SIZE];
#endif

#if (DEM_C_CB_TABLE_TRIG_ON_EVDAT_SIZE != 0U)
/** \brief C-Callback function pointer table for TriggerOnEventDataChanged */
extern CONST(Dem_CbFuncPtrTrigOnEvDatType, DEM_CONST)
  Dem_CbFuncPtrTrigOnEvDat[DEM_C_CB_TABLE_TRIG_ON_EVDAT_SIZE];
#endif

#if (DEM_C_CB_TABLE_CLEAR_EVENT_ALLOWED_SIZE != 0U)
/** \brief C-Callback function pointer table for ClearEventAllowed */
extern CONST(Dem_CbFuncPtrClearEventAllowedType, DEM_CONST)
  Dem_CbFuncPtrClearEventAllowed[DEM_C_CB_TABLE_CLEAR_EVENT_ALLOWED_SIZE];
#endif

/*-----------------[RTE-Functiontable]--------------------------------------*/

#if (DEM_RTE_CALLBACK_TABLE_TRIG_ON_EVST_SIZE != 0U)
/** \brief RTE-Callback function pointer table for TriggerOnEventStatus */
extern CONST(Dem_RteFuncPtrTrigOnEvStType, DEM_CONST)
  Dem_RteFuncPtrTrigOnEvSt[DEM_RTE_CALLBACK_TABLE_TRIG_ON_EVST_SIZE];
#endif

#if (DEM_RTE_CB_TABLE_TRIG_ON_EVDAT_SIZE != 0U)
/** \brief RTE-Callback function pointer table for TriggerOnEventDataChanged */
extern CONST(Dem_RteFuncPtrTrigOnEvDatType, DEM_CONST)
  Dem_RteFuncPtrTrigOnEvDat[DEM_RTE_CB_TABLE_TRIG_ON_EVDAT_SIZE];
#endif

#if (DEM_RTE_CB_TABLE_CLEAR_EVENT_ALLOWED_SIZE != 0U)
/** \brief RTE-Callback function pointer table for ClearEventAllowed */
extern CONST(Dem_CbFuncPtrClearEventAllowedType, DEM_CONST)
  Dem_RteFuncPtrClearEventAllowed[DEM_RTE_CB_TABLE_CLEAR_EVENT_ALLOWED_SIZE];
#endif

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

/*-----------------[Generic-Lookuptable]------------------------------------*/

#define DEM_START_SEC_CONST_16
#include <Dem_MemMap.h>

#if (DEM_LOOKUP_TABLE_INIT_MONITOR_SIZE != 0U)
/** \brief Generic callback function lookup table for InitMonitor */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_CbLookupTableInitMonitor[DEM_LOOKUP_TABLE_INIT_MONITOR_SIZE];
#endif

#if (DEM_LOOKUP_TABLE_GET_FDC_SIZE != 0U)
/** \brief Generic callback function lookup table for GetFaultDetectionCounter */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_CbLookupTableGetFDC[DEM_LOOKUP_TABLE_GET_FDC_SIZE];
#endif

/*-----------------[C-Lookuptable]------------------------------------------*/

#if (DEM_C_LOOKUP_TABLE_TRIG_ON_EVST_SIZE != 0U)
/** \brief C-Callback function lookup table for TriggerOnEventStatus */
extern CONST(Dem_CbLookupTableType, DEM_CONST)
  Dem_CbLookupTableTrigOnEvSt[DEM_C_LOOKUP_TABLE_TRIG_ON_EVST_SIZE];
#endif

#if (DEM_C_LOOKUP_TABLE_TRIG_ON_EVDAT_SIZE != 0U)
/** \brief C-Callback function lookup table for TriggerOnEventDataChanged */
extern CONST(Dem_CbLookupTableType, DEM_CONST)
  Dem_CbLookupTableTrigOnEvDat[DEM_C_LOOKUP_TABLE_TRIG_ON_EVDAT_SIZE];
#endif

#if (DEM_C_LOOKUP_TABLE_CLEAR_EVENT_ALLOWED_SIZE != 0U)
/** \brief C-Callback function lookup table for ClearEventAllowed */
extern CONST(Dem_CbLookupTableType, DEM_CONST)
  Dem_CbLookupTableClearEventAllowed[DEM_C_LOOKUP_TABLE_CLEAR_EVENT_ALLOWED_SIZE];
#endif

/*-----------------[RTE-Lookuptable]----------------------------------------*/

#if (DEM_RTE_LOOKUP_TABLE_TRIG_ON_EVST_SIZE != 0U)
/** \brief RTE-Callback function lookup table for TriggerOnEventStatus */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_RteLookupTableTrigOnEvSt[DEM_RTE_LOOKUP_TABLE_TRIG_ON_EVST_SIZE];
#endif

#if (DEM_RTE_LOOKUP_TABLE_TRIG_ON_EVDAT_SIZE != 0U)
/** \brief RTE-Callback function lookup table for TriggerOnEventDataChanged */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_RteLookupTableTrigOnEvDat[DEM_RTE_LOOKUP_TABLE_TRIG_ON_EVDAT_SIZE];
#endif

#if (DEM_RTE_LOOKUP_TABLE_CLEAR_EVENT_ALLOWED_SIZE != 0U)
/** \brief RTE-Callback function lookup table for ClearEventAllowed */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_RteLookupTableClearEventAllowed[DEM_RTE_LOOKUP_TABLE_CLEAR_EVENT_ALLOWED_SIZE];
#endif

#define DEM_STOP_SEC_CONST_16
#include <Dem_MemMap.h>

/*--------------------------------------------------------------------------*/

#if (DEM_NUM_OF_PIDS_IN_OBDFF > 0U)

#define DEM_START_SEC_CALIB_UNSPECIFIED
#include <Dem_MemMap.h>

/** \brief Configuration for PIDs stored in OBD freeze frame
 **
 ** Number of elements: ::DEM_NUM_OF_PIDS_IN_OBDFF
 */
extern CONST(Dem_PidClassType, DEM_CONST) Dem_PidClass[DEM_NUM_OF_PIDS_IN_OBDFF];

#define DEM_STOP_SEC_CALIB_UNSPECIFIED
#include <Dem_MemMap.h>
#endif /* (DEM_NUM_OF_PIDS_IN_OBDFF > 0U) */

#if (DEM_USE_ADVANCED_EVENT_DISPLACEMENT == STD_ON)
#define DEM_START_SEC_CALIB_16
#include <Dem_MemMap.h>

/* !LINKSTO dsn.Dem.Displacement.DemAdvDisplReportedEventIds,1 */
/** \brief Configuration of reported events in passive
 ** table for advanced displacement
 **
 ** Number of elements: ::DEM_NUM_OF_PASSIVE_TABLE_LINES
 */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_AdvDisplPassiveTableLineReportedEventIds[DEM_NUM_OF_PASSIVE_TABLE_LINES];

#define DEM_STOP_SEC_CALIB_16
#include <Dem_MemMap.h>

#define DEM_START_SEC_CALIB_UNSPECIFIED
#include <Dem_MemMap.h>

/* !LINKSTO dsn.Dem.Displacement.DemAdvDisplPassiveEvents,1 */
/** \brief Configuration of passive events in passive
 ** table for advanced displacement
 **
 ** Number of elements: ::DEM_NUM_OF_PASSIVE_TABLE_LINES
 */
extern CONST(Dem_AdvDisplPassiveTableLinePassiveEventsType, DEM_CONST)
  Dem_AdvDisplPassiveTableLinePassiveEvents[DEM_NUM_OF_PASSIVE_TABLE_LINES];

#define DEM_STOP_SEC_CALIB_UNSPECIFIED
#include <Dem_MemMap.h>
#endif /* (DEM_USE_ADVANCED_EVENT_DISPLACEMENT == STD_ON) */

#if (DEM_NUM_FFCLS > 0U)
#define DEM_START_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

/** \brief Configuration table for freeze frame classes
 **
 ** Number of elements: ::DEM_NUM_FFCLS
 */
extern CONST(Dem_FFClassType, DEM_CONST) Dem_FFClass[DEM_NUM_FFCLS];

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

#if (DEM_DEV_FREEZE_FRAME_USED == STD_ON)
#define DEM_START_SEC_CALIB_16
#include <Dem_MemMap.h>

/** \brief Configuration table for development freeze frame classes
 **
 ** Number of elements: ::DEM_NUMBER_OF_EVENTS
 */
extern CONST(Dem_EventDescDevFFType, DEM_CONST) Dem_EventDescDevFF[DEM_NUMBER_OF_EVENTS][DEM_NUM_OF_DEVFF_KIND];

#define DEM_STOP_SEC_CALIB_16
#include <Dem_MemMap.h>
#endif
#endif

#if (DEM_COMMON_FREEZEFRAMES_USED == STD_ON)
#define DEM_START_SEC_CALIB_16
#include <Dem_MemMap.h>

/** \brief Array of indexes to the different common parts of Freeze Frames
 ** classes (i.e. common and development) for every FFKind
 **
 ** Number of elements: ::DEM_NUM_FFKINDS
 */
extern CONST(Dem_FFClassIdxType, DEM_CONST)
  Dem_CommonPartFFClassIdx[DEM_NUM_FFKINDS];

#define DEM_STOP_SEC_CALIB_16
#include <Dem_MemMap.h>
#endif

#define DEM_START_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

#if (DEM_FREEZE_FRAME_REC_NUMERATION_TYPE == DEM_FF_RECNUM_CONFIGURED)
/** \brief Configuration table for freeze frame record numeration classes
 **
 ** Number of elements: ::DEM_NUM_FFRECNUMCLS
 */
extern CONST(Dem_FFRecNumerationClassType, DEM_CONST)
  Dem_FFRecNumerationClass[DEM_NUM_FFRECNUMCLS];
#endif

#if (DEM_NUM_EDCLS > 0U)
/** \brief Configuration table for extended data classes
 **
 ** Number of elements: ::DEM_NUM_EDCLS
 */
extern CONST(Dem_EDClassType, DEM_CONST) Dem_EDClass[DEM_NUM_EDCLS];
#endif

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

#if (DEM_EVENTCLASS_SUPPORT == STD_ON)
#define DEM_START_SEC_CALIB_UNSPECIFIED
#include <Dem_MemMap.h>

/** \brief Configuration description table for event classes
 **
 ** Number of elements: ::DEM_NUMBER_OF_EVENT_CLASSES
 **
 */
extern CONST(Dem_EventClassDescType, DEM_CONST)
  Dem_EventClassDesc[DEM_NUMBER_OF_EVENT_CLASSES];

#define DEM_STOP_SEC_CALIB_UNSPECIFIED
#include <Dem_MemMap.h>
#endif

#if (DEM_NUM_DTC_GROUPS > 0U)
#define DEM_START_SEC_CONST_32
#include <Dem_MemMap.h>

/** \brief Configuration description table of DTC-group values */
extern CONST(Dem_DTCGroupType, DEM_CONST) Dem_DTCGroups[DEM_NUM_DTC_GROUPS];

#define DEM_STOP_SEC_CONST_32
#include <Dem_MemMap.h>
#endif

#define DEM_START_SEC_CALIB_32
#include <Dem_MemMap.h>

/** \brief Configuration description table for events
 **
 ** Number of elements: ::DEM_NUMBER_OF_EVENTS
 **
 ** This array contains all specific event-related data, which are packed by
 ** using the 'bit packing scheme'.
 */
extern CONST(Dem_EventDescType, DEM_CONST)
  Dem_EventDesc[DEM_NUMBER_OF_EVENTS];

#define DEM_STOP_SEC_CALIB_32
#include <Dem_MemMap.h>

#if (DEM_USE_EVENT_DISPLACEMENT == STD_ON)
#define DEM_START_SEC_CONST_8
#include <Dem_MemMap.h>

/** \brief Table with the configurated values of Event Priority
 **
 ** Number of elements: ::DEM_NUM_EVENT_PRIORITIES
 **
 ** This array contains all unique event priority values, which are packed using
 ** EventPriority Index.
 */
extern CONST(Dem_PriorityType, DEM_CONST)
  Dem_ExternalPrioValue[DEM_NUM_EVENT_PRIORITIES];

#define DEM_STOP_SEC_CONST_8
#include <Dem_MemMap.h>
#endif /* DEM_USE_EVENT_DISPLACEMENT == STD_ON */

#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_TYPE1)
#define DEM_START_SEC_CONST_32
#include <Dem_MemMap.h>

extern CONST(Dem_DTCDescType, DEM_CONST) Dem_DTCDesc[DEM_NUMBER_OF_DTCS];

#define DEM_STOP_SEC_CONST_32
#include <Dem_MemMap.h>
#endif

#if (DEM_NUM_CMB_DTCS > 0U)
#define DEM_START_SEC_CONST_16
#include <Dem_MemMap.h>

/** \brief Holds the index to the first event (startindex) combined in the associated DTC.
 * The combined events are grouped per DTC in Dem_CmbDTCEvents[]. */
extern CONST(Dem_CmbDTCEvLnkType, DEM_CONST) Dem_CmbDTCEvLnk[DEM_NUM_CMB_DTCS + 1U];
/** \brief Holds the events combined by associated DTCs */
extern CONST(Dem_EventIdType, DEM_CONST) Dem_CmbDTCEvents[DEM_NUM_CMB_EVENTS];

#define DEM_STOP_SEC_CONST_16
#include <Dem_MemMap.h>
#endif

/** \brief Bit-Array holds all events value
 ** of DemStatusBitStorageTestFailedPerEvent */
#if (DEM_STATUS_BIT_STORAGE_TF_PER_EVENT_SUPPORT == STD_ON)
#define DEM_START_SEC_CONST_8
#include <Dem_MemMap.h>

extern CONST(uint8, DEM_CONST) Dem_StatusBitStorageTF[DEM_STATUS_BIT_STORAGE_TF_ARRAY_SIZE];

#define DEM_STOP_SEC_CONST_8
#include <Dem_MemMap.h>

/** \brief Macro to check if TestFailed status bit at event level
 ** is stored only volatile */
#define DEM_IS_TF_BIT_STORED_VOLATILE(EventId) \
  !DEM_IS_BIT_SET_IN_ARRAY(Dem_StatusBitStorageTF, EventId)
#endif /* (DEM_STATUS_BIT_STORAGE_TF_PER_EVENT_SUPPORT == STD_ON) */

#if (DEM_OBD_Support == STD_ON)
#define DEM_START_SEC_CALIB_16
#include <Dem_MemMap.h>

#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_DISABLED)
/* !LINKSTO dsn.Dem.OBD.config.0001,2 */
/* !LINKSTO dsn.Dem_OBD_0018,2 */
/** \brief OBD specific configuration description table for Events
 **
 ** Number of elements: ::DEM_NUMBER_OF_EVENTS
 **
 ** This array contains all OBD specific event-related data,
 ** which partially are packed by using the 'bit packing scheme'.
 */
extern CONST(Dem_OBDConfigType, DEM_CONST)
    Dem_OBDConfig[DEM_NUMBER_OF_EVENTS];
#else /* (DEM_EVENT_COMBINATION_SUPPORT != DEM_EVCOMB_DISABLED) */
/* !LINKSTO dsn.Dem.OBD.config.0002,1 */
/* !LINKSTO dsn.Dem_OBD_0019,1 */
/** \brief OBD specific configuration description table for DTCs
 **
 ** Number of elements: ::DEM_NUMBER_OF_DTCS
 **
 ** This array contains all OBD specific DTC-related data,
 ** which partially are packed by using the 'bit packing scheme'.
 */
extern CONST(Dem_OBDConfigType, DEM_CONST)
    Dem_OBDConfig[DEM_NUMBER_OF_DTCS];
#endif /* (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_DISABLED) */

#define DEM_STOP_SEC_CALIB_16
#include <Dem_MemMap.h>
#endif /* (DEM_OBD_Support == STD_ON) */

#define DEM_START_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

#if (DEM_J1939_SUPPORT == STD_ON)
/** \brief J1939 specific configuration description table for Events
 **
 ** Number of elements: ::DEM_NUMBER_OF_EVENTS
 **
 ** This array contains all J1939 specific event-related data,
 ** which partially are packed by using the 'bit packing scheme'.
 */
#if (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_DISABLED)
extern CONST(Dem_J1939ConfigType, DEM_CONST)
    Dem_J1939Config[DEM_NUMBER_OF_EVENTS];
#else /* (DEM_EVENT_COMBINATION_SUPPORT != DEM_EVCOMB_DISABLED) */
/** \brief J1939 specific configuration description table for Events
 **
 ** Number of elements: ::DEM_NUMBER_OF_DTCS
 **
 ** This array contains all J1939 specific event-related data,
 ** which partially are packed by using the 'bit packing scheme'.
 */
extern CONST(Dem_J1939ConfigType, DEM_CONST)
    Dem_J1939Config[DEM_NUMBER_OF_DTCS];
#endif/* (DEM_EVENT_COMBINATION_SUPPORT == DEM_EVCOMB_DISABLED) */
#endif/* (DEM_J1939_SUPPORT == STD_ON) */

/** \brief Function pointer array holding debouncing functions */
extern CONST(Dem_DebounceFctPtrTableType, DEM_CONST)
  Dem_DebounceFctPtrTable[DEM_MAXNUM_DEBOUNCECLASSES];

/*-------------------------------- OBD DCY ---------------------------------*/

#if (DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING == STD_ON)
/** \brief Array contains satellite context functions
 **
 ** The access is based on the CoreId used as index.
 ** The Master instance CoreId must not be used.
 **
 ** Number of elements: ::DEM_NUMBER_OF_CORES
 */
extern CONST (Dem_SatelliteFncPtrType, DEM_CONST)
  Dem_SatelliteFncPtr[DEM_NUMBER_OF_CORES];
#endif

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include <Dem_MemMap.h>

#if (DEM_OPCYC_AUTO_END_ENABLED == STD_ON)
#define DEM_START_SEC_CONST_8
#include <Dem_MemMap.h>

/** \brief Array contains operation cycle automatic end enabled masks
 **
 ** Number of elements: ::DEM_OPCYC_NUM_OF_AUTO_END_ENABLED_MASKS
 */
extern CONST(uint8, DEM_CONST)
  Dem_OpCycAutoEndEnabledMasks[DEM_OPCYC_NUM_OF_AUTO_END_ENABLED_MASKS];

#define DEM_STOP_SEC_CONST_8
#include <Dem_MemMap.h>
#endif /* (DEM_OPCYC_AUTO_END_ENABLED == STD_ON) */

#define DEM_START_SEC_CALIB_8
#include <Dem_MemMap.h>

#if (DEM_EVENT_DISABLING_SUPPORT == STD_ON)
/** \brief Calibratable bit-field array that holds DTC enabled/disabled flags
 **        of all events
 ** Note: If event is available, corresponding bit is set to one */
extern CONST(uint8, DEM_CONST) Dem_EventEnabled[DEM_EVENT_ENABLED_ARRAY_SIZE];
#endif

#if (DEM_OBD_Support == STD_ON)
/* !LINKSTO dsn.Dem.OBDPidSupport.Dem_ReadinessForceStatus_01,1 */
/** \brief Bit mask to force complete bit of several readiness groups.*/
extern CONST(uint8, DEM_CONST) Dem_ObdReadinessForceCompleteMask;

/* This variable exits only to allow calibration */
/* bit 2: CCM_ENA always enabled */
/* !LINKSTO J1979-DA.PID41.ByteB.bit2,1 */
/* bit 3: preset engine type bit,
 * will be mask with configured engine type in
 * Dem_ObdReadinessForceCompleteMask */
extern CONST(uint8, DEM_CONST) Dem_ObdReadinessPID41ByteB;

#if (DEM_OBD_COMPLIANCY_ENABLED == STD_ON)
extern CONST(uint8, DEM_CONST) Dem_ObdCompliancyPID1CByte;
#endif
#endif

#define DEM_STOP_SEC_CALIB_8
#include <Dem_MemMap.h>

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

#define DEM_START_SEC_VAR_CLEARED_8
#include <Dem_MemMap.h>

#if (DEM_NUM_CMB_DTCS > 0U)
/** \brief Holds the combined DTCStatus of all combined events per DTC */
extern VAR(Dem_EventStatusExtendedType, DEM_VAR_CLEARED)
  Dem_CmbDTCStatus[DEM_NUM_CMB_DTCS];
#endif

#if (DEM_USER_CTRL_WIR_SUPPORT == STD_ON)
/** \brief Bit array which holds the requested user controlled WIR bit status for all events
 ** (with one bit per event and EventId as index) */
extern VAR(uint8, DEM_VAR_CLEARED) Dem_UserCtrlWIRStatus[DEM_USER_CTRL_WIR_STATUS_SIZE];
#endif

#if (DEM_AVAILABILITY_SUPPORT == DEM_EVENT_AVAILABILITY)
/** \brief Bit-field array that holds the current event available status of all events
 ** 0: disabled/not available, 1: enabled/available */
extern VAR(uint8, DEM_VAR_CLEARED) Dem_EventAvailableStatus[DEM_EVENT_ENABLED_ARRAY_SIZE];
#endif

/** \brief Bit-field array that holds the event memory entry existence status
 ** (EvMemEntryExists) for all configured events
 ** 0: no event memory entry exists, 1: event memory entry exists */
extern VAR(uint8, DEM_VAR_CLEARED) Dem_EvMemEntryExists[DEM_EVTENTRY_EXISTS_ARRAY_SIZE];

#if (DEM_SUPPRESSION_SUPPORT == DEM_DTC_SUPPRESSION)
/** \brief Bit-field array that holds the UDS DTC suppression status of all events
 ** 0: visible, 1: suppressed */
extern VAR(uint8, DEM_VAR) Dem_UDSDTCSuppression[DEM_DTC_SUPPRESSION_ARRAY_SIZE];

#if (DEM_OBD_Support == STD_ON)
/** \brief Bit-field array that holds the OBD DTC suppression status of all events
 ** 0: visible, 1: suppressed */
extern VAR(uint8, DEM_VAR) Dem_OBDDTCSuppression[DEM_DTC_SUPPRESSION_ARRAY_SIZE];
#endif
#if (DEM_J1939_SUPPORT == STD_ON)
/** \brief Bit-field array that holds the J1939 DTC suppression status of all events
 ** 0: visible, 1: suppressed */
extern VAR(uint8, DEM_VAR) Dem_J1939DTCSuppression[DEM_DTC_SUPPRESSION_ARRAY_SIZE];
#endif
#endif

/* !LINKSTO Dem_OBD_0005,1 */
#if (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U)
/* Stored status of permanent entries */
extern VAR(uint8, DEM_VAR_CLEARED)
  Dem_EventMemoryPermanentNonVolatileStored[DEM_MAX_NUMBER_EVENT_ENTRY_PER];
#endif

#define DEM_STOP_SEC_VAR_CLEARED_8
#include <Dem_MemMap.h>

#define DEM_START_SEC_VAR_CLEARED_16
#include <Dem_MemMap.h>

/** \brief Queue holding the errors appeared before Dem_Init(), or to be
 ** entered or updated in event memory after Dem_Init()
 */
extern VAR(Dem_ErrorQueueEntryType, DEM_VAR_CLEARED)
  Dem_ErrorQueue[DEM_BSW_ERROR_BUFFER_SIZE];

#if (DEM_NUM_DEBOUNCE_COUNTER > 0U)
/** \brief per-event status for counter based debouncing */
extern VAR(Dem_DebounceCounterStatusType, DEM_VAR_CLEARED)
  Dem_DebounceCounterStatus[DEM_NUM_DEBOUNCE_COUNTER];
#endif

/** \brief EventId of the locked memory entry
 **
 ** It holds the EventId corresponding to the DTC locked via
 ** Dem_DisableDTCRecordUpdate()
 **
 ** The value DEM_EVENT_ID_INVALID means the DTC record update
 ** is enabled (unlocked).
 */
extern VAR(Dem_EventIdType, DEM_VAR_CLEARED) Dem_EvIdOfLockedMemoryEntry;

#define DEM_STOP_SEC_VAR_CLEARED_16
#include <Dem_MemMap.h>

#define DEM_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <Dem_MemMap.h>

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)
/** \brief NvM write operation (and related gate entry) status per event
 ** memory */
extern VAR(Dem_NvMGateEntryInfoType, DEM_VAR_CLEARED)
  Dem_NvMGateEntryInfo[DEM_MAXNUM_ORIGINS];

#if (DEM_OBDFF_SUPPORT_KIND == DEM_OBDFF_MULTIPLE)
/** \brief Array containing the OBD Freeze Frame data and occurrence order of the event
 ** entries from primary memory */
extern VAR(Dem_MultipleOBDEventMemoryEntryType, DEM_VAR_CLEARED)
  Dem_EntryOBDFF[DEM_MAX_NUMBER_EVENT_ENTRY_PRI];
#endif
#endif /* (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON) */

/** \brief Status of an asynchronous ClearDTC operation */
extern VAR(Dem_ClearDtcAsyncStatusType, DEM_VAR_CLEARED) Dem_ClearDtcAsyncStatus;

#if ((DEM_J1939_SUPPORT == STD_ON) && (DEM_J1939_CLEAR_DTC_SUPPORT == STD_ON))
  /** \brief Filter of an asynchronous J1939 ClearDTC processing */
extern VAR(Dem_J1939ClearDTCFilterType, DEM_VAR_CLEARED) Dem_J1939ClearDTCFilter;
#endif

#if ( (DEM_INIT_MONITOR_REENABLED_SUPPORT == STD_ON) && \
      (DEM_USE_CB_INIT_MONITOR == STD_ON) )
/** \brief Controls the asynchronous handling of InitMonitorForEvent
 ** callbacks */
extern VAR(Dem_InitMonitorReenableStateType, DEM_VAR_CLEARED)
  Dem_InitMonitorReenableState;
#endif

#define DEM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <Dem_MemMap.h>

#define DEM_START_SEC_VAR_CLEARED_8
#include <Dem_MemMap.h>

#if (DEM_OPCYC_NVSTORAGE == STD_OFF)
/** \brief Array to store the current operation cycle state for all configured
 ** operating cycles
 */
extern VAR(Dem_OperationCycleStateType, DEM_VAR_CLEARED)
  Dem_OpCycleState[DEM_NUM_OPCYCLES];
#endif

#if (DEM_MAX_NUMBER_PRESTORED_FF > 0U)
/** \brief Flags to hold validity of the prestored freeze frames
 **
 ** Each bit represents one flag.
 */
extern VAR(uint8, DEM_VAR_CLEARED)
  Dem_PFFEntryValid[(DEM_MAX_NUMBER_PRESTORED_FF + 7U) / 8U];
#endif

/* !LINKSTO Dem_OBD_0005,1 */
#if (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U)
/** \brief Flag to mark changes to the permanent memory */
/* !LINKSTO Dem_OBD_0031,1 */
extern VAR(boolean, DEM_VAR_CLEARED) Dem_EventMemoryPermanentUpdated;
#endif

#define DEM_STOP_SEC_VAR_CLEARED_8
#include <Dem_MemMap.h>

#define DEM_START_SEC_VAR_SAVED_ZONE_16
#include <Dem_MemMap.h>

/* !LINKSTO Dem_OBD_0005,1 */
#if (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U)
/** \brief Non-volatile permanent memory data of the Dem */
/* !LINKSTO Dem_OBD_0011,2 */
extern VAR(Dem_PermanentMemoryEntryType, DEM_VAR_CLEARED)
  Dem_EventMemoryPermanent[DEM_MAX_NUMBER_EVENT_ENTRY_PER];
#endif

#define DEM_STOP_SEC_VAR_SAVED_ZONE_16
#include <Dem_MemMap.h>

#define DEM_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <Dem_MemMap.h>

#define DEM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <Dem_MemMap.h>

#define DEM_START_SEC_VAR_INIT_8
#include <Dem_MemMap.h>

#if (DEM_NUM_ENABLECONDITIONS > 0U)
/** \brief Array to store the current enable condition state for all
 ** configured enable conditions
 **
 ** Number of elements: ::DEM_NUM_ENABLECONDITIONS / no RAM-variable
 */
extern VAR(boolean, DEM_VAR) Dem_EnCondStatus[DEM_NUM_ENABLECONDITIONS];
#endif

#if (DEM_NUM_ENCONDGROUPS > 0U)
/** \brief Enable condition group counters
 **
 ** accessed via Dem_InternalSetEventStatus()
 */
extern VAR(Dem_EnCondGrpStatusCounterType, DEM_VAR)
  Dem_EnCondGrpStatusCounter[DEM_NUM_ENCONDGROUPS + 1U];
#endif

#if ( (DEM_NUM_FAILURECYCLES > 0U) && \
      (DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT == STD_ON) )
/** \brief Triggers the asynchronous processing of fault confirmation */
extern VAR(boolean, DEM_VAR) Dem_DoProcessFaultConfirmation;
#endif

#define DEM_STOP_SEC_VAR_INIT_8
#include <Dem_MemMap.h>

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/

#endif /* ifndef DEM_INT_H */
/*==================[end of file]===========================================*/
