/**
 * \file
 *
 * \brief AUTOSAR Dlt
 *
 * This file contains the implementation of the AUTOSAR
 * module Dlt.
 *
 * \version 1.8.6
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2021 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */

/* MISRA-C:2012 Deviation List
 *
 * MISRAC2012-1) Deviated Rule: 11.3 (Required)
 *    "A cast shall not be performed between a pointer to object type and a pointer to a different object type."
 *
 *    Reason:
 *    Two API functions with almost the same functionality but different
 *    parameter types are implemented by a common static function. A cast to
 *    the function parameter of the common function is therefore necessary.
 *
 * MISRAC2012-2) Deviated Rule: 2.2 (Required)
 *    "There shall be no dead code."
 *
 *    Reason:
 *    The contents of the function definition are generated based on the Dlt_Rte_hook.c.jet
 *    template. When there is no trace hook function specified, the body of the function will
 *    be empty.
 *
 * MISRAC2012-3) Deviated Rule: 8.3 (Required)
 *    "All declarations of an object or function shall use the same names and type qualifiers."
 *
 *    Reason:
 *    The function declaration is generated by the RTE with another parameter name.
 *
 **/

/* tasking Deviation List
 *
 * TASKING-1) Deviated Rule: W588
 * W588: dead assignment to "requestForNative" eliminated
 *
 * Reason:
 * The variable is set but not read by anything in Dlt_Init(). This is due to specific module configurations
 * that lead to different preprocessor expansions.
 *
 * TASKING-2) Deviated Rule: W588
 * W588: dead assignment to "requestForDataSet" eliminated
 *
 * Reason:
 * The Dlt_Init() function is not called for this specific module configuration. As such, requestForDataSet's
 * set value is not read at all.
 *
 * TASKING-3) Deviated Rule: W588
 * W588: dead assignment to "retVal" eliminated
 *
 * Reason:
 * The Dlt_SendLogMessage() API is not called in some specific module configurations, so retVal's assignments
 * are useless. Also, if it is called, the Dlt_FindCtxtAndSendTraceMsg() internal functions is not reached.
 *
 * TASKING-4) Deviated Rule: W588
 * W588: dead assignment to "retVal" eliminated
 *
 * Reason:
 * The Dlt_SendLogMessage() API is not called in some specific module configurations, so retVal's assignments
 * are useless. Also, if it is called, the Dlt_FindCtxtAndSendTraceMsg() internal functions is not reached.
 *
 * TASKING-5) Deviated Rule: W549
 * W549: condition is always true
 *
 * Reason:
 * The condition is false on other module configurations.
 *
 * TASKING-6) Deviated Rule: W549
 * W549: condition is always true
 *
 * Reason:
 * The condition is false on other module configurations.
 *
 * TASKING-7) Deviated Rule: W588
 * W588: dead assignment to "requestForNative" eliminated
 *
 * Reason:
 * Even if DltImplementNVRamStorage is enabled for this specific module configuration,
 * Dlt_IssueWriteRequestToNvM() is not called, so requestForNative's assignment is useless.
 *
 * TASKING-8) Deviated Rule: W588
 * W588: dead assignment to "requestForDataSet" eliminated
 *
 * Reason:
 * Even if DltImplementNVRamStorage is enabled for this specific module configuration,
 * Dlt_IssueWriteRequestToNvM() is not called, so requestForDataSet's assignment is useless.
 *
 * TASKING-9) Deviated Rule: W588
 * W588: dead assignment to "requestForDataSet" eliminated
 *
 * Reason:
 * Even if DltImplementNVRamStorage is enabled for this specific module configuration,
 * Dlt_IssueWriteRequestToNvM() is not called, so requestForDataSet's assignment is useless.
 *
 * TASKING-10) Deviated Rule: W549
 * W549: condition is always true
 *
 * Reason:
 * The condition is false on other module configurations.
 */

/*==================[inclusions]============================================*/

#include <TSMem.h>                                /* EB specific memory functions */

#include <Dlt_Cfg.h>

#if (defined DLT_INTERNAL_USAGE)
#error DLT_INTERNAL_USAGE is already defined
#endif
#define DLT_INTERNAL_USAGE

#include <SchM_Dlt.h>                             /* SchM interface for Dlt */

#include <Dlt.h>

#if (DLT_INCLUDE_RTE == STD_ON)

#define RTE_PTR2ARRAYTYPE_PASSING
/* !LINKSTO SWS_Dlt_00482,1 */
#include <Rte_Dlt.h>
#include <Dlt_BSW.h>

#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
#include <Dlt_SessionMapping.h>
#endif /* DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431 */

#endif /* DLT_INCLUDE_RTE == STD_ON */

#include <Dlt_Trace.h>
#include <Dlt_Cbk.h>
#include <Dlt_Int.h>

#include <PduR.h>
#include <PduR_Dlt.h>

#if (STD_ON == DLT_GETECUID_AT_RUNTIME)
#include <Dlt_UserCallouts.h>
#endif

#if (DLT_RECEPTION_CONTROL_MESSAGES_ENABLED == STD_ON)
#if (DLT_ON_ETHERNET == STD_ON)
#include <SoAd.h>
#endif
#endif

/*==================[macros]================================================*/

/*------------------[AUTOSAR vendor identification check]-------------------*/

#ifndef DLT_VENDOR_ID /* configuration check */
#error DLT_VENDOR_ID must be defined
#endif

#if (DLT_VENDOR_ID != 1U) /* vendor check */
#error DLT_VENDOR_ID has wrong vendor id
#endif

/*------------------[AUTOSAR release version identification check]----------*/

#ifndef DLT_AR_RELEASE_MAJOR_VERSION /* configuration check */
#error DLT_AR_RELEASE_MAJOR_VERSION must be defined
#endif

/* major version check */
#if (DLT_AR_RELEASE_MAJOR_VERSION != 4U)
#error DLT_AR_RELEASE_MAJOR_VERSION wrong (!= 4U)
#endif

#ifndef DLT_AR_RELEASE_MINOR_VERSION /* configuration check */
#error DLT_AR_RELEASE_MINOR_VERSION must be defined
#endif

/* minor version check */
#if (DLT_AR_RELEASE_MINOR_VERSION != 2U )
#error DLT_AR_RELEASE_MINOR_VERSION wrong (!= 2U)
#endif

#ifndef DLT_AR_RELEASE_REVISION_VERSION /* configuration check */
#error DLT_AR_RELEASE_REVISION_VERSION must be defined
#endif

/* revision version check */
#if (DLT_AR_RELEASE_REVISION_VERSION != 1U )
#error DLT_AR_RELEASE_REVISION_VERSION wrong (!= 1U)
#endif

/*------------------[AUTOSAR module version identification check]-----------*/

#ifndef DLT_SW_MAJOR_VERSION /* configuration check */
#error DLT_SW_MAJOR_VERSION must be defined
#endif

/* major version check */
#if (DLT_SW_MAJOR_VERSION != 1U)
#error DLT_SW_MAJOR_VERSION wrong (!= 1U)
#endif

#ifndef DLT_SW_MINOR_VERSION /* configuration check */
#error DLT_SW_MINOR_VERSION must be defined
#endif

/* minor version check */
#if (DLT_SW_MINOR_VERSION < 8U)
#error DLT_SW_MINOR_VERSION wrong (< 8U)
#endif

#ifndef DLT_SW_PATCH_VERSION /* configuration check */
#error DLT_SW_PATCH_VERSION must be defined
#endif

/* patch version check */
#if (DLT_SW_PATCH_VERSION < 6U)
#error DLT_SW_PATCH_VERSION wrong (< 6U)
#endif

#if(defined DLT_INVALID_CORE_ID)
#error DLT_INVALID_CORE_ID already defined
#endif
/** \brief Invalid core Id to reset the master's OsCoreId in Dlt_Init() */
#define DLT_INVALID_CORE_ID                      0xFFU

#if(defined DLT_MESSAGE_SENT_ONCE)
#error DLT_MESSAGE_SENT_ONCE already defined
#endif
/** \brief Macro defines if the message was sent at least once */
#define DLT_MESSAGE_SENT_ONCE                    1U

#if(defined DLT_MESSAGE_NOT_SENT)
#error DLT_MESSAGE_NOT_SENT already defined
#endif
/** \brief Macro defines the message wasn't sent at all */
#define DLT_MESSAGE_NOT_SENT                     2U

#if(defined DLT_LOGINFO_SERVICEID_STATUS_SIZE)
#error DLT_LOGINFO_SERVICEID_STATUS_SIZE already defined
#endif
/** \brief Service ID and status response size */
#define DLT_LOGINFO_SERVICEID_STATUS_SIZE        0x05U

#if(defined DLT_RESPONSE_SERVICE_ID_IDX)
#error DLT_RESPONSE_SERVICE_ID_IDX already defined
#endif
/** \brief Index of the ServiceId in the response message payload */
#define DLT_RESPONSE_SERVICE_ID_IDX              0x0U

#if(defined DLT_GETLOGINFO_SERVICE_ID)
#error DLT_GETLOGINFO_SERVICE_ID already defined
#endif
/** \brief GetLogInfo Service ID */
#define DLT_GETLOGINFO_SERVICE_ID                0x03U

#if(defined DLT_BASE_GETLOGINFO_RESPSIZE)
#error DLT_BASE_GETLOGINFO_RESPSIZE already defined
#endif
/** \brief GetLogInfo Response Size: 2 bytes - NoOfAppIds
 *                                   4 bytes - AppId
 *                                   2 bytes - NoOfContextIdsOfAppId
 *                                   4 bytes - ContextIdOfAppId
 *                                   1 byte  - LogLevel
 *                                   1 byte  - TraceStatus
 *                                   4 bytes - Reserved bytes */
#define DLT_BASE_GETLOGINFO_RESPSIZE             18U

#if(defined DLT_CM_0x03_REQUIRED_PAYLOAD_LENGTH)
#error DLT_CM_0x03_REQUIRED_PAYLOAD_LENGTH already defined
#endif
/** \brief Required length for the request payload of service 0x03 */
#define DLT_CM_0x03_REQUIRED_PAYLOAD_LENGTH             (DLT_LOGINFO_SERVICEID_STATUS_SIZE + 12U)

#if(defined DLT_BUFFER_IDX)
#error DLT_BUFFER_IDX already defined
#endif
/** \brief Calculate new index in circular buffer array
 **
 ** Calculates the position in the ring buffer array for idx + offset. */
#define DLT_BUFFER_IDX(idx, offset, buffSize) (((idx)+(offset)) % (buffSize))

#if(defined DLT_RESET_BUFFER_IDXS)
#error DLT_RESET_BUFFER_IDXS already defined
#endif
/** \brief Reset indexes to access the circular buffer array
 **
 ** Resets indexes to access the circular buffer. */
#define DLT_RESET_BUFFER_IDXS(i)     do{ \
                                         Dlt_InternalVarsTxRx[i].Dlt_BufferReadIdx = 0U; \
                                         Dlt_InternalVarsTxRx[i].Dlt_BufferMsgIdx = 0U; \
                                         Dlt_InternalVarsTxRx[i].Dlt_BufferStoreIdx = 0U; \
                                       }while(0);

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
#if(defined DLT_GET_MESSAGE_LEN_LOG_CHN)
#error DLT_GET_MESSAGE_LEN_LOG_CHN already defined
#endif
#define DLT_GET_MESSAGE_LEN_LOG_CHN(chnIdx, idx, buffSize)  (((Dlt_MsgLengthType)((Dlt_MsgLengthType)((uint32)Dlt_CfgLogChannel[chnIdx].DltMessageTxBuffer[DLT_BUFFER_IDX((idx), \
                                  DLT_LEN_HEADER_OFFSET, (buffSize))]) << 8U)) |  \
                                  (((Dlt_MsgLengthType)((uint32)Dlt_CfgLogChannel[chnIdx].DltMessageTxBuffer[DLT_BUFFER_IDX((idx), \
                                  (DLT_LEN_HEADER_OFFSET+1U), (buffSize))]) & 0x00ffU)))
#else
#if(defined DLT_GET_MESSAGE_LEN)
#error DLT_GET_MESSAGE_LEN already defined
#endif
#define DLT_GET_MESSAGE_LEN(idx, buffSize)  (((Dlt_MsgLengthType)((Dlt_MsgLengthType)(Dlt_MessageBuffer[DLT_BUFFER_IDX((idx), \
                                  DLT_LEN_HEADER_OFFSET,(buffSize))]) << 8U)) |  \
                                  (((Dlt_MsgLengthType)(Dlt_MessageBuffer[DLT_BUFFER_IDX((idx), \
                                  (DLT_LEN_HEADER_OFFSET+1U), (buffSize))]) & 0x00ffU)))
#endif

#if(defined DLT_INIT_FILTERING_INFO)
#error DLT_INIT_FILTERING_INFO already defined
#endif
/** \brief Initialize filtering functionality to default values
 **
 ** Initialize filtering variables to default values */
#define DLT_INIT_FILTERING_INFO()       \
   do{\
      Dlt_DefaultLogLevel           = DLT_DEFAULT_MAX_LOG_LEVEL;\
      Dlt_DefaultTraceStatus        = DLT_DEFAULT_TRACE_STATUS;\
      Dlt_FilterMessages            = DLT_FILTER_MESSAGES;\
      Dlt_GlobalLogStatus           = DLT_LOGGING_ENABLED;\
   }while(0)

#if(defined DLT_INIT_MESSAGE_HEADER_FIELDS)
#error DLT_INIT_MESSAGE_HEADER_FIELDS already defined
#endif
/** \brief Initialize header fields of the message to values form configuration
 **
 ** Initialize header fields of the message to values form configuration */
#if (DLT_IMPLEMENT_TIMESTAMP != STD_OFF)
#define DLT_INIT_MESSAGE_HEADER_FIELDS()       \
   do{\
        Dlt_HeaderUseEcuId            = DLT_HEADER_CONFIG_ECU_ID_BIT;\
        Dlt_HeaderUseExtendedHeader   = DLT_HEADER_CONFIG_EXTENDED_HEADER_BIT;\
        Dlt_HeaderUseSessionID        = DLT_HEADER_CONFIG_SESSION_ID_BIT;\
        Dlt_HeaderUseTimestamp        = DLT_HEADER_CONFIG_TIMESTAMP_BIT;\
        Dlt_HeaderUseVerboseMode      = DLT_USE_VERBOSE_MODE;\
    }while(0)
#else /* #if (DLT_IMPLEMENT_TIMESTAMP == STD_OFF) */
#define DLT_INIT_MESSAGE_HEADER_FIELDS()       \
   do{\
       Dlt_HeaderUseEcuId            = DLT_HEADER_CONFIG_ECU_ID_BIT;\
       Dlt_HeaderUseExtendedHeader   = DLT_HEADER_CONFIG_EXTENDED_HEADER_BIT;\
       Dlt_HeaderUseSessionID        = DLT_HEADER_CONFIG_SESSION_ID_BIT;\
       Dlt_HeaderUseVerboseMode      = DLT_USE_VERBOSE_MODE;\
     }while(0)
#endif /* DLT_IMPLEMENT_TIMESTAMP != STD_OFF */

/** \brief Initialize traffic shaping data to a consistent state
 **
 ** Initialize traffic shaping information to consistent values */
#if (DLT_TRAFFIC_SHAPER_ENABLED == STD_ON)
#if(defined DLT_INIT_TRAFFIC_SHAPING_INFO)
#error DLT_INIT_TRAFFIC_SHAPING_INFO already defined
#endif
#define DLT_INIT_TRAFFIC_SHAPING_INFO(i)       \
   do{\
        Dlt_InternalVarsTxRx[i].Dlt_WaitStates               = 0U;\
        Dlt_InternalVarsTxRx[i].Dlt_IntegrationWindow        = 1U;\
        Dlt_InternalVarsTxRx[i].Dlt_TransmittedData          = 0U;\
    }while(0)
#endif

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
#define BUFFER_SIZE Dlt_CfgLogChannel[chnIdx].DltLogChannelBufferSize
#else /* (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
#define BUFFER_SIZE DLT_MESSAGE_BUFFER_SIZE
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */


/*==================[type definitions]======================================*/
 /** \brief Internal Variables type structure that contains the following */
typedef struct
{
  /*Index of the next free ring buffer element */
  uint32 Dlt_BufferStoreIdx;
  /*Index of the next free ring buffer element - copy of the original global variable */
  uint32 Dlt_BufferStoreIdxCopy;
  /* Length of the original store request. If other store requests interrupts the
   * ongoing store request, this variable will store the first store request length
   * (corresponding with Dlt_StoreInterruptedCnt == 1)
   */
  uint32 Dlt_BufferStoreLengthCopy;
  /*Index of the oldest ring buffer element */
  uint32 Dlt_BufferMsgIdx;
  /*Index of the currently transmitted message */
  uint32 Dlt_BufferReadIdx;
  /*Flag signaling whether the ring buffer contains messages */
  uint32 Dlt_BufferTxIdx;
#if (DLT_TRAFFIC_SHAPER_ENABLED == STD_ON)
  /* Wait time for the information to be transmitted */
  Dlt_MsgLengthType Dlt_WaitStates;
  Dlt_MsgLengthType Dlt_TransmittedData;
  uint32 Dlt_IntegrationWindow;
#endif
  /*State which verifies how many cycles Dlt_MainFunction() shall pause due to traffic shaping */
  boolean Dlt_MessageInBuffer;
  /*Counter to determine the integration window */
  boolean Dlt_TransmissionOngoing;
  /* !LINKSTO Dlt.TrafficShaper.License, 1 */
}Dlt_InternalVarsTxRx_Type;
/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define DLT_START_SEC_CODE
#include <Dlt_MemMap.h>

#if ( (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) || (DLT_SWC_SESSION_REGISTERED > 0U) )
/** \brief Find entry in SessionId Table
  *        This function returns the index of the entry in the Session table if an entry exists.
  *        If no entry exists, the function returns the index of the next free entry.
  ** \param[in] Dlt_SessionIDType session_id
  ** \param[in] LocalCoreContext pointer to the working context table
  ** \param[in-out] sessionIdx  index of the entry/next free entry
  ** \return Result of search True if the the entry was found / was created
  **                          False if a new entry was not possible
  */
STATIC FUNC(void, DLT_CODE) Dlt_FindSessionIDEntry(
    boolean runtime,
    Dlt_SessionIDType sessionId,
    CONSTP2CONST(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) LocalCoreContext,
    P2VAR(Dlt_SessionIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) sessionIdx);
#endif /* #if ( (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) || (DLT_SWC_SESSION_REGISTERED > 0U) ) */

#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)

STATIC FUNC(void, DLT_CODE) Dlt_FindChannelIdx(
    P2VAR(Dlt_ChnIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) chnIdx,
    PduIdType pduId
    );

/** \brief Function for internal handling of registered pairs of contextID and
 ** Application ID
 **
 ** \param[in] CurrentCoreId    current core Id
 ** \param[in] SessionId        number of the module (Module ID within BSW, port defined argument value within SW-C)
 ** \param[in] AppId            the Application ID
 ** \param[in] ContextId        the Context ID
 ** \param[in] LocalCoreContext the working context table
 **
 ** \return Result of registering the context
 ** \retval DLT_E_OK context has been unregistered successfully
 ** \retval DLT_E_ERROR context has not been unregistered successfully
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 ** */
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_InternalUnregisterContext(
    CoreIdType CurrentCoreId,
    Dlt_SessionIDType SessionId,
    Dlt_Internal_ApplicationIDType AppId,
    Dlt_Internal_ContextIDType ContextId,
    P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) LocalCoreContext);

/** \brief Find entry in for tuple ApplicationId/ContextId in the configuration table
  *        This function returns the index of the entry for the application and context matching tuple.
  *        If no entry exists, the function returns the index of the next free entry.
  ** \param[in] Dlt_SessionIdTableIdxType sessionIdx
  ** \param[in] Dlt_ApplicationIDType app_id
  ** \param[in] Dlt_ContextIDType context_id
  ** \param[in-out] aIdx  index of the entry/next free entry
  ** \param[in-out] contextIdx  index of the entry/next free entry
  */
STATIC FUNC(void, DLT_CODE) Dlt_FindCtxAppRegisteredTuple(
    Dlt_SessionIdTableIdxType sessIdx,
    Dlt_Internal_ApplicationIDType app_id,
    Dlt_Internal_ContextIDType context_id,
    P2VAR(Dlt_ContextIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) ctxtIdx);

#if(DLT_REGISTER_CONTEXT_NOTIFICATION == STD_ON)
/** \brief Unregister already logged application/context ids
 **
 ** The service has to be called when a software module wants to use
 ** services offered by DLT software component for a specific context.
 **
 ** \param[in] RegisterOrUnregisterContext DLT_STATUS_REGISTER = notification for RegisterContext
 **                                        DLT_STATUS_UNREGISTER = notification for UnregisterContext
 ** \param[in] session_id number of the module (Module ID within BSW,
 **     port defined argument value within SW-C)
 ** \param[in] appId the Application ID
 ** \param[in] contextId the Context ID
 ** \return Result of a notification received by a SWC when the context is registered/unregistered
 **
 ** \ServiceID{::DLT_SID_UnregisterContext}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
STATIC FUNC(void, DLT_CODE) Dlt_RegisterContextNotification(
    uint8 RegisterOrUnregisterContext,
    Dlt_SessionIDType sessionId,
    Dlt_Internal_ApplicationIDType appId,
    Dlt_Internal_ContextIDType contextId);
#endif
#endif

/** \brief Send a log message to the DLT module
 **
 ** The service represents the interface to be used by basic software
 ** modules or by software component to send log messages.
 ** \param[in] session_id For SW-C this is not visible (Port defined
 **     argument value), for BSW-modules it is the module number

 ** \param[in] identified_ctxt_id_idx Identified registered context
 ** \param[in] log_info Log information to be sent
 ** \param[in] log_data Log data to be sent
 ** \param[in] log_data_length log data length
 ** \param[in] context_id_identified identified context in the registration table
 ** \param[out] at_least_once means whether the message was transmitted or not.
 **             It has only 3 values to be verified
           0 - message wasn't sent on any of existing channels because of the message size
           1 - message was transmitted on at least one channel
           2 - message wan not transmitted because of a wrong level value
 ** \return Result of sending the log message
 ** \retval DLT_E_OK The required operation succeeded
 ** \retval DLT_E_MSG_TOO_LARGE The message is too large for
 **     sending over the network
 ** \retval DLT_E_IF_NOT_AVAILABLE The interface is not
 **     available
 ** \retval DLT_E_UNKNOWN_SESSION_ID The provided session id
 **     is unknown
 ** \retval DLT_E_NOT_IN_VERBOSE_MODE Unable to send the message
 **     in verbose mode
 **
 ** \ServiceID{::DLT_SID_SendLogMessage}
 ** \Reentrancy{Non-Reentrant}
 ** \Synchronicity{Synchronous}
 */
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_FindCtxtAndSendLogMsg(
    Dlt_SessionIDType session_id,
    uint32 identified_ctxt_id_idx,
    P2CONST(Dlt_MessageLogInfoType, AUTOMATIC, DLT_APPL_CONST) log_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) log_data,
    Dlt_MsgLengthType log_data_length,
    boolean context_id_identified,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once);

#if (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON)
/** \brief Send a log message to the DLT module in case the Context Id was
 **        identified in the registration table
 **
 ** The service represents the interface to be used by basic software
 ** modules or by software component to send log messages.
 ** \param[in] session_id For SW-C this is not visible (Port defined
 **     argument value), for BSW-modules it is the module number
 ** \param[in] identified_ctxt_id_idx Identified registered context
 ** \param[in] log_info Log information to be sent
 ** \param[in] log_data Log data to be sent
 ** \param[in] log_data_length log data length
 ** \param[out] at_least_once means whether the message was transmitted or not.
 **             It has only 3 values to be verified
           0 - message wasn't sent on any of existing channels because of the message size
           1 - message was transmitted on at least one channel
           2 - message was not transmitted because of a wrong level value
 ** \param[in] timestamp the timestamp of the message
 ** \return Result of sending the log message
 ** \retval DLT_E_OK The required operation succeeded
 ** \retval DLT_E_MSG_TOO_LARGE The message is too large for
 **     sending over the network
 ** \retval DLT_E_IF_NOT_AVAILABLE The interface is not
 **     available
 ** \retval DLT_E_UNKNOWN_SESSION_ID The provided session id
 **     is unknown
 **
 ** \Reentrancy{Non-Reentrant}
 ** \Synchronicity{Synchronous}
 */
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_SendLogMsgContextIdIdentified(
    Dlt_SessionIDType session_id,
    uint32 identified_ctxt_id_idx,
    P2CONST(Dlt_MessageLogInfoType, AUTOMATIC, DLT_APPL_CONST) log_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) log_data,
    Dlt_MsgLengthType log_data_length,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once,
    uint32 timestamp);

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
/** \brief Send a log message to the DLT module in case the Context Id was not
 **        identified in the registration table
 **
 ** The service represents the interface to be used by basic software
 ** modules or by software component to send log messages.
 ** \param[in] session_id For SW-C this is not visible (Port defined
 **     argument value), for BSW-modules it is the module number
 ** \param[in] log_info Log information to be sent
 ** \param[in] log_data Log data to be sent
 ** \param[in] log_data_length log data length
 ** \param[out] at_least_once means whether the message was transmitted or not.
 **             It has only 3 values to be verified
           0 - message wasn't sent on any of existing channels because of the message size
           1 - message was transmitted on at least one channel
           2 - message was not transmitted because of a wrong level value
 ** \param[in] timestamp the timestamp of the message
 ** \return Result of sending the log message
 ** \retval DLT_E_OK The required operation succeeded
 ** \retval DLT_E_MSG_TOO_LARGE The message is too large for
 **     sending over the network
 ** \retval DLT_E_IF_NOT_AVAILABLE The interface is not
 **     available
 ** \retval DLT_E_UNKNOWN_SESSION_ID The provided session id
 **     is unknown
 **
 ** \Reentrancy{Non-Reentrant}
 ** \Synchronicity{Synchronous}
 */
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_SendLogMsgContextIdNotIdentified(
    Dlt_SessionIDType session_id,
    P2CONST(Dlt_MessageLogInfoType, AUTOMATIC, DLT_APPL_CONST) log_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) log_data,
    Dlt_MsgLengthType log_data_length,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once,
    uint32 timestamp);
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
#endif /* (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) */

/** \brief Send a log message to the DLT module
 **
 ** The service represents the interface to be used by basic software
 ** modules or by software component to send log messages.
 ** \param[in] session_id For SW-C this is not visible (Port defined
 **     argument value), for BSW-modules it is the module number
 ** \param[in] identified_ctxt_id_idx Identified registered context
 ** \param[in] trace_info Trace information to be sent
 ** \param[in] trace_data Trace data to be sent
 ** \param[in] trace_data_length trace data length
 ** \param[in] context_id_identified identified context in the registration table
 ** \param[out] at_least_once means whether the message was transmitted or not.
 **             It has only 3 values to be verified
           0 - message wasn't sent on any of existing channels because of the message size
           1 - message was transmitted on at least one channel
           2 - message was not transmitted because of a wrong level value
 ** \return Result of sending the log message
 ** \retval DLT_E_OK The required operation succeeded
 ** \retval DLT_E_MSG_TOO_LARGE The message is too large for
 **     sending over the network
 ** \retval DLT_E_IF_NOT_AVAILABLE The interface is not
 **     available
 ** \retval DLT_E_UNKNOWN_SESSION_ID The provided session id
 **     is unknown
 ** \retval DLT_E_NOT_IN_VERBOSE_MODE Unable to send the message
 **     in verbose mode
 **
 ** \ServiceID{::DLT_SID_SendLogMessage}
 ** \Reentrancy{Non-Reentrant}
 ** \Synchronicity{Synchronous}
 */
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_FindCtxtAndSendTraceMsg(
    Dlt_SessionIDType session_id,
    uint32 identified_ctxt_id_idx,
    P2CONST(Dlt_MessageTraceInfoType, AUTOMATIC, DLT_APPL_CONST) trace_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) trace_data,
    Dlt_MsgLengthType trace_data_length,
    boolean context_id_identified,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once);

#if (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON)
/** \brief Send a trace message to the DLT module in case the Context Id was
 **        identified in the registration table
 **
 ** The service represents the interface to be used by basic software
 ** modules or by software component to send trace messages.
 ** \param[in] session_id For SW-C this is not visible (Port defined
 **     argument value), for BSW-modules it is the module number
 ** \param[in] identified_ctxt_id_idx Identified registered context
 ** \param[in] trace_info Trace information to be sent
 ** \param[in] trace_data Trace data to be sent
 ** \param[in] trace_data_length trace data length
 ** \param[out] at_least_once means whether the message was transmitted or not.
 **             It has only 3 values to be verified
           0 - message wasn't sent on any of existing channels because of the message size
           1 - message was transmitted on at least one channel
           2 - message was not transmitted because of a wrong level value
 ** \param[in] timestamp the timestamp of the message
 ** \return Result of sending the log message
 ** \retval DLT_E_OK The required operation succeeded
 ** \retval DLT_E_MSG_TOO_LARGE The message is too large for
 **     sending over the network
 ** \retval DLT_E_IF_NOT_AVAILABLE The interface is not
 **     available
 ** \retval DLT_E_UNKNOWN_SESSION_ID The provided session id
 **     is unknown
 **
 ** \Reentrancy{Non-Reentrant}
 ** \Synchronicity{Synchronous}
*/
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_SendTraceMsgContextIdIdentified(
    Dlt_SessionIDType session_id,
    uint32 identified_ctxt_id_idx,
    P2CONST(Dlt_MessageTraceInfoType, AUTOMATIC, DLT_APPL_CONST) trace_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) trace_data,
    Dlt_MsgLengthType trace_data_length,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once,
    uint32 timestamp);

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
/** \brief Send a trace message to the DLT module in case the Context Id was not
 **        identified in the registration table
 **
 ** The service represents the interface to be used by basic software
 ** modules or by software component to send trace messages.
 ** \param[in] session_id For SW-C this is not visible (Port defined
 **     argument value), for BSW-modules it is the module number
 ** \param[in] trace_info Trace information to be sent
 ** \param[in] trace_data Trace data to be sent
 ** \param[in] trace_data_length trace data length
 ** \param[out] at_least_once means whether the message was transmitted or not.
 **             It has only 3 values to be verified
           0 - message wasn't sent on any of existing channels because of the message size
           1 - message was transmitted on at least one channel
           2 - message wan not transmitted because of a wrong level value
 ** \param[in] timestamp the timestamp of the message
 ** \return Result of sending the log message
 ** \retval DLT_E_OK The required operation succeeded
 ** \retval DLT_E_MSG_TOO_LARGE The message is too large for
 **     sending over the network
 ** \retval DLT_E_IF_NOT_AVAILABLE The interface is not
 **     available
 ** \retval DLT_E_UNKNOWN_SESSION_ID The provided session id
 **     is unknown
 **
 ** \Reentrancy{Non-Reentrant}
 ** \Synchronicity{Synchronous}
*/
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_SendTraceMsgContextIdNotIdentified(
    Dlt_SessionIDType session_id,
    P2CONST(Dlt_MessageTraceInfoType, AUTOMATIC, DLT_APPL_CONST) trace_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) trace_data,
    Dlt_MsgLengthType trace_data_length,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once,
    uint32 timestamp);
#endif
#endif /* (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) */

#if(DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
/** \brief Common send message dispatcher
 **
 ** This service dispatches Dlt_SendLogMessage and Dlt_SendTraceMessage
 ** requests to the master core on a multi-core system. On a single-core
 ** system or if multi-core support is disabled, this is just a pre-
 ** processor macro which expands to Dlt_InternalSendMessage.
 **
 ** \param[in] ChannelsIdx The status of each Channel for the transmission
 ** \param[in] session_id Session id of the message
 ** \param[in] msg_info Common message info struct
 ** \param[in] msg_data Pointer to the message payload
 ** \param[in] msg_data_length Length of the message
 ** \param[in] ServiceId ServiceID of the message type (log or trace message)
 ** \param[in] timestamp The timestamp of the message
 **
 ** \return Result of sending the message
 ** \retval DLT_E_OK The required operation succeeded
 ** \retval DLT_E_MSG_TOO_LARGE The message is too large for
 **                             sending over the network
 ** \retval DLT_E_IF_NOT_AVAILABLE The interface is not
 **                                available
 ** \retval DLT_E_UNKNOWN_SESSION_ID The provided session id
 **                                  is unknown
 ** \retval DLT_E_NOT_IN_VERBOSE_MODE Unable to send the message
 **                                   in verbose mode
 **/
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_InternalDispatchSendMessage(
    P2CONST(boolean, AUTOMATIC, DLT_APPL_CONST) ChannelsIdx,
    Dlt_SessionIDType session_id,
    P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_CONST) msg_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) msg_data,
    Dlt_MsgLengthType msg_data_length,
    uint8 ServiceId,
    uint32 timestamp);
#else
#define Dlt_InternalDispatchSendMessage(a,b,c,d,e,f,g) Dlt_InternalSendMessage((a),(b),(c),(d),(e),(f),(g))
#endif

/** \brief Trigger transmission of the oldest message
 ** \param[in] TxPduId pdu id used for data transmission.
 ** \param[in/out] PduInfoPtr Contains a pointer to a buffer (SduDataPtr) to where the SDU data shall be copied,
 **                and the available buffer size in SduLengh. On return,
 **                the service will indicate the length of the copied SDU data in SduLength.
 **                the default Tx pdu will be used, configured in Dlt/General
 ** \param[out] retVal - With AUTOSAR 4.3 the Dlt_TriggerTransmit() has a return value
                         E_OK transmission was done
                         E_NOT_OK transmission was not possible
 ** This service triggers the transmission of the oldest message in
 ** the message ring buffer.
 **/
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
STATIC FUNC(Std_ReturnType, DLT_CODE) Dlt_TriggerTransmit(
 PduIdType TxPduId,
 P2VAR(PduInfoType, AUTOMATIC, DLT_APPL_DATA) PduInfoPtr );
#else
STATIC FUNC(void, DLT_CODE) Dlt_TriggerTransmit(
 PduIdType TxPduId,
 P2VAR(PduInfoType, AUTOMATIC, DLT_APPL_DATA) PduInfoPtr);
#endif

/** \brief Store message in message buffer
 **
 ** This service stores a message from a source buffer in the
 ** message ring buffer.
 ** \param[in] chnIdx Channel Idx ( if this is equal with the configured no of log channels, means that for the transmission
 **            the default Tx pdu will be used, configured in Dlt/General
 ** \param[in] header Pointer to the source buffer containing the message header
 ** \param[in] data Pointer to the source buffer containing the message payload
 ** \param[in] headerlen Length of the message header
 ** \param[in] datalen Length of the message payload
 ** \param[in] storeindex Index in circular buffer where the message shall be stored
 **
 ** \return Result of storing the message
 ** \retval DLT_BUF_FULL Message was stored
 ** \retval DLT_BUF_OVERFLOW Message was stored but older messages
 **                          were overwritten
 **/
STATIC FUNC(uint8, DLT_CODE) Dlt_StoreInBuffer(
    Dlt_ChnIdTableIdxType chnIdx,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) header,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) data,
    uint8 headerlen,
    Dlt_MsgLengthType datalen,
    uint32 storeindex);
/** \brief Retrieve message from message buffer
 **
 ** This service retrieves the oldest message from the message
 ** ring buffer and copies it into the destination buffer.
 **
 ** \param[in] chnIdx Channel Idx ( if this is equal with the configured no of log channels, means that for the transmission
 **            the default Tx pdu will be used, configured in Dlt/General.
 ** \param[out] data Pointer to the destination buffer
 ** \param[in]  length Number of bytes to read
 ** \param[in]  offset Position in the message from where
 **             to start reading
 **
 ** \return Result of retrieving the message
 ** \retval DLT_BUF_EMPTY No message found in buffer
 ** \retval DLT_BUF_INVALID Request is invalid
 ** \retval DLT_BUF_FULL Message was retrieved
 **/
STATIC FUNC(uint8, DLT_CODE) Dlt_ReadFromBuffer(
    Dlt_ChnIdTableIdxType chnIdx,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) data,
    Dlt_MsgLengthType length, Dlt_MsgLengthType offset);
/** \brief Get current message length
 ** \param[in] BufferSize maximum buffer size in bytes supported by a Tx Log Channel
 ** \param[in] chnIdx Channel Idx ( if this is equal with the configured no of log channels, means that for the transmission
 **            the default Tx pdu will be used, configured in Dlt/General
 ** \param[out] Length of a transmitted message.
 ** This function returns the length of the currently
 ** selected message.
 ** If Dlt_EnableMultipleFrames is enabled, this function
 ** returns the overall length of multiple frames which
 ** can be transmitted in one Pdu. The number of frames
 ** is calculated such that their overall length does not
 ** exceed DltMaxMessageLength.
 **
 ** \return Length of the currently selected message
 **/
STATIC FUNC(Dlt_MsgLengthType, DLT_CODE) Dlt_GetCurMessageLength(Dlt_ChnIdTableIdxType chnIdx, uint32 BufferSize);
/** \brief Check if buffer is ready for a new message
 **
 ** This function checks whether the transmit buffer is ready
 ** to accept a new message, i.e. whether the new message will
 ** fit into the buffer and won't overwrite data which is
 ** currently in transmission.
 **
 ** This function also modifies Dlt_BufferStoreIdx.
 **
 ** \param[in] chnIdx                    Channel index the message shall be transmitted on
 ** \param[in] MsgLen                    Length of the message to be stored in the buffer
 ** \param[in] BufferSize                Accepted buffer size for message transmission.
 ** \param[in] MaxMsgLen                 Maximum length of a transmitted message
 ** \param[in] StoreIdx                  Index where to store the message in the buffer
 **
 ** \return Result of buffer check
 ** \retval DLT_E_OK            Message can be stored in the buffer
 ** \retval DLT_E_MSG_TOO_LARGE Message does not fit into the buffer
 ** \retval DLT_E_IF_BUSY       Message would overwrite parts of the buffer currently in transmission in Autosar 4.1 and 4.2
 ** \retval DLT_E_NO_BUFFER     Message would overwrite parts of the buffer currently in transmission in Autosar 4.3.1
 **
 **/
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_CheckBuffer(
    uint8 chnIdx,
    Dlt_MsgLengthType MsgLen,
    Dlt_MsgLengthType MaxMsgLen,
    uint32 BufferSize,
    uint32 StoreIdx);

/** \brief Computes the length of the header according to
 **  the current configuration
 **
 ** This function calculates the length of the DLT message header
 ** according to global Dlt configuration settings.
 **
 ** \return The length of the header for the current message
 **/
STATIC FUNC(uint8, DLT_CODE) Dlt_ComputeHeaderLength(void);

/** \brief Checks that the provided app_id, context_id and session_id
 ** are registered and, if found, provide the index of the context
 ** in the working context table
 **
 **
 ** \param[in] context_id The context Id
 ** \param[in] aIdx  The application Id index inside the AppToContextIdTable
 ** \param[in] session_id The session Id
 ** \param[in] LocalCoreContext the working context table
 ** \param[out] foundContextId the index in the working context table of the
 **             context that matches the app_id-context_id pair
 **
 ** \return Whether the the provided info matches a registered context
 ** \retval TRUE The context was identified
 ** \retval FALSE The context was not identified.
 **
 **/
STATIC FUNC(boolean, DLT_CODE) Dlt_ContextIdIdentified
(
  Dlt_Internal_ContextIDType context_id,
  Dlt_AppIdTableIdxType aIdx,
  Dlt_SessionIDType session_id,
  Dlt_BSWDistributionCommonType LocalCoreContext,
  P2VAR(Dlt_ContextIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) foundContextIdIdx
);

/** \brief Initialize internal buffer management variables
 **
 ** This function initializes the internal buffer management variables
 ** for the DLT module.
 **
 ** \return void
 **/
STATIC FUNC(void, DLT_CODE) Dlt_InitInternalBuffer(void);

#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
/** \brief Shift the application Ids into the Dlt_AppIdTable with one position
 **
 ** This function is called by Dlt_InternalUnregisterContext
 **
 ** \param[in] AppIdStartIdx Application start index
 ** \param[in] CoreContext   Pointer to current local core context
 **
 ** \return void
 */
STATIC FUNC(void, DLT_CODE) Dlt_InternalUnregisterContextShiftAppIds(
    Dlt_AppIdTableIdxType AppIdStartIdx,
    P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) CoreContext);

/** \brief Clear the AppId entries in the SessionId table
 **        when all ContextIds are unregistered from a specific AppId
 **
 ** This function is called by Dlt_InternalUnregisterContext
 **
 ** \param[in] SessionIdStartIdx SessionId start index
 ** \param[in] CoreContext       Pointer to current local core context
 **
 ** \return void
 */
STATIC FUNC(void, DLT_CODE) Dlt_InternalUnregisterContextClearSessionIdTable(
    Dlt_SessionIdTableIdxType SessionIdStartIdx,
    P2VAR(Dlt_BSWDistributionCommonType,AUTOMATIC, DLT_APPL_DATA) CoreContext);

/** \brief Store in the table the session Id at the same index as the one in the configuration
 **
 ** This function is called by Dlt_InternalRegisterContext
 **
 ** \param[in] CoreContext pointer to current local core context
 ** \param[in] session_id current session id
 ** \param[in] sesIdx SessionIdTableIdx
 ** \param[in] CitIdx ContextIdTable index
 ** \param[in] contextIdx context index in DltSwCContextInfo
 **
 ** \return void
 */
STATIC FUNC(void, DLT_CODE) Dlt_InternalRegisterContextStoreSessionId(
    P2VAR(Dlt_BSWDistributionCommonType,AUTOMATIC, DLT_APPL_DATA) CoreContext,
    Dlt_SessionIDType session_id,
    Dlt_SessionIdTableIdxType sesIdx,
    Dlt_ContextIdTableIdxType CitIdx,
    Dlt_ContextIdTableIdxType contextIdx);

/** \brief Function for internal handling of registered pairs of contextID and
 ** Application ID
 **
 ** \param[in] session_id number of the module (Module ID within BSW,
 **     port defined argument value within SW-C)
 ** \param[in] app_id the Application ID
 ** \param[in] context_id the Context ID
 ** \param[out] CoreContext pointer to local CoreContext
 ** \param[in] AppDesc Points to description string for the
 **     provided application id. At maximum 255 characters are
 **     interpreted.
 ** \param[in] AppDescLen length of the Application description
 ** \param[in] sesIdx Index of the session Id
 ** \param[in] contextIdx Index of the contextId
 **
 ** \return void
 */
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_InternalRegisterLocalContext(
    Dlt_SessionIDType session_id,
    Dlt_Internal_ApplicationIDType app_id,
    Dlt_Internal_ContextIDType context_id,
    P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) CoreContext,
    P2CONST(uint8, DLT_CONST, DLT_CONST) AppDesc,
    uint8 AppDescLen,
    Dlt_SessionIdTableIdxType sesIdx,
    Dlt_ContextIdTableIdxType contextIdx);
#endif

/** \brief Create a new entry in the App id tables
 **
 ** This function is called by Dlt_InternalRegisterContext
 **
 ** \param[in] session_id Session ID of the current request
 ** \param[in] CoreContext pointer to current local core context
 ** \param[in] aIdx Dlt_AppIdTable index
 ** \param[in] sesIdx SessionIdTableIdx
 ** \param[in] app_id internal application id
 ** \param[in] CitIdx ContextIdTable index
 ** \param[in] ApplToCtxIdx AppToContextIdTable index
 **
 ** \return void
 */
STATIC FUNC(void, DLT_CODE) Dlt_InternalRegisterContextCreateNewEntry(
    Dlt_SessionIDType session_id,
    P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) CoreContext,
    Dlt_AppIdTableIdxType aIdx,
    Dlt_Internal_ApplicationIDType app_id,
    Dlt_ContextIdTableIdxType CitIdx,
    Dlt_AppToContextIdTableIdxType ApplToCtxIdx);

#if (DLT_IMPLEMENT_VFB_TRACE == STD_ON)
STATIC FUNC(void, DLT_CODE) Dlt_VfbComposePayload(
    P2VAR(Dlt_MsgLengthType, AUTOMATIC, DLT_APPL_DATA) PayloadLength);

STATIC FUNC(void, DLT_CODE) Dlt_VfbComposePayloadLength(void);
#endif /* #if (DLT_IMPLEMENT_VFB_TRACE == STD_ON) */

#define DLT_STOP_SEC_CODE
#include <Dlt_MemMap.h>

/*==================[internal data]=========================================*/

#define DLT_START_SEC_VAR_CLEARED_8
#include <Dlt_MemMap.h>

#if(DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
/* !LINKSTO SWS_Dlt_00003,1, SWS_Dlt_00342,1 */
/** \brief Message ring buffer */
STATIC VAR(uint8, DLT_VAR) Dlt_MessageBuffer[DLT_MESSAGE_BUFFER_SIZE];
#endif

#define DLT_STOP_SEC_VAR_CLEARED_8
#include <Dlt_MemMap.h>

#if  (STD_ON == DLT_GETECUID_AT_RUNTIME)
#define DLT_START_SEC_VAR_INIT_8
#include <Dlt_MemMap.h>

STATIC VAR(uint8, DLT_VAR) Dlt_UserEcuId[DLT_ECU_HEADER_LENGTH] = {0U, 0U, 0U, 0U};

#define DLT_STOP_SEC_VAR_INIT_8
#include <Dlt_MemMap.h>
#endif

#define DLT_START_SEC_VAR_CLEARED_16
#include <Dlt_MemMap.h>

/** \brief Length of last transmitted message **/
STATIC VAR(Dlt_MsgLengthType, DLT_VAR) Dlt_LastMessageLen[DLT_TXPDU_NO];
/** \brief Counter which ensures that the global variables Dlt_BufferStoreIdx is updated correctly **/
STATIC VAR(uint16, DLT_VAR) Dlt_StoreInterruptedCnt;

#if (DLT_STARTUP_DELAY_TIMER > 0U)
/** \brief Variable to count the delay until transmission is allowed. In main function periods.
 *  Max value for DLT_STARTUP_DELAY_TIMER is 10k, so uint16 is appropriate here **/
STATIC VAR(uint16, DLT_VAR) Dlt_StartupTransmissionDelay;
#endif /* DLT_STARTUP_DELAY_TIMER */

#define DLT_STOP_SEC_VAR_CLEARED_16
#include <Dlt_MemMap.h>


#define DLT_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <Dlt_MemMap.h>
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
#endif
/** \brief Internal indexes to process data reception and transmission **/
STATIC VAR(Dlt_InternalVarsTxRx_Type, DLT_VAR) Dlt_InternalVarsTxRx[DLT_TXPDU_NO];
/** \brief Stucture to store information describing the confirmed and copied data **/
STATIC VAR(Dlt_TxConnectionType, DLT_VAR) Dlt_TxConnection[DLT_TXPDU_NO];

#if (DLT_IMPLEMENT_NV_RAM_STORAGE == STD_ON)
/** \brief Variable to hold index of the last registered ApplicationId **/
STATIC VAR(Dlt_AppIdTableIdxType, DLT_VAR) Dlt_LastApplIdxRegistered;
/** \brief Variable to hold index of the last registered ContextId to a given ApplicationId **/
STATIC VAR(Dlt_AppToContextIdTableIdxType, DLT_VAR) Dlt_LastAppToCtxRefIdxRegistered;
#endif

#define DLT_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <Dlt_MemMap.h>

/*==================[external data]=========================================*/

#define DLT_START_SEC_VAR_CLEARED_8
#include <Dlt_MemMap.h>

/* !LINKSTO SWS_Dlt_00319,1 */
/** \brief Global message counter **/
VAR(uint8, DLT_VAR) Dlt_HeaderMessageCounter[DLT_TXPDU_NO];

#define DLT_STOP_SEC_VAR_CLEARED_8
#include <Dlt_MemMap.h>

#define DLT_START_SEC_VAR_INIT_8
#include <Dlt_MemMap.h>

/* !LINKSTO SWS_Dlt_00077,1 */
VAR(uint8, DLT_VAR) Dlt_HeaderUseEcuId = DLT_HEADER_CONFIG_ECU_ID_BIT;
VAR(uint8, DLT_VAR) Dlt_HeaderUseExtendedHeader = DLT_HEADER_CONFIG_EXTENDED_HEADER_BIT;
VAR(uint8, DLT_VAR) Dlt_HeaderUseSessionID = DLT_HEADER_CONFIG_SESSION_ID_BIT;
/* !LINKSTO Dlt.DltProtocol.UseVerboseMode.InitialValue,1*/
VAR(uint8, DLT_VAR) Dlt_HeaderUseVerboseMode = DLT_USE_VERBOSE_MODE;

#if (DLT_IMPLEMENT_TIMESTAMP != STD_OFF)
VAR(uint8, DLT_VAR) Dlt_HeaderUseTimestamp = DLT_HEADER_CONFIG_TIMESTAMP_BIT;
#endif /* DLT_IMPLEMENT_TIMESTAMP != STD_OFF */

VAR(Dlt_MessageLogLevelType, DLT_VAR) Dlt_DefaultLogLevel = DLT_DEFAULT_MAX_LOG_LEVEL;
VAR(Dlt_MessageTraceStatusType, DLT_VAR) Dlt_DefaultTraceStatus = DLT_DEFAULT_TRACE_STATUS;
VAR(Dlt_FilterMessagesType, DLT_VAR) Dlt_FilterMessages = DLT_FILTER_MESSAGES;

VAR(uint8, DLT_VAR) Dlt_HeaderLength = DLT_INIT_HEADER_LENGTH;
VAR(uint8, DLT_VAR) Dlt_InitStateMaster = DLT_UNINITIALIZED;

#if (DLT_IMPLEMENT_VFB_TRACE == STD_ON)
VAR(uint8, DLT_VAR) Dlt_TraceData[DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE] = {0U};
VAR(uint8, DLT_VAR) Dlt_LocalTraceData[DLT_VFB_TRACE_PAYLOAD_MAX_SIZE] = {0U};
VAR(uint8, DLT_VAR) Dlt_NoOfMessagesInVfbBuffer = 0U;
VAR(boolean, DLT_VAR) Dlt_IsVfbBufferFull = FALSE;
#endif /* #if (DLT_IMPLEMENT_VFB_TRACE == STD_ON) */

#define DLT_STOP_SEC_VAR_INIT_8
#include <Dlt_MemMap.h>

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
#define DLT_START_SEC_MC_SHARED_VAR_INIT_8
#else
#define DLT_START_SEC_VAR_INIT_8
#endif
#include <Dlt_MemMap.h>

VAR(Dlt_GlobalLogStatusType, DLT_VAR) Dlt_GlobalLogStatus = DLT_LOGGING_ENABLED;

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
/* !LINKSTO Dlt.BswDistribution.SharedMemorySections,1 */
#define DLT_STOP_SEC_MC_SHARED_VAR_INIT_8
#else
#define DLT_STOP_SEC_VAR_INIT_8
#endif
#include <Dlt_MemMap.h>

#if (DLT_IMPLEMENT_VFB_TRACE == STD_ON)

#if (TS_SIZE_PduLengthType == 2U)
#define DLT_START_SEC_VAR_INIT_16
#else /* #if (TS_SIZE_PduLengthType == 4U) */
#define DLT_START_SEC_VAR_INIT_32
#endif /* #if (TS_SIZE_PduLengthType == 2U) */
#include <Dlt_MemMap.h>

VAR(Dlt_MsgLengthType, DLT_VAR) Dlt_TraceDataWriteIdx = 0U;
VAR(Dlt_MsgLengthType, DLT_VAR) Dlt_TraceDataReadIdx = 0U;

#if (TS_SIZE_PduLengthType == 2U)
#define DLT_STOP_SEC_VAR_INIT_16
#else /* #if (TS_SIZE_PduLengthType == 4U) */
#define DLT_STOP_SEC_VAR_INIT_32
#endif /* #if (TS_SIZE_PduLengthType == 2U) */
#include <Dlt_MemMap.h>

#endif /* #if (DLT_IMPLEMENT_VFB_TRACE == STD_ON) */

#define DLT_START_SEC_VAR_INIT_32
#include <Dlt_MemMap.h>
VAR(uint32, DLT_VAR) Dlt_BandwidthForComModule = DLT_BANDWIDTH_FOR_COM_MODULE;

#define DLT_STOP_SEC_VAR_INIT_32
#include <Dlt_MemMap.h>

#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
#if (DLT_REGISTER_CONTEXT_NOTIFICATION == STD_ON)
#define DLT_START_SEC_VAR_INIT_UNSPECIFIED
#include <Dlt_MemMap.h>
/** \brief Flag that is set when a register notification is received and reset when the
           information within the notification is transmitted */
STATIC VAR(boolean, DLT_VAR) Dlt_RegisterCtxtNotification = FALSE;
#define DLT_STOP_SEC_VAR_INIT_UNSPECIFIED
#include <Dlt_MemMap.h>
#endif
#endif

#define DLT_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <Dlt_MemMap.h>

VAR(Dlt_ContextIdTableIdxType, DLT_VAR)       Dlt_ContextIdTableIdx;
VAR(Dlt_ContextIdTableType, DLT_VAR)          Dlt_ContextIdTable[DLT_MAX_COUNT_CONTEXT_IDS];

#define DLT_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <Dlt_MemMap.h>

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
/* !LINKSTO Dlt.BswDistribution.SharedMemorySections,1 */
#define DLT_START_SEC_MC_SHARED_VAR_CLEARED_UNSPECIFIED
#else
#define DLT_START_SEC_VAR_CLEARED_UNSPECIFIED
#endif
#include <Dlt_MemMap.h>

VAR(Dlt_AppIdTableIdxType, DLT_VAR)           Dlt_MaxRegisteredAppldTableEntry;
VAR(Dlt_AppToContextIdTableIdxType, DLT_VAR)  Dlt_AppToContextIdTableIdx[DLT_MAX_COUNT_APP_IDS];
/* !LINKSTO SWS_Dlt_00060,1 */
VAR(Dlt_AppIdTableType, DLT_VAR)              Dlt_AppIdTable[DLT_MAX_COUNT_APP_IDS];
VAR(Dlt_AppToContextIdTableType, DLT_VAR)     Dlt_AppToContextIdTable[DLT_MAX_COUNT_APP_IDS];

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
VAR(Dlt_SessionIdTableType, DLT_VAR)          Dlt_SessionIdTable[DLT_SWC_REGISTERED_NO];
VAR(Dlt_LogChannelThresholdInfoType, DLT_VAR) Dlt_LogChannelThresholdInfo[DLT_TXPDU_NO];
#endif

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
#define DLT_STOP_SEC_MC_SHARED_VAR_CLEARED_UNSPECIFIED
#else
#define DLT_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#endif
#include <Dlt_MemMap.h>

#define DLT_START_SEC_CONST_UNSPECIFIED
#include <Dlt_MemMap.h>

/* We need a valid context pointer, because the spec explicitly allows "send message"
 * calls before Dlt initialization. Since at startup all context tables contain the
 * same entries, we can simply initialize this pointer with the first table. It will
 * be set to the correct table by Dlt_Init() later. This is OK, because before
 * Dlt_Init() completes, IOC communication (and thus changes to the tables) is not
 * possible, anyway. */
CONSTP2CONST(Dlt_BSWMasterContextType, DLT_CONST, DLT_CONST) Dlt_BSWMasterContextPtr = &Dlt_BSWMasterContext;

#define DLT_STOP_SEC_CONST_UNSPECIFIED
#include <Dlt_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

#define DLT_START_SEC_CONST_8
#include <Dlt_MemMap.h>

STATIC CONST(uint8, DLT_CONST) Dlt_HeaderPayloadEndianes = DLT_HEADER_PAYLOAD_ENDIANES_BIT;
STATIC CONST(uint8, DLT_CONST) Dlt_HeaderProtocolVersion = DLT_HEADER_PROTOCOL_VERSION_BIT;

#define DLT_STOP_SEC_CONST_8
#include <Dlt_MemMap.h>

/*==================[external function definitions]=========================*/

#define DLT_START_SEC_CODE
#include <Dlt_MemMap.h>

/*------------------[Dlt_Init]----------------------------------------------*/
/* !LINKSTO Dlt.DltPersistentStorage.DltModuleOperational,1 */
FUNC(void, DLT_CODE) Dlt_Init(
    P2CONST(Dlt_ConfigType, AUTOMATIC, DLT_APPL_CONST) config)
{
  Dlt_AppToContextIdTableIdxType i;
  uint8 CtxIdx;
#if (STD_ON == DLT_GETECUID_AT_RUNTIME)
  P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) PEcuId;
#endif
#if (DLT_IMPLEMENT_NV_RAM_STORAGE == STD_ON)
  Std_ReturnType requestForNative = E_NOT_OK;
  Std_ReturnType requestForDataSet = E_NOT_OK;
#endif
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  CoreIdType CurrentCoreId = GetCoreID();
#endif

  TS_PARAM_UNUSED(config);

  DBG_DLT_INIT_ENTRY();

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  if (CurrentCoreId == DLT_MASTER_CORE)
#endif
  {
    Dlt_ChnIdTableIdxType chnIdx;
#if (DLT_STARTUP_DELAY_TIMER > 0U)
    /* Initialize the transmission delay */
    /* !LINKSTO Dlt.ASR431.SWS_Dlt_00648, 1 */
    Dlt_StartupTransmissionDelay = (DLT_STARTUP_DELAY_TIMER/DLT_MAINFUNCTION_PERIOD);
#endif /* (DLT_STARTUP_DELAY_TIMER > 0U) */
#if (DLT_TRAFFIC_SHAPER_ENABLED == STD_ON)
    for (chnIdx = 0; chnIdx < DLT_TXPDU_NO; chnIdx++)
    {
      /* Reset data used for traffic shaping */
      DLT_INIT_TRAFFIC_SHAPING_INFO(chnIdx);
    };
#else
    TS_PARAM_UNUSED(chnIdx);
#endif /* (DLT_TRAFFIC_SHAPER_ENABLED == STD_ON) */

    /* Initialize traffic shaper */
    Dlt_BandwidthForComModule = DLT_BANDWIDTH_FOR_COM_MODULE;

    /* Initialize registered contexts */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    *Dlt_BSWMasterContextPtr->CoreContext.MaxRegisteredAppldTableEntry = 0U;
    *Dlt_BSWMasterContextPtr->CoreContext.ContextIdTableIdx = 0U;
#else
    Dlt_MaxRegisteredAppldTableEntry = 0U;
    Dlt_ContextIdTableIdx = 0U;
#endif

    for (i = 0U; i < DLT_MAX_COUNT_APP_IDS; i++)
    {
#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
      TS_MemBZero(&Dlt_AppToContextIdTable[i].ContextIdTableIdx,
          sizeof(Dlt_AppToContextIdTable[i].ContextIdTableIdx));
      Dlt_AppToContextIdTableIdx[i] = 0U;
#else
      TS_MemBZero(&Dlt_BSWMasterContextPtr->CoreContext.AppToContextIdTable[i].ContextIdTableIdx,
          sizeof(Dlt_BSWMasterContextPtr->CoreContext.AppToContextIdTable[i].ContextIdTableIdx));
      Dlt_BSWMasterContextPtr->CoreContext.AppToContextIdTableIdx[i] = 0U;

      /* !LINKSTO Dlt.ASR431.SWS_ResetCtxtAppDesc, 1 */
      TS_MemBZero(&Dlt_BSWMasterContextPtr->CoreContext.AppIdTable[i], sizeof(Dlt_BSWMasterContextPtr->CoreContext.AppIdTable[i]));
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
    }
    /* Initialize message filter */
    /* !LINKSTO SWS_Dlt_00348, 1 */
    DLT_INIT_FILTERING_INFO();

    /* Initialize message header fields */
    /* !LINKSTO Dlt.DltProtocol.UseVerboseMode.InitialValue, 1 */
    DLT_INIT_MESSAGE_HEADER_FIELDS();

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    for (CtxIdx = 0; CtxIdx < DLT_MAX_COUNT_CONTEXT_IDS; CtxIdx ++)
    {
      for (chnIdx = 0; chnIdx < DLT_TXPDU_NO; chnIdx ++)
      {
        /* !LINKSTO Dlt.LogChannelsInitRuntimeChnIdxReset,1 */
        Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[CtxIdx].ChannelsIdx[chnIdx] = FALSE;
      }
      /* !LINKSTO Dlt.ASR431.SWS_Dlt_00658,1, Dlt.EB_Req_LogLevelRuntimeForEachContext,1 */
      Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[CtxIdx].LogLevel = DLT_DEFAULT_MAX_LOG_LEVEL;
      /* !LINKSTO Dlt.EB_Req_TraceStatusRuntimeForEachContext, 1 */
      Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[CtxIdx].TraceStatus = DLT_DEFAULT_TRACE_STATUS;
      /* !LINKSTO Dlt.ASR431.SWS_ResetCtxtAppDesc, 1 */
      TS_MemBZero(&Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[CtxIdx].ContextDescription, APPCTXDEXLEN);
      TS_MemBZero(&Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[CtxIdx].ContextId,
          sizeof(Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[CtxIdx].ContextId));
      Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[CtxIdx].SessionIdTableIdx = 0U;
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
      Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[CtxIdx].OsCoreId = DLT_INVALID_CORE_ID;
#endif /* #if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
      Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[CtxIdx].VerboseMode = DLT_USE_VERBOSE_MODE;
    }

    for (i = 0U; i < DLT_SWC_REGISTERED_NO; i++)
    {
      TS_MemBZero(&Dlt_BSWMasterContextPtr->CoreContext.SessionIdTable[i],
          sizeof(Dlt_BSWMasterContextPtr->CoreContext.SessionIdTable[i]));
    }

    /* !LINKSTO Dlt.EB_Req_LogChannelsInitRuntimeVars, 1 */
    TS_MemCpy(&Dlt_LogChannelThresholdInfo[0U], &Dlt_CfgLogChannelThresholdInfo[0U], sizeof(Dlt_CfgLogChannelThresholdInfo));
#else
    TS_PARAM_UNUSED(CtxIdx);
    TS_PARAM_UNUSED(chnIdx);
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
    /* !LINKSTO SWS_Dlt_00070, 1,
                Dlt.ASR431.SWS_Dlt_00649, 1,
                EB_Ref_SWS_Dlt_00453, 1,
                SWS_Dlt_00491, 1,
                EB_Ref_SWS_Dlt_00288_2, 1 */
#if (DLT_IMPLEMENT_NV_RAM_STORAGE == STD_ON)
    /* Call NvM_ReadBlock to copy the values of the runtime variables
       from NvM block to Dlt RAM */
    /* call NvM_ReadBlock API for NvM native block*/
    /* !LINKSTO Dlt.OptionalInterfaces, 1 */
    /* !LINKSTO Dlt.swdd.DltPersistentStorage.BlockIdForNativeBlock, 1 */
    /* Deviation TASKING-1 */
    requestForNative = NvM_ReadBlock(DLT_STORE_NATIVE_NVRAM_BLOCK_ID, NULL_PTR);
    /* select corresponding NVRAM block dataset */
    /* !LINKSTO Dlt.swdd.DltPersistentStorage.BlockIdForDataSetBlock, 1 */
    requestForDataSet = NvM_SetDataIndex(DLT_STORE_DATASET_NVRAM_BLOCK_ID, 0U);
    if (E_OK == requestForDataSet)
    {
      /* !LINKSTO Dlt.swdd.DltPersistentStorage.BlockIdForDataSetBlock, 1 */
      /* call NvM_ReadBlock for dataset NvM block */
      /* Deviation TASKING-2 */
      requestForDataSet = NvM_ReadBlock(DLT_STORE_DATASET_NVRAM_BLOCK_ID, NULL_PTR);
    }

#if (DLT_DEV_ERROR_DETECT == STD_OFF)
    TS_PARAM_UNUSED(requestForNative);
#else /* #if (DLT_DEV_ERROR_DETECT == STD_ON) */
    if((requestForNative != E_OK) || (requestForDataSet != E_OK))
    {
      DLT_DET_REPORT_ERROR(DLT_SID_Init, DLT_E_REQUEST_NOT_ACCEPTED);
    }
#endif /* #if (DLT_DEV_ERROR_DETECT == STD_OFF) */

#endif /*DLT_IMPLEMENT_NV_RAM_STORAGE == STD_ON*/

    /* Initialize internal buffer management variables */
    Dlt_InitInternalBuffer();

#if (DLT_IMPLEMENT_VFB_TRACE == STD_ON)
    /* Register the contexts for VFB tracing. This function calls
     * Dlt_InternalRegisterContext() when DltServiceAPI != AUTOSAR_431
     * and Dlt_RegisterContext() when DltServiceAPI == AUTOSAR_431,
     * for each configured tracing hook. If the hook has already been registered
     * (e.g. because it is part of the NvM data), this function will handle it. */
    /* !LINKSTO Dlt.swdd.DltConfig.Misc.JetTemplates.HookFunctions.CallRegCtxtfromInit, 1 */
    /* CHECK: NOPARSE */
    if ( (*Dlt_BSWMasterContextPtr->CoreContext.InitState == DLT_INITIALIZED) ||
         (*Dlt_BSWMasterContextPtr->CoreContext.InitState == DLT_INITIALIZED_PERSISTENT) )
    /* CHECK: PARSE */
    {
      /* Deviation MISRAC2012-2 */
      Dlt_RegisterVFBContexts();
    }
    /* CHECK: NOPARSE */
    else
    {
      /* In order to register the VFB contexts, the Dlt module needs to be initialized with either
       * DLT_INITIALIZED or DLT_INITIALIZED_PERSISTENT. (because of a Dlt_RegisterContext() call).
       *
       * If persistent storage is disabled, the Dlt_InitInternalBuffer() internal function
       * always initializes the module with DLT_INITIALIZED.
       *
       * If persistent storage is enabled and data sets are successfully restored from the NvM blocks,
       * the Dlt module will be initialized with DLT_INITIALIZED_PERSISTENT by Dlt_NvMSingleBlockCallbackDataSet().
       *
       * If persistent storage is enabled and data sets are not restored from the NvM blocks,
       * the Dlt module will be initialized with DLT_INITIALIZED by Dlt_InitInternalBuffer().
       *
       * There is no possibility for the module to be uninitialized when reaching this point.
       */
      DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_SID_Init);
    }
    /* CHECK: PARSE */
#endif /* DLT_IMPLEMENT_VFB_TRACE == STD_ON */
  }
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  else
  {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    Dlt_ChnIdTableIdxType LogChannelIdx;
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

    Dlt_BSWSatelliteContextPtrType SatelliteContextPtr     = Dlt_GetSatelliteContextPtr();

    *(SatelliteContextPtr->CoreContext.InitState)          = DLT_INITIALIZED;
    *(SatelliteContextPtr->CoreContext.ContextIdTableIdx)  = 0U;
    *(SatelliteContextPtr->CoreContext.DefaultLogLevel)    = DLT_DEFAULT_MAX_LOG_LEVEL;
    *(SatelliteContextPtr->CoreContext.DefaultTraceStatus) = DLT_DEFAULT_TRACE_STATUS;
    *(SatelliteContextPtr->CoreContext.FilterMessages)     = DLT_FILTER_MESSAGES;

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    *(SatelliteContextPtr->CoreContext.MaxRegisteredAppldTableEntry) = 0U;
    *(SatelliteContextPtr->CoreContext.AppToContextIdTableIdx)       = 0U;

    for (i = 0U; i < DLT_MAX_COUNT_APP_IDS; i++)
    {
      TS_MemBZero(&SatelliteContextPtr->CoreContext.AppIdTable[i],
          sizeof(SatelliteContextPtr->CoreContext.AppIdTable[i]));
      TS_MemBZero(&SatelliteContextPtr->CoreContext.AppToContextIdTable[i],
          sizeof(SatelliteContextPtr->CoreContext.AppToContextIdTable[i]));
    }

    for (i = 0U; i < DLT_MAX_COUNT_CONTEXT_IDS; i++)
    {
      for (LogChannelIdx = 0U; LogChannelIdx < DLT_TXPDU_NO; LogChannelIdx++)
      {
        /* !LINKSTO Dlt.LogChannelsInitRuntimeChnIdxReset,1 */
        SatelliteContextPtr->CoreContext.ContextIdTable[i].ChannelsIdx[LogChannelIdx] = FALSE;
      }
      /* !LINKSTO Dlt.ASR431.SWS_Dlt_00658,1, Dlt.EB_Req_LogLevelRuntimeForEachContext,1 */
      SatelliteContextPtr->CoreContext.ContextIdTable[i].LogLevel = DLT_DEFAULT_MAX_LOG_LEVEL;
      /* !LINKSTO Dlt.EB_Req_TraceStatusRuntimeForEachContext, 1 */
      SatelliteContextPtr->CoreContext.ContextIdTable[i].TraceStatus = DLT_DEFAULT_TRACE_STATUS;
      /* !LINKSTO Dlt.ASR431.SWS_ResetCtxtAppDesc, 1 */
      TS_MemBZero(&SatelliteContextPtr->CoreContext.ContextIdTable[i].ContextDescription, APPCTXDEXLEN);
      TS_MemBZero(&SatelliteContextPtr->CoreContext.ContextIdTable[i].ContextId,
          sizeof(SatelliteContextPtr->CoreContext.ContextIdTable[i].ContextId));
      SatelliteContextPtr->CoreContext.ContextIdTable[i].SessionIdTableIdx = 0U;
      SatelliteContextPtr->CoreContext.ContextIdTable[i].OsCoreId = CurrentCoreId;
      SatelliteContextPtr->CoreContext.ContextIdTable[i].VerboseMode = DLT_USE_VERBOSE_MODE;
    }

    for (i = 0U; i < DLT_SWC_REGISTERED_NO; i++)
    {
      TS_MemBZero(&SatelliteContextPtr->CoreContext.SessionIdTable[i],
          sizeof(SatelliteContextPtr->CoreContext.SessionIdTable[i]));
    }
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

  }
#endif

#if (DLT_RECEPTION_CONTROL_MESSAGES_ENABLED == STD_ON)
  Dlt_InitReceiveProcessor();

#if (DLT_ON_ETHERNET == STD_ON)
  /* No meaningful reaction on error */
  (void) SoAd_OpenSoCon(DLT_RX_SOCKET_ID);
#endif
#endif

#if (STD_ON == DLT_GETECUID_AT_RUNTIME)
  /* !LINKSTO EB_Req_EcuIdChoice.Callout.Functionality, 1,
     EB_Req_EcuIdChoice.Callout.Init, 1 */
  PEcuId = (uint8 *)Dlt_AppGetEcuIdAddress();
  if (NULL_PTR != PEcuId)
  {
    TS_MemCpy(Dlt_UserEcuId,PEcuId,DLT_ECU_HEADER_LENGTH_STATIC);
  }
#if (DLT_DEV_ERROR_DETECT == STD_ON)
  else
  {
    /* !LINKSTO EB_Req_EcuIdChoice.Callout.DetOn.NULL_PTR, 1 */
    DLT_DET_REPORT_ERROR(DLT_SID_GetEcuIdAddress, DLT_E_PARAM_POINTER);
  }
#endif /* #if (DLT_DEV_ERROR_DETECT == STD_ON) */
#endif /* #if (STD_ON == DLT_GETECUID_AT_RUNTIME) */

  DBG_DLT_INIT_EXIT();
}

/*------------------[Dlt_GetVersionInfo]------------------------------------*/
#if (DLT_VERSION_INFO_API == STD_ON)
FUNC(void, DLT_CODE) Dlt_GetVersionInfo(
    P2VAR(Std_VersionInfoType, AUTOMATIC, DLT_APPL_DATA) versioninfo)
{
  DBG_DLT_GETVERSIONINFO_ENTRY(versioninfo);

#if (DLT_DEV_ERROR_DETECT == STD_ON)
  if (versioninfo == NULL_PTR)
  {
    DLT_DET_REPORT_ERROR(DLT_SID_GetVersionInfo, DLT_E_PARAM_POINTER);
  }
  else
#endif /* DLT_DEV_ERROR_DETECT */
  {
    versioninfo->vendorID         = DLT_VENDOR_ID;
    versioninfo->moduleID         = DLT_MODULE_ID;
    versioninfo->sw_major_version = DLT_SW_MAJOR_VERSION;
    versioninfo->sw_minor_version = DLT_SW_MINOR_VERSION;
    versioninfo->sw_patch_version = DLT_SW_PATCH_VERSION;
  }

  DBG_DLT_GETVERSIONINFO_EXIT(versioninfo);
}
#endif /* (DLT_VERSION_INFO_API == STD_ON) */

#define DLT_STOP_SEC_CODE
#include <Dlt_MemMap.h>

#if (DLT_INCLUDE_RTE == STD_ON)
#define Dlt_START_SEC_CODE
#else
#define DLT_START_SEC_CODE
#endif
#include <Dlt_MemMap.h>

/*------------------[Dlt_SendLogMessage]------------------------------------*/
/* !LINKSTO SWS_Dlt_00241,1 */
/* !LINKSTO Dlt.ASR431.SWS_Dlt_00241,1 */
/* !LINKSTO SWS_Dlt_00007,1, SWS_Dlt_00009,1, SWS_Dlt_00010,1 */
FUNC(Dlt_ReturnType, DLT_CODE) Dlt_ASR43_SendLogMessage(
    Dlt_SessionIDType session_id,
    P2CONST(Dlt_MessageLogInfoType, AUTOMATIC, DLT_APPL_CONST) log_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) log_data,
    uint16 log_data_length)
{
  uint8 CanLogMsgBeSentAtLeastOnce = 0U;

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_SessionIdTableIdxType sessionIdx = DLT_SESSION_ID_NULL;
  Dlt_ReturnType retVal = DLT_E_ERROR;
#else
  /* !LINKSTO EB_Req_Dlt_SendLogMessage.InvalidMessageType.Return.ASR42,1,
              EB_Req_Dlt_SendLogMessage.NullPointerReturn.ASR42,2 */
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
#endif

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.CoreID, 1 */
  CoreIdType CurrentCoreId = GetCoreID();
  Dlt_BSWSatelliteContextPtrType SatelliteContextPtr = (CurrentCoreId != DLT_MASTER_CORE) ?
      Dlt_GetSatelliteContextPtr() : NULL_PTR;
  Dlt_BSWDistributionCommonType LocalCoreContext = (CurrentCoreId != DLT_MASTER_CORE) ?
      SatelliteContextPtr->CoreContext : Dlt_BSWMasterContextPtr->CoreContext;
#else
  /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.SingleCoreArchitecture,1 */
  Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
#endif

  DBG_DLT_SENDLOGMESSAGE_ENTRY(session_id, log_info, log_data, log_data_length);

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  /* Check if there is a valid session id in the configuration */
  /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.SessionIDCheck, 1 */
  Dlt_FindSessionIDEntry(FALSE, session_id, &LocalCoreContext, &sessionIdx);
#endif

#if (DLT_DEV_ERROR_DETECT == STD_ON)
  /* !LINKSTO Dlt.ASR431.SWS_Dlt_00755, 1 */
  if((log_info == NULL_PTR) || (log_data == NULL_PTR))
  {
    /* The SWS does not tell us which error we should return in this
    case. DLT_E_PARAM_POINTER is specified as DET error, but not as valid
    return value of Dlt_Returntype. Taking this into consideration DLT_E_ERROR_UNKNOWN
    is returned to signal that this execution should not end in a success */

    /* !LINKSTO EB_Req_Dlt_SendLogMessage.NullPointerDET,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_SendLogMessage, DLT_E_PARAM_POINTER);
  }
  else if (((uint8)((log_info->options) & DLT_OPT_MESSAGE_TYPE_MASK)) != (DLT_TYPE_LOG << DLT_OPT_MESSAGE_TYPE_POS))
  {
    /* !LINKSTO EB_Req_Dlt_SendLogMessage.InvalidMessageType.DET,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_SendLogMessage, DLT_E_WRONG_PARAMETERS);
  }
  else
#endif
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  if (sessionIdx == DLT_SWC_REGISTERED_NO)
  {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
    /* !LINKSTO EB_Req_Dlt_SendLogMessage.InvalidSesId.DET,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_SendLogMessage, DLT_E_UNKNOWN_SESSION_ID);
#endif
    /* If no matching session ID could be found, return the corresponding
     * error. */
  /* !LINKSTO EB_Req_Dlt_SendLogMessage.InvalidSesId.Return,1 */
    retVal = DLT_E_UNKNOWN_SESSION_ID;
  }
  else
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
  {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    Dlt_Internal_ApplicationIDType logInfoAppId_Internal = DLT_UINT32_CONVERT_TUPLE(log_info->app_id);
    Dlt_Internal_ContextIDType logInfoContextId_Internal = DLT_UINT32_CONVERT_TUPLE(log_info->context_id);
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
    Dlt_ApplicationIDType logInfoAppId_Internal = log_info->app_id;
    Dlt_ContextIDType logInfoContextId_Internal = log_info->context_id;
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

    /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.GlobalLoggingCheck,1 */
    if (Dlt_GlobalLogStatus == DLT_LOGGING_ENABLED)
    {
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      uint8 isMessageSent = 0U;
      /* !LINKSTO EB_Ref_Dlt.ASR431.SWS_Dlt_00650_STEP4,1 */
      /* Filter message length allowed to be sent on a logging session */
      if (log_data_length > Dlt_SwCLogInfo[sessionIdx].MaxSwCLogMessageLength)
      {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        /* !LINKSTO EB_Req_Dlt_SendLogMessage.MsgTooLarge.DET,1 */
        DLT_DET_REPORT_ERROR(DLT_SID_SendLogMessage, DLT_E_NO_BUFFER);
#endif
        /* !LINKSTO EB_Req_Dlt_SendLogMessage.MsgTooLarge.Return,1 */
        retVal = DLT_E_NO_BUFFER;
      }
      else
#endif
      {
        boolean ContextIdIdentified = FALSE;
        Dlt_ContextIdTableIdxType IdentifiedContextIdIdx = 0U;
        Dlt_AppIdTableIdxType aIdx = 0U;

        Dlt_FindApplicationIDEntry(session_id, logInfoAppId_Internal, &LocalCoreContext, &aIdx);

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        /* Is there an application already registered ? */
        /* Log information on context NULL - wild card for context id */
        if ((logInfoContextId_Internal == DLT_CTX_ID_NULL)&&(*LocalCoreContext.MaxRegisteredAppldTableEntry != aIdx))
        {
          Dlt_MessageLogInfoType localLogInfo;
          Dlt_AppIdTableIdxType atcIdx;

          /* if context is null, each context for the requested application id shall be sent with the same log message */
          for (atcIdx = 0U; atcIdx < LocalCoreContext.AppToContextIdTableIdx[aIdx]; atcIdx++)
          {
            localLogInfo.arg_count  = log_info->arg_count;
            localLogInfo.log_level  = log_info->log_level;
            localLogInfo.options    = log_info->options;
            DLT_FILL_BUFFER_32(localLogInfo.context_id, 0U, LocalCoreContext.ContextIdTable[LocalCoreContext.AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx]].ContextId);
            TS_MemCpy(&localLogInfo.app_id[0U], log_info->app_id, sizeof(log_info->app_id));

            Dlt_EnterExclusiveAreaAnyCoreContext();

            /* !LINKSTO EB_Ref_SWS_Dlt_00661_P2,1 */
            ContextIdIdentified = Dlt_ContextIdIdentified(LocalCoreContext.ContextIdTable[LocalCoreContext.AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx]].ContextId,
                                                          aIdx,
                                                          session_id,
                                                          LocalCoreContext,
                                                          &IdentifiedContextIdIdx);
            Dlt_ExitExclusiveAreaAnyCoreContext();
            /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.ForwardRequest,1 */
            retVal = Dlt_FindCtxtAndSendLogMsg(session_id, IdentifiedContextIdIdx, (Dlt_MessageLogInfoType *)&localLogInfo, log_data, (uint16)log_data_length, ContextIdIdentified, &CanLogMsgBeSentAtLeastOnce);

            if (CanLogMsgBeSentAtLeastOnce == DLT_MESSAGE_SENT_ONCE)
            {
              /* message was sent at least once */
              isMessageSent =  DLT_MESSAGE_SENT_ONCE;
            }
            if (isMessageSent != DLT_MESSAGE_SENT_ONCE)
            {
              /* message was not sent because of a wrong level value */
              isMessageSent = DLT_MESSAGE_NOT_SENT;
            }
          }
        }
        else /*(logInfoContextId_Internal == DLT_CTX_ID_NULL)*/
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
        {
          /* This is for the case when either the application is not registered - => wild card for it
           * or application id was found in the registration table and it will be further used to
           * find context */
          Dlt_EnterExclusiveAreaAnyCoreContext();
          /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.MessageIdentifyContext,1 */
          ContextIdIdentified = Dlt_ContextIdIdentified(logInfoContextId_Internal, aIdx, session_id, LocalCoreContext, &IdentifiedContextIdIdx);
          Dlt_ExitExclusiveAreaAnyCoreContext();
          /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.ForwardRequest,1 */
          retVal = Dlt_FindCtxtAndSendLogMsg(session_id, IdentifiedContextIdIdx, log_info, log_data, (uint16)log_data_length, ContextIdIdentified, &CanLogMsgBeSentAtLeastOnce);
        }
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          /* Map the error for 4.3 ASR version */
          /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00670_LogChannel_NoBuffer,1 */
          /* !LINKSTO Dlt.ASR431.SWS_Dlt_00666,1 */
          /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00672,1 */
         if ((CanLogMsgBeSentAtLeastOnce == DLT_MESSAGE_SENT_ONCE)||
             (isMessageSent == DLT_MESSAGE_SENT_ONCE))
         {
           retVal = DLT_E_OK;
         }
         if ((retVal != DLT_E_NO_BUFFER)&&
             (retVal != DLT_E_MSG_TOO_LARGE)&&
             (retVal != DLT_E_UNKNOWN_SESSION_ID)&&
             (retVal != DLT_E_OK))
         {
           retVal = DLT_E_OK;
         }
#endif
      } /* (log_data_length > Dlt_SwCLogInfo[sessionIdx].MaxSwCLogMessageLength) */
    }/* (Dlt_GlobalLogStatus == DLT_LOGGING_ENABLED) */
    /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.GlobalLoggingDisabled,1 */
    else
    {
      retVal = DLT_E_OK;
    }
  }

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  if (retVal == DLT_E_ERROR)
  {
    retVal = DLT_E_UNKNOWN_SESSION_ID;
  }
#else
  TS_PARAM_UNUSED(CanLogMsgBeSentAtLeastOnce);
#endif
  DBG_DLT_SENDLOGMESSAGE_EXIT(retVal, session_id, log_info, log_data, log_data_length);

  return retVal;
}

#if (DLT_INCLUDE_RTE == STD_ON)
#define Dlt_STOP_SEC_CODE
#else
#define DLT_STOP_SEC_CODE
#endif
#include <Dlt_MemMap.h>

#define DLT_START_SEC_CODE
#include <Dlt_MemMap.h>

STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_FindCtxtAndSendLogMsg(
    Dlt_SessionIDType session_id,
    uint32 identified_ctxt_id_idx,
    P2CONST(Dlt_MessageLogInfoType, AUTOMATIC, DLT_APPL_CONST) log_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) log_data,
    Dlt_MsgLengthType log_data_length,
    boolean context_id_identified,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once)
{
  /* !LINKSTO EB_Ref_Dlt.ASR431.SWS_Dlt_00650_STEP1,1 */
  /* Generate timestamp */
  uint32 timestamp = Dlt_GetTimestamp();
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ReturnType retVal = DLT_E_ERROR;
#else
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
#endif

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.CoreID,1 */
  CoreIdType CurrentCoreId = GetCoreID();

  Dlt_BSWDistributionCommonType LocalCoreContext = (CurrentCoreId != DLT_MASTER_CORE) ?
    Dlt_GetSatelliteContextPtr()->CoreContext : Dlt_BSWMasterContextPtr->CoreContext;
#else
  Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */

#if ((DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) || (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431))
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  uint8 DltCoreInitState = (CurrentCoreId != DLT_MASTER_CORE) ?
      *LocalCoreContext.InitState : Dlt_InitStateMaster;
#else
  uint8 DltCoreInitState = Dlt_InitStateMaster;
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
#endif /* ((DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) || (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)) */

  TS_PARAM_UNUSED(at_least_once);
  if (((uint8)((log_info->options) & DLT_OPT_VERBOSE_MODE_MASK)) != 0U)
  {
    /* !LINKSTO Dlt.DltProtocol.UseVerboseMode.SetFlag,1 */
    /* Check that there is a registered appId ContextId pair and, if so,
     * if verbose mode is deactivated for that pair */
    if (context_id_identified == TRUE)
    {
      if (LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].VerboseMode == FALSE)
      {
        /* verbose mode was deactivated for this specific appId ContextId pair */
        /* !LINKSTO SWS_Dlt_00090,1 */
        retVal = DLT_E_NOT_IN_VERBOSE_MODE;
      }
    }
#if (DLT_USE_VERBOSE_MODE == STD_OFF)
    else
    {
      /* !LINKSTO SWS_Dlt_00300,1, Dlt.DltProtocol.UseVerboseMode.ClearFlag,1 */
      /* !LINKSTO SWS_Dlt_00090,1 */
      retVal = DLT_E_NOT_IN_VERBOSE_MODE;
    }
#endif /* (DLT_USE_VERBOSE_MODE == STD_OFF) */
  }
  /* Send message only if the tuple has verbose mode ON */
  /* !LINKSTO Dlt_VerboseOffDiscardMessage,1 */
  if (retVal != DLT_E_NOT_IN_VERBOSE_MODE)
  {
    /* !LINKSTO SWS_Dlt_00065,1 */
#if (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON)
    /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.MessageFilterEnabled,1 */
    if ((DltCoreInitState != DLT_UNINITIALIZED) && (*LocalCoreContext.FilterMessages == DLT_FILTER_MESSAGES_ON))
    {
      if (context_id_identified == TRUE)
      {
        retVal = Dlt_SendLogMsgContextIdIdentified(session_id,
                  identified_ctxt_id_idx,
                  log_info,
                  log_data,
                  log_data_length,
                  at_least_once,
                  timestamp);
      }
      else
      {
        if (*LocalCoreContext.DefaultLogLevel != DLT_LOG_OFF)
        {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          retVal = Dlt_SendLogMsgContextIdNotIdentified(session_id,
                    log_info,
                    log_data,
                    log_data_length,
                    at_least_once,
                    timestamp);
#else /* (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
          /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.ContextNotRegistered4.2, 1 */
          retVal = DLT_E_UNKNOWN_SESSION_ID;
#endif
        }
        else
        {
          /* !LINKSTO Dlt.FilterMessages.PairOfApplIDContextID, 1 */
          retVal = DLT_E_UNKNOWN_SESSION_ID;
        }
      }
    }
    else
#endif /* (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) */
    /* !LINKSTO SWS_Dlt_00066,1 */
    {
#if(DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
      boolean ChannelsIdx[DLT_TXPDU_NO] = { FALSE };
#endif

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      if (context_id_identified == TRUE)
#else
      if ((context_id_identified == TRUE) || (DltCoreInitState == DLT_UNINITIALIZED))
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
      {
        uint8 chnIdx;
        /* When message filtering is off, the message will be sent on every assigned channel,
         * including on the default one */
        for (chnIdx = 0U; chnIdx < DLT_TXPDU_NO; chnIdx++)
        {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          if (LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].ChannelsIdx[chnIdx] == TRUE)
#endif
          {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF)
            /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.MessageFilterDisabled,1,
                        Dlt.swdd.DltCore.API.SendTraceMessage.InternalDispatch,1,
                        Dlt.swdd.DltCore.API.SendTraceMessage.InternalDispatchReturn,1 */
            /* Deviation MISRAC2012-1 */
            retVal = Dlt_InternalDispatchSendMessage(chnIdx, session_id,
                       (P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_DATA)) log_info,
                       log_data, log_data_length, DLT_SID_SendLogMessage, timestamp);
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
            if (retVal == DLT_E_OK)
            {
              (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
            }
            else
            {
              if ((*at_least_once) != DLT_MESSAGE_SENT_ONCE)
              {
                (*at_least_once) = DLT_MESSAGE_NOT_SENT;
              }
            }
#endif
#else /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
            ChannelsIdx[chnIdx] = TRUE;
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF) */
          }
        }
      } /* (context_id_identified == TRUE) */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      else
      {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF)
        /* Deviation MISRAC2012-1 */
        retVal = Dlt_InternalDispatchSendMessage(DEFAULT_LOG_CHN_IDX, session_id,
                   (P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_DATA)) log_info,
                   log_data, log_data_length, DLT_SID_SendLogMessage, timestamp);
#else
        ChannelsIdx[DEFAULT_LOG_CHN_IDX] = TRUE;
#endif
      }
#else /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
      else
      {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        /* !LINKSTO Dlt.SendLogMessage.FilteringOffInvalidSessionId.DetOn.ASR42,1 */
        DLT_DET_REPORT_ERROR(DLT_SID_SendLogMessage, DLT_E_UNKNOWN_SESSION_ID);
#endif
        /* !LINKSTO Dlt.SendLogMessage.FilteringOffInvalidSessionId.ASR42,1 */
        /* Deviation TASKING-3 */
        retVal = DLT_E_UNKNOWN_SESSION_ID;
      }
#endif

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
      /* Deviation MISRAC2012-1 */
      retVal = Dlt_InternalDispatchSendMessage(ChannelsIdx, session_id,
               (P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_DATA)) log_info,
               log_data, log_data_length, DLT_SID_SendLogMessage, timestamp);
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      if (retVal == DLT_E_OK)
      {
        (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
      }
      else
      {
        (*at_least_once) = DLT_MESSAGE_NOT_SENT;
      }
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
    }
  }
  return retVal;
}

#if (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON)
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_SendLogMsgContextIdIdentified(
    Dlt_SessionIDType session_id,
    uint32 identified_ctxt_id_idx,
    P2CONST(Dlt_MessageLogInfoType, AUTOMATIC, DLT_APPL_CONST) log_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) log_data,
    Dlt_MsgLengthType log_data_length,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once,
    uint32 timestamp)
{

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ReturnType retVal = DLT_E_ERROR;
#else
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
#endif
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  CoreIdType CurrentCoreId = GetCoreID();

  Dlt_BSWDistributionCommonType LocalCoreContext = (CurrentCoreId != DLT_MASTER_CORE) ?
    Dlt_GetSatelliteContextPtr()->CoreContext : Dlt_BSWMasterContextPtr->CoreContext;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  boolean ChannelFound = FALSE;
#endif
#else /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF) */
  Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
  Dlt_MessageLogLevelType cur_log_level = *LocalCoreContext.DefaultLogLevel;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  *at_least_once = FALSE;
#else
  TS_PARAM_UNUSED(at_least_once);
#endif
  /* On an already registered context , the log level of the found context shall be used,
   * otherwise log level used shall be the default one */

  /* CHECK: NOPARSE */
  if (LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].LogLevel != DLT_LOG_DEFAULT)
  /* CHECK: PARSE */
  {
    cur_log_level = LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].LogLevel;
  }
  /* CHECK: NOPARSE */
  else
  {
   /* When registering an AppId/ContextId tuple, Dlt_RegisterContext() assigns and stores
    * a log level (between 0 and 6) for the tuple.
    *
    * When Dlt_SendLogMsgContextIdIdentified() reads the registered tuple's information,
    * the log level is always going to be between 0 and 6 and never the value of DLT_LOG_DEFAULT (0xffU).
    *
    * As such, the else branch cannot be reached. */
    DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_SID_SendLogMessage);
  }
  /* CHECK: PARSE */

  /* !LINKSTO Dlt.ASR431.SWS_Dlt_00658,1, Dlt.MessageFiltering.TupleLogLevel,1, EB_Ref_Dlt.ASR431.SWS_Dlt_00650_STEP2,1,
              Dlt.swdd.DltCore.API.SendLogMessage.FilterThreshold, 1,
              Dlt.swdd.DltCore.API.SendLogMessage.SingleCoreLogLevelPassFilterCondition, 1*/
  if ((cur_log_level != DLT_LOG_OFF) && (log_info->log_level <= cur_log_level))
  {
#if(DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
    boolean ChannelsIdx[DLT_TXPDU_NO] = { FALSE };
#endif
    uint8 ChnIdx;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    boolean isOnlyDefaultAssigned = TRUE;

    for (ChnIdx = 0U; ChnIdx < DLT_TXPDU_NO; ChnIdx++)
    {
      /* !LINKSTO EB_Ref_Dlt.ASR431.SWS_Dlt_00650_STEP3,1 */
      if((LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].ChannelsIdx[ChnIdx] == TRUE)&&
         (ChnIdx != DEFAULT_LOG_CHN_IDX))
      {
        isOnlyDefaultAssigned = FALSE;
        break;
      }
    }
    /* If there are channels assigned to the ApplicationId/ContextId tuple, other than the default one, then,
     * verify if there is possible
     * the tuple information can be sent on these channels */
     /* !LINKSTO Dlt.SendLogMessage.OnDefaultLogChannel, 1, EB_Ref_SWS_Dlt_00661_P1, 1 */
    if (isOnlyDefaultAssigned == FALSE)
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
    {
      for (ChnIdx = 0U; ChnIdx < DLT_TXPDU_NO; ChnIdx++)
      {
        /* If context is assigned to any channel and context log threshold has a lower LogLevel value than the
         * configured one of LogChannel threshold , then the message will be transmitted on that log channel */
        /* !LINKSTO Dlt.MessageFiltering.LogChannel.LogLevelThreshold,1, EB_Ref_Dlt.ASR431.SWS_Dlt_00650_STEP5,1, Dlt.ASR431.Ref_SWS_Dlt_00665_Step1, 1 */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        if ((LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].ChannelsIdx[ChnIdx] == TRUE) &&
            (ChnIdx != DEFAULT_LOG_CHN_IDX) &&
            (LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].LogLevel <= Dlt_LogChannelThresholdInfo[ChnIdx].DltLogChannelThreshold))
#endif
        {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF)
          /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.MessageFilterDisabled,1,
                      Dlt.ASR431.SWS_Dlt_00003,1 */
          /* Deviation MISRAC2012-1 */
          retVal = Dlt_InternalDispatchSendMessage(ChnIdx,
                    session_id,
                    (P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_DATA)) log_info,
                    log_data,
                    log_data_length,
                    DLT_SID_SendLogMessage,
                    timestamp);
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          if (retVal == DLT_E_OK)
          {
            (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
          }
#endif
#else /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
          ChannelsIdx[ChnIdx] = TRUE;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          ChannelFound = TRUE;
#endif
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF) */
        }
#if ((DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) && (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF))
        else
        {
          if ((*at_least_once) != DLT_MESSAGE_SENT_ONCE)
          {
            /* !LINKSTO Dlt.MessageFiltering.LogChannel.LogLevelThreshold,1 */
            /* message shall be discarded and DLT_E_OK return status shall be sent*/
            (*at_least_once) = DLT_MESSAGE_NOT_SENT;
          }
        }
#endif
      }
    }
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    /* If no channel is assigned to the ApplicationId/ContextId tuple, then, verify if the tuple's information can be sent on the default channel */
    else
    {
      /* If context is assigned to any channel and context log threshold has a lower LogLevel value than the
       * configured one of LogChannel threshold , then the message will be transmitted on that log channel */
      /* !LINKSTO Dlt.MessageFiltering.LogChannel.LogLevelThreshold,1, EB_Ref_Dlt.ASR431.SWS_Dlt_00650_STEP2,1 , Dlt.SendLogMessage.LogChannelNotAssigned,1,
                  Dlt.ASR431.Ref_SWS_Dlt_00665_Step1, 1 */
      if (LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].LogLevel <=
          Dlt_LogChannelThresholdInfo[DEFAULT_LOG_CHN_IDX].DltLogChannelThreshold)
      {
#if(DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF)
        /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.InternalSendMessage,1,
                    Dlt.swdd.DltCore.API.SendLogMessage.InternalSendMessageReturnValue,1,
                    Dlt.ASR431.SWS_Dlt_00003,1 */
        /* Deviation MISRAC2012-1 */
        retVal = Dlt_InternalDispatchSendMessage(DEFAULT_LOG_CHN_IDX,
                  session_id,
                  (P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_DATA)) log_info,
                  log_data,
                  log_data_length,
                  DLT_SID_SendLogMessage,
                  timestamp);
        if (retVal == DLT_E_OK)
        {
          (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
        }
#else
        ChannelsIdx[DEFAULT_LOG_CHN_IDX] = TRUE;
        ChannelFound = TRUE;
#endif
      }
    }
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    if (ChannelFound == TRUE)
#endif
    {
      /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.InternalSendMessage,1,
                  Dlt.swdd.DltCore.API.SendLogMessage.InternalSendMessageReturnValue,1,
                  Dlt.ASR431.SWS_Dlt_00003,1 */
      /* Deviation MISRAC2012-1 */
      retVal = Dlt_InternalDispatchSendMessage(ChannelsIdx,
                session_id,
                (P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_DATA)) log_info,
                log_data,
                log_data_length,
                DLT_SID_SendLogMessage,
                timestamp);
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      if (retVal == DLT_E_OK)
      {
        (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
      }
      else
      {
        /* !LINKSTO Dlt.MessageFiltering.LogChannel.LogLevelThreshold,1 */
        /* message shall be discarded and DLT_E_OK return status shall be sent*/
        (*at_least_once) = DLT_MESSAGE_NOT_SENT;
      }
#endif
    }
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
  }
  else
  {
    /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.LogLevelFilterNOK, 1 */
    retVal = DLT_E_OK;
  }

  return retVal;
}

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)

STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_SendLogMsgContextIdNotIdentified(
    Dlt_SessionIDType session_id,
    P2CONST(Dlt_MessageLogInfoType, AUTOMATIC, DLT_APPL_CONST) log_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) log_data,
    Dlt_MsgLengthType log_data_length,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once,
    uint32 timestamp)
{
  Dlt_ReturnType retVal = DLT_E_ERROR;

  /* !LINKSTO EB_Ref_Dlt.ASR431.SWS_Dlt_00650_STEP2,1,
     Dlt.swdd.DltCore.API.SendLogMessage.SingleCoreLogLevelPassFilterCondition, 1 */
  /* if no context is identified, check if trace information is corresponding with the default's log channel one
   * and send it to the default channel */
  if (log_info->log_level <= Dlt_LogChannelThresholdInfo[DEFAULT_LOG_CHN_IDX].DltLogChannelThreshold)
  {
    /* !LINKSTO EB_Ref_SWS_Dlt_00661_P3, 1, Dlt.ASR431.Ref_SWS_Dlt_00665_Step3, 1 */
#if(DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
    boolean ChannelsIdx[DLT_TXPDU_NO] = { FALSE };
    ChannelsIdx[DEFAULT_LOG_CHN_IDX] = TRUE;
    /* Deviation MISRAC2012-1 */
    retVal = Dlt_InternalDispatchSendMessage(ChannelsIdx,
              session_id,
              (P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_DATA)) log_info,
              log_data,
              log_data_length,
              DLT_SID_SendLogMessage,
              timestamp);
#else
    /* Deviation MISRAC2012-1 */
    retVal = Dlt_InternalDispatchSendMessage(DEFAULT_LOG_CHN_IDX,
              session_id,
              (P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_DATA)) log_info,
              log_data,
              log_data_length,
              DLT_SID_SendLogMessage,
              timestamp);
#endif

    if (retVal == DLT_E_OK)
    {
      (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
    }
    else
    {
      (*at_least_once) = DLT_MESSAGE_NOT_SENT;
    }
  }
  else
  {
    /* !LINKSTO Dlt.MessageFiltering.LogChannel.LogLevelThreshold,1 */
    retVal = DLT_E_OK;
    (*at_least_once) = DLT_MESSAGE_NOT_SENT;
  }

  return retVal;
}
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
#endif /* (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) */

#define DLT_STOP_SEC_CODE
#include <Dlt_MemMap.h>

#if (DLT_INCLUDE_RTE == STD_ON)
#define Dlt_START_SEC_CODE
#else
#define DLT_START_SEC_CODE
#endif
#include <Dlt_MemMap.h>

/*-----------------------------[Dlt_SendTraceMessage]------------------*/
/* !LINKSTO SWS_Dlt_00243,1 */
/* !LINKSTO Dlt.ASR431.SWS_Dlt_00243, 1 */
/* !LINKSTO SWS_Dlt_00333,1, SWS_Dlt_00009,1 */
FUNC(Dlt_ReturnType, DLT_CODE) Dlt_ASR43_SendTraceMessage(
    Dlt_SessionIDType session_id,
    P2CONST(Dlt_MessageTraceInfoType, AUTOMATIC, DLT_APPL_CONST) trace_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) trace_data,
    uint16 trace_data_length)
{
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_SessionIdTableIdxType sessionIdx = DLT_SESSION_ID_NULL;
  Dlt_ReturnType retVal = DLT_E_ERROR;
#else
  /* !LINKSTO EB_Req_Dlt_SendTraceMessage.InvalidMessageType.Return.ASR42,1,
              EB_Req_Dlt_SendTraceMessage.NullPointer.Return.ASR42,1 */
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
#endif
  boolean ContextIdIdentified = FALSE;
  Dlt_ContextIdTableIdxType IdentifiedContextIdIdx = DLT_CTX_ID_NULL;
  uint8 CanTraceMsgBeSentAtLeastOnce = 0U;

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  CoreIdType CurrentCoreId = GetCoreID();
  Dlt_BSWSatelliteContextPtrType SatelliteContextPtr = (CurrentCoreId != DLT_MASTER_CORE) ?
      Dlt_GetSatelliteContextPtr() : NULL_PTR;
  Dlt_BSWDistributionCommonType LocalCoreContext = (CurrentCoreId != DLT_MASTER_CORE) ?
      SatelliteContextPtr->CoreContext : Dlt_BSWMasterContextPtr->CoreContext;
#else
    Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
#endif

  DBG_DLT_SENDTRACEMESSAGE_ENTRY(session_id, trace_info, trace_data, trace_data_length);

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  /* !LINKSTO Dlt.swdd.DltCore.API.SendTraceMessage.SessionIDCheck, 1 */
  /* Find Session Index in the existing pre-configured table */
  Dlt_FindSessionIDEntry(FALSE, session_id, &LocalCoreContext, &sessionIdx);
#endif

#if (DLT_DEV_ERROR_DETECT == STD_ON)
  /* !LINKSTO Dlt.ASR431.SWS_Dlt_00755,1 */
  if ((trace_info == NULL_PTR) || (trace_data == NULL_PTR))
  {
    /* The SWS does not tell us which error we should return in this
       case. DLT_E_PARAM_POINTER is specified as DET error, but not as valid
       return value of Dlt_Returntype. Taking this into consideration DLT_E_ERROR_UNKNOWN
    is returned to signal that this execution should not end in a success */
     /* !LINKSTO EB_Req_Dlt_SendTraceMessage.NullPointer.DET,2 */
    DLT_DET_REPORT_ERROR(DLT_SID_SendTraceMessage, DLT_E_PARAM_POINTER);
  }
  else if ( (((uint8)((trace_info->options) & DLT_OPT_MESSAGE_TYPE_MASK)) != (DLT_TYPE_APP_TRACE << DLT_OPT_MESSAGE_TYPE_POS)) &&
            (((uint8)((trace_info->options) & DLT_OPT_MESSAGE_TYPE_MASK)) != (DLT_TYPE_NW_TRACE << DLT_OPT_MESSAGE_TYPE_POS)))
  {
    /* !LINKSTO EB_Req_Dlt_SendTraceMessage.InvalidMessageType.DET,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_SendTraceMessage, DLT_E_WRONG_PARAMETERS);
  }
  /* !LINKSTO PRS_Dlt_00620,1 */
  else if ((trace_info->trace_info < DLT_TRACE_VARIABLE) ||
           (trace_info->trace_info > DLT_TRACE_VFB))
  {
    DLT_DET_REPORT_ERROR(DLT_SID_SendTraceMessage, DLT_E_WRONG_PARAMETERS);
  }
  else
#endif
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  if (sessionIdx == DLT_SWC_REGISTERED_NO)
  {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
    /* !LINKSTO EB_Req_Dlt_SendTraceMessage.InvalidSesId.DET, 1 */
    DLT_DET_REPORT_ERROR(DLT_SID_SendTraceMessage, DLT_E_UNKNOWN_SESSION_ID);
#endif
    /* !LINKSTO Dlt.swdd.DltCore.API.SendTraceMessage.InvalidSessionId, 1 */
    retVal = DLT_E_UNKNOWN_SESSION_ID;
  }
  else
#endif
  {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    Dlt_Internal_ApplicationIDType traceInfoAppId_Internal = DLT_UINT32_CONVERT_TUPLE(trace_info->app_id);
    Dlt_Internal_ContextIDType traceInfoContextId_Internal = DLT_UINT32_CONVERT_TUPLE(trace_info->context_id);
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
    Dlt_ApplicationIDType traceInfoAppId_Internal = trace_info->app_id;
    Dlt_ContextIDType traceInfoContextId_Internal = trace_info->context_id;
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

    /* !LINKSTO Dlt.swdd.DltCore.API.SendTraceMessage.GlobalLogging,1 */
    if (Dlt_GlobalLogStatus == DLT_LOGGING_ENABLED)
    {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      uint8 isMessageSent = 0U;
      /* Filter message length if it can be sent as a trace message*/
      if(trace_data_length > Dlt_SwCLogInfo[sessionIdx].MaxSwCTraceMessageLength)
      {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        /* !LINKSTO EB_Req_Dlt_SendTraceMessage.MsgTooLarge.DET,1 */
        DLT_DET_REPORT_ERROR(DLT_SID_SendTraceMessage, DLT_E_NO_BUFFER);
#endif
        /* !LINKSTO EB_Req_Dlt_SendTraceMessage.MsgTooLarge.Return,1 */
        retVal = DLT_E_NO_BUFFER;
      }
      else
#endif
      {
        Dlt_AppIdTableIdxType aIdx = 0U;

        Dlt_FindApplicationIDEntry(session_id, traceInfoAppId_Internal, &LocalCoreContext, &aIdx);
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        if ((traceInfoContextId_Internal == DLT_CTX_ID_NULL)&&
            (*LocalCoreContext.MaxRegisteredAppldTableEntry != aIdx))
        {
          Dlt_AppIdTableIdxType atcIdx;
          Dlt_MessageTraceInfoType localtraceInfo;

          /* if context is null, each context for the requested application id shall be sent with the same log message */
          for (atcIdx = 0U; atcIdx < LocalCoreContext.AppToContextIdTableIdx[aIdx]; atcIdx++)
          {
            Dlt_EnterExclusiveAreaAnyCoreContext();
            DLT_FILL_BUFFER_32(localtraceInfo.context_id, 0U, LocalCoreContext.ContextIdTable[LocalCoreContext.AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx]].ContextId);
            Dlt_ExitExclusiveAreaAnyCoreContext();
            TS_MemCpy(&localtraceInfo.app_id[0U], trace_info->app_id, sizeof(trace_info->app_id));
            localtraceInfo.options = trace_info->options;
            localtraceInfo.trace_info = trace_info->trace_info;
            Dlt_EnterExclusiveAreaAnyCoreContext();

            /* !LINKSTO Dlt.swdd.DltCore.API.SendTraceMessage.ContextRegistered,1 */
            ContextIdIdentified = Dlt_ContextIdIdentified(LocalCoreContext.ContextIdTable[LocalCoreContext.AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx]].ContextId,
                                                          aIdx,
                                                          session_id,
                                                          LocalCoreContext,
                                                          &IdentifiedContextIdIdx);

            Dlt_ExitExclusiveAreaAnyCoreContext();
            /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00665_Step2, 1 */
            retVal = Dlt_FindCtxtAndSendTraceMsg(session_id, IdentifiedContextIdIdx, (Dlt_MessageTraceInfoType *)&localtraceInfo, trace_data, (uint16)trace_data_length, ContextIdIdentified, &CanTraceMsgBeSentAtLeastOnce);

            /* !LINKSTO Dlt.ASR431.SWS_Dlt_00666,1, EB_Ref_SWS_Dlt_00661_P2,1 */
            if (CanTraceMsgBeSentAtLeastOnce == DLT_MESSAGE_SENT_ONCE)
            {
              /* message was sent at least once*/
              isMessageSent =  DLT_MESSAGE_SENT_ONCE;
            }
            if (isMessageSent != DLT_MESSAGE_SENT_ONCE)
            {
              /*message was not sent because of a wrong level value*/
              isMessageSent = DLT_MESSAGE_NOT_SENT;
            }
          }
        }
        else
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
        {
          Dlt_EnterExclusiveAreaAnyCoreContext();
          ContextIdIdentified = Dlt_ContextIdIdentified(traceInfoContextId_Internal, aIdx, session_id, LocalCoreContext, &IdentifiedContextIdIdx);
          Dlt_ExitExclusiveAreaAnyCoreContext();
          retVal = Dlt_FindCtxtAndSendTraceMsg(session_id, IdentifiedContextIdIdx, trace_info, trace_data, (uint16)trace_data_length, ContextIdIdentified, &CanTraceMsgBeSentAtLeastOnce);
        }
      }
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      if ((CanTraceMsgBeSentAtLeastOnce == DLT_MESSAGE_SENT_ONCE)||
          (isMessageSent == DLT_MESSAGE_SENT_ONCE))
      {
        retVal = DLT_E_OK;
      }
        /* Map the error for 4.3 ASR version */
        /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00670_LogChannel_NoBuffer,1 */
        /* !LINKSTO Dlt.ASR431.SWS_Dlt_00666,1 */
        /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00672,1 */
       if ((retVal != DLT_E_NO_BUFFER)&&
           (retVal != DLT_E_MSG_TOO_LARGE)&&
           (retVal != DLT_E_UNKNOWN_SESSION_ID)&&
           (retVal != DLT_E_OK))
       {
         retVal = DLT_E_OK;
       }
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
    }
    else
    {
      /* !LINKSTO Dlt.swdd.DltCore.API.SendTraceMessage.GlobalLoggingDisabled,1 */
      retVal = DLT_E_OK;
    }
  }
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  if (retVal == DLT_E_ERROR)
  {
    retVal = DLT_E_UNKNOWN_SESSION_ID;
  }
#else
  TS_PARAM_UNUSED(CanTraceMsgBeSentAtLeastOnce);
#endif
  DBG_DLT_SENDTRACEMESSAGE_EXIT(retVal, session_id, trace_info, trace_data, trace_data_length);
  return retVal;
}

#if (DLT_INCLUDE_RTE == STD_ON)
#define Dlt_STOP_SEC_CODE
#else
#define DLT_STOP_SEC_CODE
#endif
#include <Dlt_MemMap.h>

#define DLT_START_SEC_CODE
#include <Dlt_MemMap.h>

STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_FindCtxtAndSendTraceMsg(
    Dlt_SessionIDType session_id,
    uint32 identified_ctxt_id_idx,
    P2CONST(Dlt_MessageTraceInfoType, AUTOMATIC, DLT_APPL_CONST) trace_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) trace_data,
    Dlt_MsgLengthType trace_data_length,
    boolean context_id_identified,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once)
{
  uint32 timestamp = Dlt_GetTimestamp();
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  CoreIdType CurrentCoreId = GetCoreID();

  Dlt_BSWDistributionCommonType LocalCoreContext = (CurrentCoreId != DLT_MASTER_CORE) ?
    Dlt_GetSatelliteContextPtr()->CoreContext : Dlt_BSWMasterContextPtr->CoreContext;
#else
  Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */

#if ((DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) || (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431))
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  uint8 DltCoreInitState = (CurrentCoreId != DLT_MASTER_CORE) ?
      *LocalCoreContext.InitState : Dlt_InitStateMaster;
#else /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF) */
  uint8 DltCoreInitState = Dlt_InitStateMaster;
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
#endif /* ((DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) || (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)) */

#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ReturnType retVal = DLT_E_ERROR;
#else
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
  TS_PARAM_UNUSED(at_least_once);
#endif

  if (((uint8)((trace_info->options) & DLT_OPT_VERBOSE_MODE_MASK)) != 0U)
  {
    /* !LINKSTO Dlt.DltProtocol.UseVerboseMode.SetFlag,1 */
    /* Check that there is a registered appId ContextId pair and, if so,
     * if verbose mode is deactivated for that pair */
    if (context_id_identified == TRUE)
    {
      if (LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].VerboseMode == FALSE)
      {
        /* verbose mode was deactivated for this specific appId ContextId pair */
        /* !LINKSTO SWS_Dlt_00090,1 */
        retVal = DLT_E_NOT_IN_VERBOSE_MODE;
      }
    }
#if (DLT_USE_VERBOSE_MODE == STD_OFF)
    else
    {
      /* !LINKSTO SWS_Dlt_00300,1, Dlt.DltProtocol.UseVerboseMode.ClearFlag,1 */
      /* !LINKSTO SWS_Dlt_00090,1 */
      retVal = DLT_E_NOT_IN_VERBOSE_MODE;
    }
#endif /* (DLT_USE_VERBOSE_MODE == STD_OFF) */
  }
  /* Only send trace message if tuple has verbose mode enabled
   * !LINKSTO Dlt_VerboseOffDiscardMessage,1 */
  if (retVal != DLT_E_NOT_IN_VERBOSE_MODE)
  {
    uint8 ChnIdx = 0U;

    /* !LINKSTO SWS_Dlt_00065,1,
                Dlt.swdd.DltCore.API.SendTraceMessage.FilterEnabled,1 */
#if (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON)
    if ((DltCoreInitState != DLT_UNINITIALIZED) && (*LocalCoreContext.FilterMessages == DLT_FILTER_MESSAGES_ON))
    {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      *at_least_once = 0U;
#endif
      if (context_id_identified == TRUE)
      {
        retVal = Dlt_SendTraceMsgContextIdIdentified(session_id,
            identified_ctxt_id_idx,
            trace_info,
            trace_data,
            trace_data_length,
            at_least_once,
            timestamp);
      }
      else
      {
        if (*LocalCoreContext.DefaultTraceStatus == DLT_TRACE_STATUS_ON)
        {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          retVal = Dlt_SendTraceMsgContextIdNotIdentified(session_id,
                      trace_info,
                      trace_data,
                      trace_data_length,
                      at_least_once,
                      timestamp);
#else /* (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
          /* If no matching session ID could be found, return the corresponding error. */
          /* !LINKSTO Dlt.swdd.DltCore.API.SendTraceMessage.ContextIdNotRegistered,1 */
          retVal = DLT_E_UNKNOWN_SESSION_ID;
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
        }
        else
        {
          /* !LINKSTO Dlt.FilterMessages.PairOfApplIDContextID, 1 */
          retVal = DLT_E_UNKNOWN_SESSION_ID;
        }
      }
    }
      /* !LINKSTO SWS_Dlt_00066,1,
                  SWS_Dlt_00068,1,
                  Dlt.swdd.DltCore.API.SendTraceMessage.MultiCoreMessageFilteringDisabled,1 */
    else
#endif /* (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) */
    {
      /* Dlt_MessageTraceInfoType has four elements while Dlt_MessageCommonInfoType has five
       * elements, thus requiring manual element mapping, in order to avoid alignment issues */
      Dlt_MessageCommonInfoType trace_info_common;
#if(DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
      boolean ChannelsIdx[DLT_TXPDU_NO] = { FALSE };
#endif

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      TS_MemCpy(&trace_info_common.app_id, trace_info->app_id, sizeof(trace_info->app_id));
      TS_MemCpy(&trace_info_common.context_id, trace_info->context_id, sizeof(trace_info->context_id));
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
      trace_info_common.app_id = trace_info->app_id;
      trace_info_common.context_id = trace_info->context_id;
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
      trace_info_common.arg_count = 0U;
      trace_info_common.log_level_trace_info = trace_info->trace_info;
      trace_info_common.options = trace_info->options;

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      if (context_id_identified == TRUE)
#else
      if ((context_id_identified == TRUE) || (DltCoreInitState == DLT_UNINITIALIZED))
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
      {
        for (ChnIdx = 0; ChnIdx < DLT_TXPDU_NO; ChnIdx++)
        {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          if (LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].ChannelsIdx[ChnIdx] == TRUE)
#endif
          {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF)
            /* Deviation MISRAC2012-1 */
            retVal = Dlt_InternalDispatchSendMessage(ChnIdx,
                                                     session_id,
                                                     &trace_info_common,
                                                     trace_data,
                                                     trace_data_length,
                                                     DLT_SID_SendTraceMessage,
                                                     timestamp);
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
            if (retVal == DLT_E_OK)
            {
              (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
            }
            else
            {
              if ((*at_least_once) != DLT_MESSAGE_SENT_ONCE)
              {
                (*at_least_once) = DLT_MESSAGE_NOT_SENT;
              }
            }
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
#else /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
            ChannelsIdx[ChnIdx] = TRUE;
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF) */
          }
        }
      }
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      else
      {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF)
        /* Deviation MISRAC2012-1 */
        retVal = Dlt_InternalDispatchSendMessage(DEFAULT_LOG_CHN_IDX,
                                                 session_id,
                                                 &trace_info_common,
                                                 trace_data,
                                                 trace_data_length,
                                                 DLT_SID_SendTraceMessage,
                                                 timestamp);
#else /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
        ChannelsIdx[DEFAULT_LOG_CHN_IDX] = TRUE;
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF) */
      }
#else /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
      else
      {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        /* !LINKSTO Dlt.SendTraceMessage.FilteringOffInvalidSessionId.DetOn.ASR42,1 */
        DLT_DET_REPORT_ERROR(DLT_SID_SendTraceMessage, DLT_E_UNKNOWN_SESSION_ID);
#endif
        /* !LINKSTO Dlt.SendTraceMessage.FilteringOffInvalidSessionId.ASR42, 1 */
        /* Deviation TASKING-4 */
        retVal = DLT_E_UNKNOWN_SESSION_ID;
      }
#endif
      /* !LINKSTO Dlt.swdd.SendMessage.API.SendTraceMessage,1 */
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
      /* Deviation MISRAC2012-1 */
      retVal = Dlt_InternalDispatchSendMessage(ChannelsIdx,
                                               session_id,
                                               &trace_info_common,
                                               trace_data,
                                               trace_data_length,
                                               DLT_SID_SendTraceMessage,
                                               timestamp);
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      if (retVal == DLT_E_OK)
      {
        (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
      }
      else
      {
        if ((*at_least_once) != DLT_MESSAGE_SENT_ONCE)
        {
          /* !LINKSTO Dlt.MessageFiltering.LogChannel.LogLevelThreshold,1 */
          /* message shall be discarded and DLT_E_OK return status shall be sent*/
          (*at_least_once) = DLT_MESSAGE_NOT_SENT;
        }
      }
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
    }
  }
  return retVal;
}

#if (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON)
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_SendTraceMsgContextIdIdentified(
    Dlt_SessionIDType session_id,
    uint32 identified_ctxt_id_idx,
    P2CONST(Dlt_MessageTraceInfoType, AUTOMATIC, DLT_APPL_CONST) trace_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) trace_data,
    Dlt_MsgLengthType trace_data_length,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once,
    uint32 timestamp)
{
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  CoreIdType CurrentCoreId = GetCoreID();

  Dlt_BSWDistributionCommonType LocalCoreContext = (CurrentCoreId != DLT_MASTER_CORE) ?
    Dlt_GetSatelliteContextPtr()->CoreContext : Dlt_BSWMasterContextPtr->CoreContext;
#else
  Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
#endif
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ReturnType retVal = DLT_E_ERROR;
#else
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
  TS_PARAM_UNUSED(at_least_once);
#endif

  /* If yes, get either the defined trace status or use the default
   * trace status if configured */
  /* !LINKSTO SWS_Dlt_00067,1,
              Dlt.swdd.DltCore.API.SendTraceMessage.SingleCoreValidSessionId,1,
              Dlt.swdd.DltCore.API.SendTraceMessage.FilterThreshold,1,
              Dlt.ASR431.SWS_Dlt_00659,1,
              Dlt.ASR431.SWS_Dlt_00663,1 */
  if((LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].TraceStatus == DLT_TRACE_STATUS_ON) ||
      ((LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].TraceStatus == DLT_TRACE_STATUS_DEFAULT) &&
        (*LocalCoreContext.DefaultTraceStatus == DLT_TRACE_STATUS_ON)) )
  {
    /* Dlt_MessageTraceInfoType has four elements while Dlt_MessageCommonInfoType has
     * five elements, thus requiring manual element mapping,
     * in order to avoid alignment issues */
    Dlt_MessageCommonInfoType trace_info_common;
    uint8 chnIdx = 0U;

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    boolean ChannelFound = FALSE;
#endif
    boolean ChannelsIdx[DLT_TXPDU_NO] = { FALSE };
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    boolean isOnlyDefaultAssigned = TRUE;
    TS_MemCpy(&trace_info_common.app_id, trace_info->app_id, sizeof(trace_info->app_id));
    TS_MemCpy(&trace_info_common.context_id, trace_info->context_id, sizeof(trace_info->context_id));
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
    trace_info_common.app_id = trace_info->app_id;
    trace_info_common.context_id = trace_info->context_id;
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
    trace_info_common.arg_count = 0U;
    trace_info_common.log_level_trace_info = trace_info->trace_info;
    trace_info_common.options = trace_info->options;
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    for (chnIdx = 0U; chnIdx < DLT_TXPDU_NO; chnIdx++)
    {
      if ((LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].ChannelsIdx[chnIdx] == TRUE)&&
          (chnIdx != DEFAULT_LOG_CHN_IDX))
      {
        isOnlyDefaultAssigned = FALSE;
        break;
      }
    }
    /* !LINKSTO EB_Ref_SWS_Dlt_00661_P1,1 */
    /* If there are channels assigned to the ApplicationId/ContextId tuple, other than the default one, then, verify if there is possible
     * the tuple information can be sent on these channels */
    if (isOnlyDefaultAssigned == FALSE)
#endif
    {
      for (chnIdx = 0U; chnIdx < DLT_TXPDU_NO; chnIdx++)
      {
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        /* message shall be sent on each channel assigned to the ApplicationId/ContextId tuple */
        /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00665_Step1, 1 */
        if ((LocalCoreContext.ContextIdTable[identified_ctxt_id_idx].ChannelsIdx[chnIdx] == TRUE)&&
            (Dlt_LogChannelThresholdInfo[chnIdx].DltLogTraceStatusFlag == TRUE)&&
            (chnIdx != DEFAULT_LOG_CHN_IDX))
#endif
        {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
          ChannelsIdx[chnIdx] = TRUE;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          ChannelFound = TRUE;
#endif
#else /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF) */
          /* Deviation MISRAC2012-1 */
          retVal = Dlt_InternalDispatchSendMessage(chnIdx, session_id,
                                               &trace_info_common,
                                               trace_data,
                                               trace_data_length,
                                               DLT_SID_SendTraceMessage,
                                               timestamp);
          if (retVal == DLT_E_OK)
          {
            (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
          }
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
        }
#if ((DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF) && (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431))
        else
        {
          if (*at_least_once != DLT_MESSAGE_SENT_ONCE)
          {
            /* !LINKSTO Dlt.MessageFiltering.LogChannel.LogLevelThreshold,1 */
            /* message shall be discarded and DLT_E_OK return status shall be sent*/
            (*at_least_once) = DLT_MESSAGE_NOT_SENT;
          }
        }
#endif
      }
    }
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    else
    {
      /* !LINKSTO Dlt.ASR431.SWS_Dlt_00668, 1, Dlt.ASR431.Ref_SWS_Dlt_00665_Step1, 1 */
      /* message shall be sent on each channel assigned to the ApplicationId/ContextId tuple */
      if (Dlt_LogChannelThresholdInfo[DEFAULT_LOG_CHN_IDX].DltLogTraceStatusFlag == TRUE)
      {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
        ChannelsIdx[DEFAULT_LOG_CHN_IDX] = TRUE;
        ChannelFound = TRUE;
#else /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF) */
        /* Deviation MISRAC2012-1 */
        retVal = Dlt_InternalDispatchSendMessage(DEFAULT_LOG_CHN_IDX, session_id,
                                               &trace_info_common,
                                               trace_data,
                                               trace_data_length,
                                               DLT_SID_SendTraceMessage,
                                               timestamp);
        if (retVal == DLT_E_OK)
        {
          (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
        }
        else
        {
          (*at_least_once) = DLT_MESSAGE_NOT_SENT;
        }
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
      }
      else
      {
        /* !LINKSTO Dlt.ASR431.SWS_Dlt_00668,1 */
        (*at_least_once) = DLT_MESSAGE_NOT_SENT;
      }
    }
#endif /* DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431 */

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    if (ChannelFound == TRUE)
#endif /* DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431 */
    {
      /* Deviation MISRAC2012-1 */
      retVal = Dlt_InternalDispatchSendMessage(ChannelsIdx, session_id,
                                               &trace_info_common,
                                               trace_data,
                                               trace_data_length,
                                               DLT_SID_SendTraceMessage,
                                               timestamp);
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      if (retVal == DLT_E_OK)
      {
        (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
      }
      else
      {
        /* !LINKSTO Dlt.MessageFiltering.LogChannel.LogLevelThreshold,1 */
        /* message shall be discarded and DLT_E_OK return status shall be sent*/
        (*at_least_once) = DLT_MESSAGE_NOT_SENT;
      }
#endif
    }
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION != STD_ON) */
  }
  else
  {
    /* !LINKSTO Dlt.ASR431.SWS_Dlt_00663,1, Dlt.EB_Req_Dlt_SendTraceMessage.Autosar42TraceStsOff,1,
                Dlt.swdd.DltCore.API.SendTraceMessage.TraceOFF,1 */
    retVal = DLT_E_OK;
  }

  return retVal;
}

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_SendTraceMsgContextIdNotIdentified(
    Dlt_SessionIDType session_id,
    P2CONST(Dlt_MessageTraceInfoType, AUTOMATIC, DLT_APPL_CONST) trace_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) trace_data,
    Dlt_MsgLengthType trace_data_length,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) at_least_once,
    uint32 timestamp)
{
  Dlt_ReturnType retVal = DLT_E_ERROR;

  /* If no context is identified, check if log information is corresponding with the default's log channel one
   * and send it to the default channel */
  /* !LINKSTO EB_Ref_SWS_Dlt_00661_P3,1 */
  if (TRUE == Dlt_LogChannelThresholdInfo[DEFAULT_LOG_CHN_IDX].DltLogTraceStatusFlag)
  {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
    boolean ChannelsIdx[DLT_TXPDU_NO] = { FALSE };
#endif
    Dlt_MessageCommonInfoType trace_info_common;
    trace_info_common.arg_count = 0U;

    TS_MemCpy(&trace_info_common.app_id, trace_info->app_id, sizeof(trace_info->app_id));
    TS_MemCpy(&trace_info_common.context_id, trace_info->context_id, sizeof(trace_info->context_id));
    trace_info_common.log_level_trace_info = trace_info->trace_info;
    trace_info_common.options = trace_info->options;

    /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00665_Step3, 1 */
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
    ChannelsIdx[DEFAULT_LOG_CHN_IDX] = TRUE;
    /* Deviation MISRAC2012-1 */
    /* !LINKSTO Dlt.swdd.SendMessage.API.SendTraceMessage,1,
                Dlt.swdd.DltCore.API.SendTraceMessage.InternalMessageDispatch,1,
                Dlt.swdd.DltCore.API.SendTraceMessage.InternalMessageDispatchReturn,1,
                Dlt.ASR431.Ref_SWS_Dlt_00665_Step3, 1 */
    retVal = Dlt_InternalDispatchSendMessage(ChannelsIdx, session_id,
                                             &trace_info_common,
                                             trace_data,
                                             trace_data_length,
                                             DLT_SID_SendTraceMessage,
                                             timestamp);
#else
    /* Deviation MISRAC2012-1 */
    retVal = Dlt_InternalDispatchSendMessage(DEFAULT_LOG_CHN_IDX, session_id,
                                             &trace_info_common,
                                             trace_data,
                                             trace_data_length,
                                             DLT_SID_SendTraceMessage,
                                             timestamp);
#endif

    if (retVal == DLT_E_OK)
    {
      (*at_least_once) = DLT_MESSAGE_SENT_ONCE;
    }
    else
    {
      /* !LINKSTO Dlt.ASR431.SWS_Dlt_00668,1 */
      (*at_least_once) = DLT_MESSAGE_NOT_SENT;
    }
  }
  else
  {
    /* !LINKSTO Dlt.ASR431.SWS_Dlt_00663,1 */
    retVal = DLT_E_OK;
  }

  return retVal;
}
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
#endif /* (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) */

#define DLT_STOP_SEC_CODE
#include <Dlt_MemMap.h>

#if (DLT_INCLUDE_RTE == STD_ON)
#define Dlt_START_SEC_CODE
#else
#define DLT_START_SEC_CODE
#endif
#include <Dlt_MemMap.h>

/*-----------------------------[Dlt_RegisterContext]------------------*/
/* !LINKSTO SWS_Dlt_00245,1 */
/* !LINKSTO Dlt.ASR431.SWS_Dlt_00245,1 */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
FUNC(Dlt_ReturnType, DLT_CODE) Dlt_ASR43_RegisterContext(
    Dlt_SessionIDType session_id,
    P2CONST(Dlt_ApplicationIDType, AUTOMATIC, DLT_APPL_CONST) app_id,
    P2CONST(Dlt_ContextIDType, AUTOMATIC, DLT_APPL_CONST) context_id,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) app_description,
    uint8 len_app_description,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) context_description,
    uint8 len_context_description)
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
FUNC(Dlt_ReturnType, DLT_CODE) Dlt_ASR43_RegisterContext(
    Dlt_SessionIDType session_id,
    Dlt_ApplicationIDType app_id,
    Dlt_ContextIDType context_id,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) app_description,
    uint8 len_app_description,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) context_description,
    uint8 len_context_description)
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
{
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  /* !LINKSTO EB_Req_Dlt_RegisterContext.DltUninit.RetVal.ASR431,1 */
  Dlt_ReturnType ReturnValue = DLT_E_UNKNOWN_SESSION_ID;
#else
  /* !LINKSTO EB_Req_Dlt_RegisterContext.DltUninit.RetVal.ASR42,1 */
  Dlt_ReturnType ReturnValue = DLT_E_ERROR_UNKNOWN;
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  CoreIdType CurrentCoreId = GetCoreID();
  /* WARNING: SatelliteContextPtr is NULL_PTR on MASTER core */
  Dlt_BSWSatelliteContextPtrType SatelliteContextPtr = (CurrentCoreId != DLT_MASTER_CORE) ?
      Dlt_GetSatelliteContextPtr() : NULL_PTR;
  Dlt_BSWDistributionCommonType LocalCoreContext = (CurrentCoreId != DLT_MASTER_CORE) ?
      SatelliteContextPtr->CoreContext : Dlt_BSWMasterContextPtr->CoreContext;
  uint8 DltCoreInitState = (CurrentCoreId != DLT_MASTER_CORE) ?
      *LocalCoreContext.InitState : Dlt_InitStateMaster;
#else
  Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
  uint8 DltCoreInitState = Dlt_InitStateMaster;
#endif /* #if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_Internal_ApplicationIDType AppId_Internal = 0U;
  Dlt_Internal_ContextIDType ContextId_Internal = 0U;
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
  Dlt_ApplicationIDType AppId_Internal = app_id;
  Dlt_ContextIDType ContextId_Internal = context_id;
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
  TS_PARAM_UNUSED(app_description);
  TS_PARAM_UNUSED(len_app_description);
  TS_PARAM_UNUSED(context_description);
  TS_PARAM_UNUSED(len_context_description);
#endif

  /* Check if Dlt is initialized */
  if (DltCoreInitState == DLT_UNINITIALIZED)
  {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
    /* !LINKSTO  EB_Req_Dlt_RegisterContex_DltNotInitDET,1,
              Dlt.swdd.BSWDistribution.DltNotInit.ApiNotAvailable,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_NOT_INITIALIZED);
#endif /* (DLT_DEV_ERROR_DETECT == STD_ON) */
  }
  else
  {
#if ( (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) && (DLT_DEV_ERROR_DETECT == STD_ON) )
    if ( (app_id == NULL_PTR) || (context_id == NULL_PTR) || (context_description == NULL_PTR) )
    {
      DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_PARAM_POINTER);
    }
    else if (len_context_description == 0U)
    {
      /* !LINKSTO EB_Ref_SWS_ASR_4.3_RegisterContext_RetVal_Dlt_WrongParamOrNullPtr,1 */
      DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_WRONG_PARAMETERS);
    }
    else
#endif /* #if ( (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) && (DLT_DEV_ERROR_DETECT == STD_ON) ) */
    {
      boolean ContextIdIsIdentified;
      Dlt_ContextIdTableIdxType IdentifiedContextIdIdx = 0U;
      Dlt_AppIdTableIdxType AppIdStartIdx = 0U;

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      AppId_Internal = DLT_UINT32_CONVERT_TUPLE(*app_id);
      ContextId_Internal = DLT_UINT32_CONVERT_TUPLE(*context_id);
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

      DBG_DLT_REGISTERCONTEXT_ENTRY(session_id, AppId_Internal, ContextId_Internal, app_description,
          len_app_description, context_description, len_context_description);

      Dlt_EnterExclusiveAreaAnyCoreContext();
      Dlt_FindApplicationIDEntry(session_id, AppId_Internal, &LocalCoreContext, &AppIdStartIdx);
      ContextIdIsIdentified = Dlt_ContextIdIdentified(ContextId_Internal, AppIdStartIdx, session_id, LocalCoreContext, &IdentifiedContextIdIdx);
      Dlt_ExitExclusiveAreaAnyCoreContext();

      if (ContextIdIsIdentified == TRUE)
      {
        ReturnValue = DLT_E_CONTEXT_ALREADY_REG;
      }
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      /* !LINKSTO EB_Ref_SWS_ASR_4.3_RegisterContext_RetVal_appDescription,1 */
      else if (app_description == NULL_PTR)
      {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_PARAM_POINTER);
#endif
      }
      /* !LINKSTO EB_Ref_SWS_ASR_4.3_RegisterContext_RetVal_lenAppDescription,1 */
      else if (len_app_description == 0U)
      {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_WRONG_PARAMETERS);
#endif
      }
#endif
      /* Check if the maximum number of registered contexts is reached */
      else if (*LocalCoreContext.ContextIdTableIdx == DLT_MAX_COUNT_CONTEXT_IDS)
      {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        /* !LINKSTO EB_Ref_ASR43_RegisterContext_RetVal_Dlt_TooManyCtxts,1 */
        DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_ERROR_TO_MANY_CONTEXT);
#endif
      }
      else
      {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        Dlt_SessionIdTableIdxType SessionIdStartIdx = 0U;
        Dlt_ContextIdTableIdxType ContextIdStartIdx = 0U;

        /* Check if the session_id is found in the pre-configured table */
        Dlt_FindSessionIDEntry(FALSE, session_id, &LocalCoreContext, &SessionIdStartIdx);

        /* Check if the found SessionIdStartIdx is a valid one */
        if (SessionIdStartIdx != DLT_SWC_REGISTERED_NO)
        {
          /* Find the app_id/context_id tuple in the pre-configured table */
          Dlt_FindCtxAppRegisteredTuple(SessionIdStartIdx, AppId_Internal, ContextId_Internal, &ContextIdStartIdx);

          /* Check if the found ContextIdStartIdx is a valid one */
          if (ContextIdStartIdx == Dlt_MaxCtxAppIdPerSwC[SessionIdStartIdx])
          {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
            DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_UNKNOWN_SESSION_ID);
#endif
          }
          else
          {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
            /* Store the CurrentCoreId together with the given app_id/context_id tuple */
            LocalCoreContext.ContextIdTable[*LocalCoreContext.ContextIdTableIdx].OsCoreId = CurrentCoreId;
#endif /* #if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */

            Dlt_EnterExclusiveAreaAnyCoreContext();

            /* Fill the context description and context description length before calling Dlt_InternalRegisterLocalContext() */
            LocalCoreContext.ContextIdTable[*LocalCoreContext.ContextIdTableIdx].ContextDescription.CtxtDescLen = len_context_description;
            TS_MemCpy(&LocalCoreContext.ContextIdTable[*LocalCoreContext.ContextIdTableIdx].ContextDescription.CtxtDesc[0U],
                context_description, len_context_description);

            Dlt_ExitExclusiveAreaAnyCoreContext();

            /* Store the given app_id/context_id tuple into the internal master/satellite core tables */
            ReturnValue = Dlt_InternalRegisterLocalContext(session_id, AppId_Internal, ContextId_Internal, &LocalCoreContext,
                app_description, len_app_description, SessionIdStartIdx, ContextIdStartIdx);
          }
        }
        else
        {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
          DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_UNKNOWN_SESSION_ID);
#endif
        }
#else
        ReturnValue = DLT_E_OK;
#endif
      }

      if (ReturnValue == DLT_E_OK)
      {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
        if (CurrentCoreId == DLT_MASTER_CORE)
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION = STD_ON) */
        {
#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
          /* !LINKSTO Dlt.swdd.DltCore.API.MultiCoreRegisterContextCoreIdMaster,1,
                      EB_Req_Dlt_RegisterContext_ForwardREQ,1,
                      EB_Req_Dlt_RegisterContext_ForwardREQReturn,1 */
          ReturnValue = Dlt_InternalRegisterContext(session_id, AppId_Internal, ContextId_Internal, &LocalCoreContext, app_description, len_app_description, FALSE);
#endif
#if ((DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) && (DLT_REGISTER_CONTEXT_NOTIFICATION == STD_ON))
          /* !LINKSTO Dlt.ASR431.SWS_Dlt_00768,1*/
          Dlt_RegisterContextNotification(DLT_STATUS_REGISTER, session_id, AppId_Internal, ContextId_Internal);
#endif
        }
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
        else
        {
          Std_ReturnType SchmSlaveSendCtxt;
          Dlt_IOCRegisterContextMessageType Dlt_IOCRegisterContextMessage;

          /* !LINKSTO Dlt.swdd.DltCore.API.MultiCoreRegisterContextCoreIdSlave,1 */
          SatelliteContextPtr->EnterExclusiveArea();
          Dlt_IOCRegisterContextMessage.session_id = session_id;
          Dlt_IOCRegisterContextMessage.app_id = AppId_Internal;
          Dlt_IOCRegisterContextMessage.context_id = ContextId_Internal;
          SatelliteContextPtr->ExitExclusiveArea();

          Dlt_IOCRegisterContextMessage.LogLevel = *LocalCoreContext.DefaultLogLevel;
          Dlt_IOCRegisterContextMessage.TraceStatus = *LocalCoreContext.DefaultTraceStatus;
          Dlt_IOCRegisterContextMessage.VerboseMode = DLT_USE_VERBOSE_MODE;

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          Dlt_IOCRegisterContextMessage.OsCoreId = CurrentCoreId;
          Dlt_IOCRegisterContextMessage.register_or_unregister = DLT_IS_REGISTER;

          SatelliteContextPtr->EnterExclusiveArea();
          Dlt_IOCRegisterContextMessage.contextIdTableIdx = *LocalCoreContext.ContextIdTableIdx;

          /* Slave will receive information about Tuple Description and size of descriptive information as well */
          TS_MemCpy(&Dlt_IOCRegisterContextMessage.app_description[0U],app_description,len_app_description);
          TS_MemCpy(&Dlt_IOCRegisterContextMessage.context_description[0U],&context_description[0U],len_context_description);
          Dlt_IOCRegisterContextMessage.len_app_description = len_app_description;
          Dlt_IOCRegisterContextMessage.len_context_description = len_context_description;
          SatelliteContextPtr->ExitExclusiveArea();
#endif
          SchmSlaveSendCtxt = SatelliteContextPtr->SlaveSendContextMessage(&Dlt_IOCRegisterContextMessage);

          ReturnValue = (SchmSlaveSendCtxt != SCHM_E_OK) ? DLT_E_UNKNOWN_SESSION_ID : DLT_E_OK;
        }
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
      }
    }
  }

  DBG_DLT_REGISTERCONTEXT_EXIT(ReturnValue, session_id, AppId_Internal, ContextId_Internal, app_description,
    len_app_description, context_description, len_context_description);

  return ReturnValue;
}

#if (DLT_INCLUDE_RTE == STD_ON)
#define Dlt_STOP_SEC_CODE
#else
#define DLT_STOP_SEC_CODE
#endif
#include <Dlt_MemMap.h>

#define DLT_START_SEC_CODE
#include <Dlt_MemMap.h>

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
#if (DLT_REGISTER_CONTEXT_NOTIFICATION == STD_ON)
STATIC FUNC(void, DLT_CODE) Dlt_RegisterContextNotification(
    uint8 RegisterOrUnregisterContext,
    Dlt_SessionIDType sessionId,
    Dlt_Internal_ApplicationIDType appId,
    Dlt_Internal_ContextIDType contextId)
{
  uint8 Dlt_LocalPayloadToRespond[DLT_LOGINFO_SERVICEID_STATUS_SIZE + DLT_BASE_GETLOGINFO_RESPSIZE] = {0U};
  uint8 status = DLT_E_ERROR;
  uint8 TempStatus = DLT_E_ERROR;

  /* Header must always contain extended header */
  uint8 Header[DLT_MAX_STD_HEADER_LENGTH + DLT_EXT_HEADER_LENGTH_STATIC];
  uint8 NextHeaderFieldIdx = DLT_MIN_HEADER_LENGTH; /* Minimum length of the header */
  uint8 LocalHeaderLength;
  Dlt_MsgLengthType FullMessageLength;
  Dlt_MessageCommonInfoType MsgInfo;
  uint32 timestamp = 0U;
  DBG_DLT_REGISTERCONTEXTNOTIFICATION_ENTRY(RegisterOrUnregisterContext, sessionId, appId, contextId);
  MsgInfo.arg_count = 1U;
  DLT_FILL_BUFFER_32(MsgInfo.app_id, 0U, appId);
  DLT_FILL_BUFFER_32(MsgInfo.context_id, 0U, contextId);

  MsgInfo.log_level_trace_info = 0U;
  /* !LINKSTO EB.Req.DltMessageOptionsBitField, 1 */
#if (DLT_MESSAGE_OPTIONS_BITFIELD == AUTOSAR_421)
  MsgInfo.options = 0x03U; /* 0000 0011 - bits 0, 1, 2 for message_type, which is 0x03U (DLT_TYPE_CONTROL)
                            *           - bit 3 for verbose_mode, which is 0x00U (DLT_VERBOSE_MODE_OFF) */
#else /* #if (DLT_MESSAGE_OPTIONS_BITFIELD == AUTOSAR_431) */
  MsgInfo.options = 0x06U; /* 0000 0110 - bits 1, 2, 3 for message_type, which is 0x03U (DLT_TYPE_CONTROL)
                            *           - bit 0 for verbose_mode, which is 0x00U (DLT_VERBOSE_MODE_OFF) */
#endif /* #if (DLT_MESSAGE_OPTIONS_BITFIELD == AUTOSAR_421) */

  timestamp = Dlt_GetTimestamp();

  /* Call internal GetLogInfo */
  if (Dlt_GetLogInfoInternal(sessionId ,DLT_GETLOGINFO_OPTIONS_NO_DESC, appId, contextId,
      &status, (uint8 *)&Dlt_LocalPayloadToRespond[DLT_LOGINFO_SERVICEID_STATUS_SIZE]) == E_OK)
  {
    TempStatus = status;

    /* !LINKSTO Dlt.ASR431.SWS_Dlt_00774,1 */
    /* !LINKSTO Dlt.swdd.DltRegisterContextNotification_GetLogInfoStatus, 1 */
    status = RegisterOrUnregisterContext;
  }

  /* Calculate length for the response in header of a control message*/
  LocalHeaderLength = Dlt_CalculateRespHdrLength();

  if (TempStatus == DLT_CTRL_OK)
  {
    FullMessageLength =  (Dlt_MsgLengthType) LocalHeaderLength + DLT_LOGINFO_SERVICEID_STATUS_SIZE + DLT_BASE_GETLOGINFO_RESPSIZE;
  }
  else
  {
    FullMessageLength =  (Dlt_MsgLengthType) LocalHeaderLength + DLT_LOGINFO_SERVICEID_STATUS_SIZE;
  }

  Dlt_BSWMasterContextPtr->EnterExclusiveArea();
  /* WEID and UEH are always being set, all other fields are dependent on the configuration */
  Header[DLT_HTYP_HEADER_OFFSET] =                  DLT_HEADER_EXTENDED_HEADER_BIT
                                                  | DLT_HEADER_ECU_ID_BIT
                                                  | Dlt_HeaderUseSessionID
#if (DLT_IMPLEMENT_TIMESTAMP != STD_OFF)
                                                  | Dlt_HeaderUseTimestamp
#endif /* DLT_IMPLEMENT_TIMESTAMP != STD_OFF */
                                                  ;

  /* First 4 bytes are always the service Id */
  Dlt_WriteDwordToByteArrayPayload(&Dlt_LocalPayloadToRespond[DLT_RESPONSE_SERVICE_ID_IDX], DLT_GETLOGINFO_SERVICE_ID);
  /* 5th byte is the response status */
  Dlt_LocalPayloadToRespond[DLT_LOGINFO_SERVICEID_STATUS_SIZE - 1U] = status;
  /* Create the standard header fields in Dlt_LocalHeaderBuffer */
  Dlt_CreateStandardHeader(DEFAULT_LOG_CHN_IDX, sessionId, Header, &NextHeaderFieldIdx, FullMessageLength, timestamp);
  /* Create the extended header fields in header */
  Dlt_CreateExtendedHeader(&MsgInfo, Header, &NextHeaderFieldIdx);
  Dlt_BSWMasterContextPtr->ExitExclusiveArea();

  if ( (status == DLT_STATUS_REGISTER) || (status == DLT_STATUS_UNREGISTER) )
  {
    /* Send positive response */
    Dlt_SendResponse(Header, (uint8 *)&Dlt_LocalPayloadToRespond, LocalHeaderLength, (DLT_BASE_GETLOGINFO_RESPSIZE + DLT_LOGINFO_SERVICEID_STATUS_SIZE));
    Dlt_RegisterCtxtNotification = TRUE;
  }
  else
  {
    /* Send negative response */
    Dlt_SendResponse(Header, (uint8 *)&Dlt_LocalPayloadToRespond, LocalHeaderLength, DLT_LOGINFO_SERVICEID_STATUS_SIZE);
  }

  DBG_DLT_REGISTERCONTEXTNOTIFICATION_EXIT(RegisterOrUnregisterContext, sessionId, appId, contextId);
}
#endif /* #if (DLT_REGISTER_CONTEXT_NOTIFICATION == STD_ON) */

#define DLT_STOP_SEC_CODE
#include <Dlt_MemMap.h>

#if (DLT_INCLUDE_RTE == STD_ON)
#define Dlt_START_SEC_CODE
#else
#define DLT_START_SEC_CODE
#endif
#include <Dlt_MemMap.h>

/*-----------------------------[Dlt_UnregisterContext]------------------*/
/* !LINKSTO Dlt.ASR431.SWS_Dlt_00769, 1 */
FUNC(Dlt_ReturnType, DLT_CODE) Dlt_ASR43_UnregisterContext(
    Dlt_SessionIDType sessionId,
    P2CONST(Dlt_ApplicationIDType, AUTOMATIC, DLT_APPL_CONST) appId,
    P2CONST(Dlt_ContextIDType, AUTOMATIC, DLT_APPL_CONST) contextId)
{
  /* !LINKSTO EB_Req_Dlt_UnregisterContext.DltNotInitReturn,1 */
  Dlt_ReturnType ReturnValue = DLT_E_ERROR;

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  CoreIdType CurrentCoreId = GetCoreID();
  /* WARNING: SatelliteContextPtr is NULL_PTR on MASTER core */
  Dlt_BSWSatelliteContextPtrType SatelliteContextPtr = (CurrentCoreId != DLT_MASTER_CORE) ?
      Dlt_GetSatelliteContextPtr() : NULL_PTR;
  Dlt_BSWDistributionCommonType LocalCoreContext = (CurrentCoreId != DLT_MASTER_CORE) ?
      SatelliteContextPtr->CoreContext : Dlt_BSWMasterContextPtr->CoreContext;
  uint8 DltCoreInitState = (CurrentCoreId != DLT_MASTER_CORE) ?
      *LocalCoreContext.InitState : Dlt_InitStateMaster;
#else
  Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
  uint8 DltCoreInitState = Dlt_InitStateMaster;
#endif

  /* Check if the Dlt module is initialized */
  if (DltCoreInitState == DLT_UNINITIALIZED)
  {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
    /* !LINKSTO EB_Req_Dlt_UnregisterContext.DltNotInitDET,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_UnregisterContext, DLT_E_NOT_INITIALIZED);
#endif
  }
#if (DLT_DEV_ERROR_DETECT == STD_ON)
  /* Check if the appId and contextId parameters are NULL_PTR */
  else if ( (appId == NULL_PTR) || (contextId == NULL_PTR) )
  {
    DLT_DET_REPORT_ERROR(DLT_SID_UnregisterContext, DLT_E_PARAM_POINTER);
  }
  else
#endif /* #if (DLT_DEV_ERROR_DETECT == STD_ON) */
  {
    Dlt_SessionIdTableIdxType SessionIdStartIdx = 0U;
    Dlt_ContextIdTableIdxType ContextIdStartIdx = 0U;

    Dlt_Internal_ContextIDType ContextId_Internal;
    Dlt_Internal_ApplicationIDType AppId_Internal;

    /* Search for the given sessionId in the pre-configured table */
    Dlt_FindSessionIDEntry(FALSE, sessionId, &LocalCoreContext, &SessionIdStartIdx);

    /* Convert the appId/contextId uint8 arrays to uint32 */
    AppId_Internal = DLT_UINT32_CONVERT_TUPLE(*appId);
    ContextId_Internal = DLT_UINT32_CONVERT_TUPLE(*contextId);

    /* Debug entry point */
    DBG_DLT_UNREGISTERCONTEXT_ENTRY(sessionId, AppId_Internal, ContextId_Internal);

    /* If sessionId was found in the pre-configured table, search for the given tuple */
    if (SessionIdStartIdx != DLT_SWC_REGISTERED_NO)
    {
      /* Search for the given appId/contextId tuple in the pre-configured table */
      Dlt_FindCtxAppRegisteredTuple(SessionIdStartIdx, AppId_Internal, ContextId_Internal, &ContextIdStartIdx);
    }

    /* If true, sessionId was not found in the pre-configured table */
    if (SessionIdStartIdx == DLT_SWC_REGISTERED_NO)
    {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
      /* !LINKSTO  EB_Req_Dlt_UnregisterContext.InvalidSesIdDET,1 */
      DLT_DET_REPORT_ERROR(DLT_SID_UnregisterContext, DLT_E_CONTEXT_NOT_YET_REG);
#endif
      /* !LINKSTO  EB_Req_Dlt_UnregisterContext.InvalidSesIdReturn,1 */
      ReturnValue = DLT_E_CONTEXT_NOT_YET_REG;
    }
    /* If true, the given tuple was not found in the pre-configured table */
    else if (ContextIdStartIdx == Dlt_MaxCtxAppIdPerSwC[SessionIdStartIdx])
    {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
      /* !LINKSTO  EB_Req_Dlt_UnregisterContext.InvalidCtxIdDET,1 */
      DLT_DET_REPORT_ERROR(DLT_SID_UnregisterContext, DLT_E_UNKNOWN_SESSION_ID);
#endif
      ReturnValue = DLT_E_UNKNOWN_SESSION_ID;
    }
    else
    {
      /* Valid sessionId, appId and contextId were found in the pre-configured table */
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
      /* !LINKSTO Dlt.swdd.DltCore.API.MultiCoreRegisterContextGetCoreId,1 */
      if (CurrentCoreId == DLT_MASTER_CORE)
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION = STD_ON) */
      {
        /* Send the unregister notification from the master core only */
#if (DLT_REGISTER_CONTEXT_NOTIFICATION == STD_ON)
        /* !LINKSTO Dlt.ASR431.SWS_Dlt_00774,1 */
        Dlt_RegisterContextNotification(DLT_STATUS_UNREGISTER, sessionId, AppId_Internal, ContextId_Internal);
#endif
      }

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF)
      /* Check and store the given tuple in the master/satellite tables */
      ReturnValue = Dlt_InternalUnregisterContext(DLT_MASTER_CORE, sessionId, AppId_Internal, ContextId_Internal, &LocalCoreContext);
#else
      /* Check and store the given tuple in the master/satellite tables */
      ReturnValue = Dlt_InternalUnregisterContext(CurrentCoreId, sessionId, AppId_Internal, ContextId_Internal, &LocalCoreContext);

      /* If on satellite core, send the given parameters to the master core */
      if (CurrentCoreId != DLT_MASTER_CORE)
      {
        Std_ReturnType SchmSlaveSendCtxt;
        Dlt_IOCRegisterContextMessageType Dlt_IOCRegisterContextMessage;

        Dlt_IOCRegisterContextMessage.register_or_unregister = DLT_IS_UNREGISTER;
        Dlt_IOCRegisterContextMessage.OsCoreId = CurrentCoreId;

        SatelliteContextPtr->EnterExclusiveArea();
        Dlt_IOCRegisterContextMessage.session_id = sessionId;
        Dlt_IOCRegisterContextMessage.app_id = AppId_Internal;
        Dlt_IOCRegisterContextMessage.context_id = ContextId_Internal;
        Dlt_IOCRegisterContextMessage.contextIdTableIdx = *LocalCoreContext.ContextIdTableIdx;
        SatelliteContextPtr->ExitExclusiveArea();

        SchmSlaveSendCtxt = SatelliteContextPtr->SlaveSendContextMessage(&Dlt_IOCRegisterContextMessage);

        ReturnValue = (SchmSlaveSendCtxt != SCHM_E_OK) ? DLT_E_UNKNOWN_SESSION_ID : DLT_E_OK;
      }
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION = STD_ON) */
    }
  }

  /* Debug exit point */
  DBG_DLT_UNREGISTERCONTEXT_EXIT(ReturnValue, sessionId, AppId_Internal, ContextId_Internal);

  return ReturnValue;
}

#if (DLT_INCLUDE_RTE == STD_ON)
#define Dlt_STOP_SEC_CODE
#else
#define DLT_STOP_SEC_CODE
#endif
#include <Dlt_MemMap.h>

#define DLT_START_SEC_CODE
#include <Dlt_MemMap.h>

/*-----------------------------[Dlt_InternalUnregisterContext]------------------*/
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_InternalUnregisterContext(
    CoreIdType CurrentCoreId,
    Dlt_SessionIDType SessionId,
    Dlt_Internal_ApplicationIDType AppId,
    Dlt_Internal_ContextIDType ContextId,
    P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) LocalCoreContext)
{
  Dlt_ReturnType ReturnValue = DLT_E_ERROR;

  Dlt_AppIdTableIdxType          AppIdStartIdx       = 0U;
  Dlt_ContextIdTableIdxType      ContextIdStartIdx   = 0U;
  Dlt_SessionIdTableIdxType      SessionIdStartIdx   = 0U;
  Dlt_AppToContextIdTableIdxType AppIdToContextIdIdx = 0U;

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF)
  TS_PARAM_UNUSED(CurrentCoreId);
#endif /* #if (DLT_ENABLE_BSW_DISTRIBUTION == STD_OFF) */

  /* Search for the given SessionId in the run-time table */
  Dlt_FindSessionIDEntry(TRUE, SessionId, LocalCoreContext, &SessionIdStartIdx);

  /* Search for the given AppId in the run-time table */
  Dlt_FindApplicationIDEntry(SessionId, AppId, LocalCoreContext, &AppIdStartIdx);

  /* If true, no tuples with the given SessionId were registered at run-time */
  if (SessionIdStartIdx == DLT_SWC_REGISTERED_NO)
  {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
    /* !LINKSTO  EB_Req_Dlt_UnregisterContext.InvalidAppIdReturn,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_UnregisterContext, DLT_E_CONTEXT_NOT_YET_REG);
#endif
    /* !LINKSTO  EB_Req_Dlt_UnregisterContext.InvalidAppIdDET,1 */
    ReturnValue = DLT_E_CONTEXT_NOT_YET_REG;
  }
  /* If true, the given AppId has not registered any tuples at run-time */
  else if (AppIdStartIdx == *LocalCoreContext->MaxRegisteredAppldTableEntry)
  {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
    DLT_DET_REPORT_ERROR(DLT_SID_UnregisterContext, DLT_E_UNKNOWN_SESSION_ID);
#endif
    ReturnValue = DLT_E_UNKNOWN_SESSION_ID;
  }
  /* If true, the given AppId/ContextId tuple has not been registered at run-time */
  else if (Dlt_CheckForRegisteredContext(ContextId, AppIdStartIdx, &ContextIdStartIdx, &AppIdToContextIdIdx) == FALSE)
  {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
    DLT_DET_REPORT_ERROR(DLT_SID_UnregisterContext, DLT_E_UNKNOWN_SESSION_ID);
#endif
    ReturnValue = DLT_E_UNKNOWN_SESSION_ID;
  }
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  else if ( (CurrentCoreId == DLT_MASTER_CORE) &&
      (LocalCoreContext->ContextIdTable[ContextIdStartIdx].OsCoreId != DLT_MASTER_CORE) )
  {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
    /* !LINKSTO EB_Req_Dlt_UnregisterContext.InvalidCtxIdDET, 1 */
    DLT_DET_REPORT_ERROR(DLT_SID_UnregisterContext, DLT_E_CONTEXT_NOT_YET_REG);
#endif
    /* !LINKSTO EB_Req_Dlt_UnregisterContext.InvalidCtxtIdReturn,1 */
    ReturnValue = DLT_E_CONTEXT_NOT_YET_REG;
  }
#endif /* #if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
  else
  {
    /* Valid sessionId, appId and contextId were found in the run-time tables */

    Dlt_AppIdTableIdxType AppIdIdx;
    Dlt_ContextIdTableIdxType ContextIdIdx1;
    Dlt_ContextIdTableIdxType ContextIdIdx2 = 0U;
    Dlt_ContextIdTableIdxType ContextIdIdx3;

    /* Enter exclusive area on master/satellite core */
    Dlt_EnterExclusiveAreaAnyCoreContext();

    /* A tuple is tied to a session ID and all validations are done prior, which makes
     * the coverage of this branch impossible under current implementation */
    /* If given AppId was registered once, the values from Dlt_AppIdTable shall be shifted */
    if (LocalCoreContext->AppToContextIdTableIdx[AppIdStartIdx] == 1U)
    {
      LocalCoreContext->AppToContextIdTableIdx[AppIdStartIdx] = 0U;

      Dlt_InternalUnregisterContextShiftAppIds(AppIdStartIdx, LocalCoreContext);

      /* Decrement number of registered applications, since the requested tuple had an appId
       * with only one contextId: appId should be removed from the table */
      (*LocalCoreContext->MaxRegisteredAppldTableEntry)--;
    }
    else
    {
      /* Number of contextIds per appId should be decremented by one contextId.
       * Dlt_MaxRegisteredAppldTableEntry remains the same since the requested
       * appId had at least two contextIds assigned */
      LocalCoreContext->AppToContextIdTableIdx[AppIdStartIdx] = LocalCoreContext->AppToContextIdTableIdx[AppIdStartIdx] - 1U;
    }

    for (ContextIdIdx1 = 0; ContextIdIdx1 < DLT_MAX_COUNT_CONTEXT_IDS_PER_APP_ID; ContextIdIdx1++)
    {
      if (LocalCoreContext->ContextIdTable[LocalCoreContext->AppToContextIdTable[AppIdStartIdx].ContextIdTableIdx[ContextIdIdx1]].ContextId == ContextId)
      {
        /* When the contextId is matching, ContextIdTableIdx of Dlt_AppToContextTable
         * shall be reset, so no contextId appears to be registered for the application in the table */
        ContextIdIdx2 = LocalCoreContext->AppToContextIdTable[AppIdStartIdx].ContextIdTableIdx[ContextIdIdx1];

        LocalCoreContext->AppToContextIdTable[AppIdStartIdx].ContextIdTableIdx[ContextIdIdx1] = 0U;

        break;
      }
    }

    /* After resetting the contextId in the table, all the indices
     * for Dlt_AppToContextIdTable shall be shifted with one position */
    for (ContextIdIdx1 = 0U; ContextIdIdx1 < DLT_MAX_COUNT_CONTEXT_IDS_PER_APP_ID; ContextIdIdx1++)
    {
      /* Deviation TASKING-5 */
      if (ContextIdIdx1 == (DLT_MAX_COUNT_CONTEXT_IDS_PER_APP_ID - 1U))
      {
        /* The last one shall be reset */
        LocalCoreContext->AppToContextIdTable[AppIdStartIdx].ContextIdTableIdx[ContextIdIdx1] = 0U;
      }
      else
      {
        LocalCoreContext->AppToContextIdTable[AppIdStartIdx].ContextIdTableIdx[ContextIdIdx1] =
            LocalCoreContext->AppToContextIdTable[AppIdStartIdx].ContextIdTableIdx[ContextIdIdx1 + 1U];
      }
    }

    for (AppIdIdx = AppIdStartIdx; AppIdIdx < *LocalCoreContext->MaxRegisteredAppldTableEntry; AppIdIdx++)
    {
      for (ContextIdIdx1 = 0U; ContextIdIdx1 < DLT_MAX_COUNT_CONTEXT_IDS_PER_APP_ID; ContextIdIdx1++)
      {
        if ((LocalCoreContext->AppToContextIdTable[AppIdIdx].ContextIdTableIdx[ContextIdIdx1] != 0U) &&
            (LocalCoreContext->AppToContextIdTable[AppIdIdx].ContextIdTableIdx[ContextIdIdx1] > ContextIdIdx2))
        {
          /* The position for each contextId shall be decremented by 0U */
          LocalCoreContext->AppToContextIdTable[AppIdIdx].ContextIdTableIdx[ContextIdIdx1] =
              LocalCoreContext->AppToContextIdTable[AppIdIdx].ContextIdTableIdx[ContextIdIdx1] - 1U;
        }
      }
    }

    for (ContextIdIdx3 = ContextIdStartIdx; ContextIdIdx3 < (*LocalCoreContext->ContextIdTableIdx); ContextIdIdx3++)
    {
      if (ContextIdIdx3 == (*LocalCoreContext->ContextIdTableIdx - 1U))
      {
        /* !LINKSTO Dlt.ASR431.SWS_Dlt_00773,1 */
        TS_MemBZero(&LocalCoreContext->ContextIdTable[ContextIdIdx3], sizeof(LocalCoreContext->ContextIdTable[ContextIdIdx3]));
      }
      else
      {
        /* !LINKSTO Dlt.ASR431.SWS_Dlt_00773,1 */
        TS_MemCpy(&LocalCoreContext->ContextIdTable[ContextIdIdx3],
            &LocalCoreContext->ContextIdTable[ContextIdIdx3 + 1U], sizeof(LocalCoreContext->ContextIdTable[ContextIdIdx3]));
      }
    }

    /* !LINKSTO Dlt.ASR431.SWS_Dlt_00773,1 */
    (*LocalCoreContext->ContextIdTableIdx)--;

    Dlt_InternalUnregisterContextClearSessionIdTable(SessionIdStartIdx, LocalCoreContext);

    /* Exit exclusive area on master/satellite core */
    Dlt_ExitExclusiveAreaAnyCoreContext();

    ReturnValue = DLT_E_OK;
  }
  return ReturnValue;
}
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

/*-----------------------------[Dlt_EnterExclusiveAreaMaster]------------------*/
FUNC(void, DLT_CODE) Dlt_EnterExclusiveAreaMaster(void)
{
  SchM_Enter_Dlt_SCHM_DLT_EXCLUSIVE_AREA_MASTER();
}

/*-----------------------------[Dlt_ExitExclusiveAreaMaster]------------------*/
FUNC(void, DLT_CODE) Dlt_ExitExclusiveAreaMaster(void)
{
  SchM_Exit_Dlt_SCHM_DLT_EXCLUSIVE_AREA_MASTER();
}

/*------------------[Dlt_EnterExclusiveAreaAnyCoreContext]--------------------*/
FUNC(void, DLT_CODE) Dlt_EnterExclusiveAreaAnyCoreContext(void)
{
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  CoreIdType CurrentCoreId = GetCoreID();
  Dlt_BSWSatelliteContextPtrType SatelliteContextPtr = (CurrentCoreId != DLT_MASTER_CORE) ?
        Dlt_GetSatelliteContextPtr() : NULL_PTR;
#endif

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  if (CurrentCoreId == DLT_MASTER_CORE)
  {
#endif
    Dlt_BSWMasterContextPtr->EnterExclusiveArea();
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  }
  else
  {
    SatelliteContextPtr->EnterExclusiveArea();
  }
#endif
}

/*------------------[Dlt_ExitExclusiveAreaAnyCoreContext]--------------------*/
FUNC(void, DLT_CODE) Dlt_ExitExclusiveAreaAnyCoreContext(void)
{
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  CoreIdType CurrentCoreId = GetCoreID();
  Dlt_BSWSatelliteContextPtrType SatelliteContextPtr = (CurrentCoreId != DLT_MASTER_CORE) ?
        Dlt_GetSatelliteContextPtr() : NULL_PTR;
#endif

#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  if (CurrentCoreId == DLT_MASTER_CORE)
  {
#endif
    Dlt_BSWMasterContextPtr->ExitExclusiveArea();
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  }
  else
  {
    SatelliteContextPtr->ExitExclusiveArea();
  }
#endif
}

/*-----------------------------[Dlt_ComTxConfirmation]------------------*/
/* !LINKSTO Dlt.swdd.Communication.Interface,1,
            Dlt.DltCore.Dlt_ComTxConfirmation.Confirm,1,
            Dlt.ASR431.Ref_SWS_Dlt_00697_PositiveTxConfirmation,1,
            Dlt.ASR431.Ref_SWS_Dlt_00697_NegativeTxConfirmation,1
*/
FUNC(void, DLT_CODE) Dlt_ComTxConfirmation(
    PduIdType DltTxPduId,
    NotifResultType Result)
{

  Dlt_ChnIdTableIdxType chnIdx = 0U;
  DBG_DLT_COMTXCONFIRMATION_ENTRY(DltTxPduId, Result);

#if (DLT_DEV_ERROR_DETECT == STD_OFF)
  TS_PARAM_UNUSED(Result);
  TS_PARAM_UNUSED(DltTxPduId);
#endif
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_FindChannelIdx(&chnIdx,DltTxPduId);
#endif

#if (DLT_DEV_ERROR_DETECT == STD_ON)
  if (Dlt_InitStateMaster == DLT_UNINITIALIZED)
  {
    /* !LINKSTO EB_Req_Dlt_ComTxConfirmation.DltNotInitDET, 1 */
    DLT_DET_REPORT_ERROR(DLT_SID_ComTxConfirmation, DLT_E_NOT_INITIALIZED);
  }

  /* something strange happened if these do not match */
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  else if (chnIdx >= DLT_TXPDU_NO)
#else
  else if (DltTxPduId != DLT_TX_PDU_ID)
#endif
  {
    /* !LINKSTO EB_Req_Dlt_ComTxConfirmation.TxPduId.DET,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_ComTxConfirmation, DLT_E_WRONG_PARAMETERS);
  }
  else
#endif
  {
    /* !LINKSTO EB_Req_Dlt_ComTxConfirmation.TxConfirmationStatus,1 */
    if (Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmissionOngoing == TRUE)
    {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
      if (Result != E_OK)
      {
        /* !LINKSTO EB_Req_Dlt_ComTxConfirmation.TxConfirmationFailure,1 */
        DLT_DET_REPORT_ERROR(DLT_SID_ComTxConfirmation, DLT_E_ERROR_IN_PROV_SERVICE);
      }
#endif
      Dlt_BSWMasterContextPtr->EnterExclusiveArea();
      /* reset the position for the next transmission */
      Dlt_TxConnection[chnIdx].PositionInMessage = 0U;
      Dlt_TxConnection[chnIdx].ConfirmedPositionInMessage = 0U;

      /* Are there further messages in the ring buffer? If yes,
       * transmit them, too.
       * Attention!
       * The order of first switching to the next message and
       * then unlocking the previous message is important! This
       * protects the buffer from concurrent Dlt_InternalSendMessage
       * calls without the need of an exclusive area.
       */

      /* CHECK: NOPARSE */
      /* !LINKSTO EB_Req_Dlt_ComTxConfirmation.MsgInBuffer.NextMessage,1 */
      if (Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer == TRUE)
      /* CHECK: PARSE */
      {
#if(DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx = DLT_BUFFER_IDX(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx,
                                                                       Dlt_LastMessageLen[chnIdx],
                                                                       DLT_MESSAGE_BUFFER_SIZE);

#else
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx = DLT_BUFFER_IDX(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx,
                                                                       Dlt_LastMessageLen[chnIdx],
                                                                       Dlt_CfgLogChannel[chnIdx].DltLogChannelBufferSize);
#endif
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx = Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx;
        Dlt_LastMessageLen[chnIdx] = 0U;

        if (Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx == Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy)
        {
          /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00651_RemoveMessageFromLogChannelBuffer, 1 */
          Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer = FALSE;
        }
      }
      /* CHECK: NOPARSE */
      else
      {
        /* This branch is not reachable due to requiring a concurrent execution of the function,
         * as Dlt_ComTxConfirmation() continues its execution if Dlt_TransmissionOngoing is true.
         * This flag is true only in Dlt_TriggerTransmit() if a message is in the internal buffer.
         * This dependency makes this branch unreachable in a test environment where concurrent
         * execution is not possible. Also, both of these flags are static variables, which are
         * visible only in this translation unit. */
        DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_SID_ComTxConfirmation);
      }
      /* CHECK: PARSE */
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
#if (DLT_REGISTER_CONTEXT_NOTIFICATION == STD_ON)
      if(Dlt_RegisterCtxtNotification == TRUE)
      {
        /* Reset indexes in case of a notification, when a complete transmission is done */
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy = 0U;
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdx = 0U;
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx = 0U;
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx = 0U;
        Dlt_RegisterCtxtNotification = FALSE;
      }
#endif
#endif
      /* !LINKSTO EB_Req_Dlt_ComTxConfirmation.MsgInBuffer.TransmissionOngoing.False,1 */
      Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmissionOngoing = FALSE;

      Dlt_BSWMasterContextPtr->ExitExclusiveArea();
    }
  }

  DBG_DLT_COMTXCONFIRMATION_EXIT(DltTxPduId, Result);
}

/*-----------------------------[Dlt_ComCopyTxData]------------------*/
/* !LINKSTO SWS_Dlt_00516,1, Dlt.swdd.Communication.Interface,1 */
FUNC(BufReq_ReturnType, DLT_CODE) Dlt_ComCopyTxData(
    PduIdType                                      id,
    P2VAR(PduInfoType, AUTOMATIC, DLT_APPL_DATA)   info,
    P2VAR(RetryInfoType, AUTOMATIC, DLT_APPL_DATA) retry,
    P2VAR(PduLengthType, AUTOMATIC, DLT_APPL_DATA) availableDataPtr)
{
  /* !LINKSTO EB_Req_Dlt_ComCopyTxData.PreconditionsNOK,1,
              EB_Req_Dlt_ComCopyTxData.TransmissionNOK.Return,1,
              EB_Req_Dlt_ComCopyTxData.InvalidPduId.Return,1,
              Dlt.swdd.DltCore.API.ComCopyTxData.Retry.Error,1 */
  BufReq_ReturnType CopyDataStatus = BUFREQ_E_NOT_OK;
  Std_ReturnType ProcessRetryInformation =  E_NOT_OK;
  Dlt_ChnIdTableIdxType chnIdx = 0U;
  DBG_DLT_COMCOPYTXDATA_ENTRY(id, info, retry, availableDataPtr);
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_FindChannelIdx((Dlt_ChnIdTableIdxType* )&chnIdx,id);
#else
  TS_PARAM_UNUSED(id);
#endif
#if (DLT_DEV_ERROR_DETECT == STD_ON)
  if (Dlt_InitStateMaster == DLT_UNINITIALIZED)
  {
    DLT_DET_REPORT_ERROR(DLT_SID_ComCopyTxData, DLT_E_NOT_INITIALIZED);
  }
  else if ((info == NULL_PTR) || (availableDataPtr == NULL_PTR))
  {
    DLT_DET_REPORT_ERROR(DLT_SID_ComCopyTxData, DLT_E_PARAM_POINTER);
  }
  else if ((0U != info->SduLength) && (NULL_PTR == info->SduDataPtr))
  {
    DLT_DET_REPORT_ERROR(DLT_SID_ComCopyTxData, DLT_E_PARAM_POINTER);
  }
  else if ((retry != NULL_PTR) &&
           (retry->TpDataState != TP_DATARETRY) &&
           (retry->TpDataState != TP_CONFPENDING) &&
           (retry->TpDataState != TP_DATACONF))
  {
    DLT_DET_REPORT_ERROR(DLT_SID_ComCopyTxData, DLT_E_WRONG_PARAMETERS);
  }
  /* Something strange happened if these do not match */
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  else if (chnIdx >= DLT_TXPDU_NO)
#else
  else if (id != DLT_TX_PDU_ID)
#endif
  {
    /* inform user if input parameter pduId is invalid */
    /* !LINKSTO EB_Req_Dlt_ComCopyTxData.InvalidPduId.DET,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_ComCopyTxData, DLT_E_WRONG_PARAMETERS);
  }
  else if (FALSE == Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmissionOngoing)
  {
    /* Sequence error */
    /* !LINKSTO EB_Req_Dlt_ComCopyTxData.TransmissionNOK,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_ComCopyTxData, DLT_E_COM_FAILURE);
  }
  else
#endif /* (DLT_DEV_ERROR_DETECT == STD_ON) */
  {
    if (retry != NULL_PTR)
    {
      if (retry->TpDataState == TP_DATARETRY)
      {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        if ( retry->TxTpDataCnt >
            (Dlt_TxConnection[chnIdx].PositionInMessage - Dlt_TxConnection[chnIdx].ConfirmedPositionInMessage))
        {
          DLT_DET_REPORT_ERROR(DLT_SID_ComCopyTxData, DLT_E_WRONG_PARAMETERS);
        }
        else
#endif
        {
          Dlt_BSWMasterContextPtr->EnterExclusiveArea();
          /* !LINKSTO EB_Req_Dlt_ComCopyTxData_DataRetry,1 */
          Dlt_TxConnection[chnIdx].PositionInMessage -= retry->TxTpDataCnt;
          /* all data before this index is consider to be confirmed since retry is an implicit
             confirmation for all data before the TxTpDataCnt */
          Dlt_TxConnection[chnIdx].ConfirmedPositionInMessage = Dlt_TxConnection[chnIdx].PositionInMessage;
          ProcessRetryInformation = E_OK;
          Dlt_BSWMasterContextPtr->ExitExclusiveArea();
        }
      }
      /* The lower layer requests not to confirm any already copied data yet */
      else if (retry->TpDataState == TP_CONFPENDING)
      {
        /* !LINKSTO Dlt.swdd.DltCore.API.ComCopyTxData.Retry.TP_CONFPENDING,1 */
        /* don't confirm previous copied data this way they are available for error recovery */
        ProcessRetryInformation =  E_OK;
      }
      /* at this point there is no possible value for retry->TpDataState than TP_DATACONF */
      else
      {
        /* !LINKSTO Dlt.swdd.DltCore.API.ComCopyTxData.Retry.TP_DATACONF,1,
                    EB_Req_Dlt_ComCopyTxData.DataDiscard,1 */
        Dlt_BSWMasterContextPtr->EnterExclusiveArea();
        /* TP_DATACONF: all data before this call is confirmed */
        Dlt_TxConnection[chnIdx].ConfirmedPositionInMessage = Dlt_TxConnection[chnIdx].PositionInMessage;
        ProcessRetryInformation = E_OK;
        Dlt_BSWMasterContextPtr->ExitExclusiveArea();
      }
    }
    else
    {
      /* !LINKSTO Dlt.swdd.DltCore.API.ComCopyTxData.Retry.NULL_PTR,1 */
      Dlt_BSWMasterContextPtr->EnterExclusiveArea();
      /* no retry requested. All data before this location is considered as confirmed */
      Dlt_TxConnection[chnIdx].ConfirmedPositionInMessage = Dlt_TxConnection[chnIdx].PositionInMessage;
      ProcessRetryInformation = E_OK;
      Dlt_BSWMasterContextPtr->ExitExclusiveArea();
    }
    /* Deviation TASKING-6 */
    if (E_OK == ProcessRetryInformation)
    {
      if (info->SduLength != 0U)
      {
        /* !LINKSTO EB_Req_Dlt_ComCopyTxData.BufferNotFree,1 */
        if(info->SduLength <= Dlt_LastMessageLen[chnIdx])
        {
          Std_ReturnType readFromBuffer;

          Dlt_BSWMasterContextPtr->EnterExclusiveArea();

          /* The SduLength variable could be an uint32, but this should cause no problem since the
             maximum message size is less or equal than DLT_MAX_MESSAGE_LENGTH */
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          DLT_PRECONDITION_ASSERT(DLT_INSTANCE_ID, (info->SduLength <= Dlt_CfgLogChannel[chnIdx].DltLogChannelMaxMessageLength), DLT_INTERNAL_API_ID);
#else
          DLT_PRECONDITION_ASSERT(DLT_INSTANCE_ID, (info->SduLength <= DLT_MAX_MESSAGE_LENGTH), DLT_INTERNAL_API_ID);
#endif
          /* !LINKSTO EB_Req_Dlt_ComCopyTxData_CopyData,1 */
          readFromBuffer = Dlt_ReadFromBuffer(chnIdx, info->SduDataPtr,
              info->SduLength, Dlt_TxConnection[chnIdx].PositionInMessage);

          Dlt_BSWMasterContextPtr->ExitExclusiveArea();

          switch(readFromBuffer)
          {
            case DLT_BUF_FULL:
            {
              Dlt_BSWMasterContextPtr->EnterExclusiveArea();
              Dlt_TxConnection[chnIdx].PositionInMessage += info->SduLength;
              Dlt_BSWMasterContextPtr->ExitExclusiveArea();
              CopyDataStatus = BUFREQ_OK;
              break;
            }
            case DLT_BUF_INVALID:
            {
              CopyDataStatus = BUFREQ_E_BUSY;
              break;
            }
            default:
            {
              CopyDataStatus = BUFREQ_E_NOT_OK;
              break;
            }
          }
        }
        else
        {
          CopyDataStatus = BUFREQ_E_BUSY;
        }
      }
      else
      {
        /* In case the user wants to indicate state changes in the retry parameter or to query the current amount of
           available data in the upper layer module */
        CopyDataStatus = BUFREQ_OK;
      }

      /* update the available data to consider the current value of Dlt_TxConnection.PositionInMessage */
      /* !LINKSTO EB_Req_Dlt_ComCopyTxData.RemainingData,1 */
      *availableDataPtr = Dlt_LastMessageLen[chnIdx] - Dlt_TxConnection[chnIdx].PositionInMessage;
    }
    else
    {
      /* the retry information was not processed correctly. exit with BUFREQ_E_NOT_OK */
    }
  }

  DBG_DLT_COMCOPYTXDATA_EXIT(retVal, id, info, retry, availableDataPtr);
  return CopyDataStatus;
}

/*-----------------------------[Dlt_MainFunction]--------------------*/
/* !LINKSTO Dlt.TrafficShaping.DltInterfaces,1 */
FUNC(void, DLT_CODE) Dlt_MainFunction(void)
{
  boolean isOkToTransmit = FALSE;

  Dlt_ChnIdTableIdxType chnIdx = 0U;
  PduInfoType PduInfo[DLT_TXPDU_NO];

  DBG_DLT_MAINFUNCTION_ENTRY();

  /* !LINKSTO SWS_Dlt_00004, 1, Dlt.swdd.DltCore.API.MainFunction.DltUninit,1 */
  /* No message is transmitted by DLT until the DLT module is initialized */
  if (Dlt_InitStateMaster != DLT_UNINITIALIZED)
  {
#if (DLT_STARTUP_DELAY_TIMER > 0U)
    /* !LINKSTO Dlt.ASR431.SWS_Dlt_00005,1,
       Dlt.swdd.Dlt_MainFunction.MessageProcessing.Delay,1 */
    if (Dlt_StartupTransmissionDelay == 0U)
#endif
    {
#if (DLT_TRAFFIC_SHAPER_ENABLED == STD_ON)
      boolean Dlt_WaitMoreStates;
      Dlt_MsgLengthType len = 0U;
#endif
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      for (chnIdx = 0U; chnIdx < DLT_TXPDU_NO; chnIdx++)
      {
#endif
#if (DLT_RECEPTION_CONTROL_MESSAGES_ENABLED == STD_ON)
        {
          Dlt_UnpackRxData();
        }
#endif /* (DLT_RECEPTION_CONTROL_MESSAGES_ENABLED == STD_ON) */
        /* Do not allow a new transmission to start if there is no message in buffer
        or another transmission is ongoing
        or a store was intrerupted by the mainfunction */
        /* !LINKSTO Dlt.swdd.DltCore.API.MainFunction.ConditionsForMsgTransmissionMet,1 */
        Dlt_BSWMasterContextPtr->EnterExclusiveArea();
        if((Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer == TRUE) &&
          (Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmissionOngoing == FALSE) &&
          (Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy == Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdx))
        {
#if (DLT_TRAFFIC_SHAPER_ENABLED == STD_ON)
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          len = Dlt_GetCurMessageLength(chnIdx, Dlt_CfgLogChannel[chnIdx].DltLogChannelBufferSize);
#else  /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
          len = Dlt_GetCurMessageLength(chnIdx, DLT_MESSAGE_BUFFER_SIZE);
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
#endif /* #if (DLT_TRAFFIC_SHAPER_ENABLED == STD_ON) */
          isOkToTransmit = TRUE;
        }
        Dlt_BSWMasterContextPtr->ExitExclusiveArea();

/* !LINKSTO Dlt.TrafficShaper.License,1, Dlt.ASR431.Ref_SWS_Dlt_00651_MessageTrafficShapingSettings,1 */
#if (DLT_TRAFFIC_SHAPER_ENABLED == STD_ON)
        /* ENTER critical section */
        Dlt_BSWMasterContextPtr->EnterExclusiveArea();
        /* !LINKSTO Dlt.swdd.Dlt_MainFunction.IntegrationWindow,1,
                    Dlt.swdd.MainFunction.BandwidthWithinLimits,1 */
        if (Dlt_InternalVarsTxRx[chnIdx].Dlt_IntegrationWindow == DLT_INTEGRATION_WINDOW)
        {
          /* critical section
            Dlt_BandwidthForComModule is hidden within DLT_MAXIMUM_NUMBER_OF_BYTES and
            DLT_BYTES_PER_MAINFUNCTION thus we must protect them from an interfering
            call to Dlt_SetComInterfaceMaxBandwidth() */
          /* !LINKSTO Dlt.swdd.DltCore.API.MainFunction.DataFitsInIntegrationWindow,1 */
          if ( (Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmittedData + len) > (Dlt_MsgLengthType)DLT_MAXIMUM_NUMBER_OF_BYTES)
          {
            /* How long must we wait to compensate the excess data? */
            /* !LINKSTO SWS_Dlt_00344,1,
                        Dlt.swdd.DltCore.API.MainFunction.ExcessData.IntegrationWindow,1,
                        Dlt.swdd.DltCore.API.MainFunction.ExcessData.WaitStates,1 */
            Dlt_InternalVarsTxRx[chnIdx].Dlt_WaitStates =
              ( (Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmittedData + len) - (Dlt_MsgLengthType)DLT_MAXIMUM_NUMBER_OF_BYTES) /
              (Dlt_MsgLengthType)DLT_BYTES_PER_MAINFUNCTION;
          }

          if(0U != Dlt_InternalVarsTxRx[chnIdx].Dlt_WaitStates)
          {
            Dlt_InternalVarsTxRx[chnIdx].Dlt_IntegrationWindow = 1U;
          }
          else
          {
            /* If no wait time is imposed set Dlt_IntegrationWindow to 0U
            * as it will be incremented in the same MF call */
            Dlt_InternalVarsTxRx[chnIdx].Dlt_IntegrationWindow = 0U;
          }
          /* !LINKSTO Dlt.swdd.DltCore.API.MainFunction.TrafficCounter,1 */
          Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmittedData = 0U;
        }

        if(Dlt_InternalVarsTxRx[chnIdx].Dlt_WaitStates == 0U)
        {
          Dlt_WaitMoreStates = FALSE;
        }
        else
        {
          Dlt_WaitMoreStates = TRUE;
        }

        /* LEAVE critical section */
        Dlt_BSWMasterContextPtr->ExitExclusiveArea();

        if (Dlt_WaitMoreStates == FALSE)
        {
          if (isOkToTransmit == TRUE)
          {
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
            /* !LINKSTO Dlt.swdd.DltCore.API.MainFunction.TriggerTransmit,1 */
            (void)Dlt_TriggerTransmit(Dlt_CfgLogChannel[chnIdx].DltITxPduHandleId, &PduInfo[chnIdx]);
            isOkToTransmit = FALSE;
#else
            Dlt_TriggerTransmit(DLT_TX_PDU_ID, &PduInfo[chnIdx]);
#endif
            Dlt_BSWMasterContextPtr->EnterExclusiveArea();
            Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmittedData += len;
            Dlt_BSWMasterContextPtr->ExitExclusiveArea();
          }
          /* !LINKSTO Dlt.swdd.DltCore.API.MainFunction.ConditionsForMsgTransmissionNotMet.NoMsgInBuffer,1,
                      Dlt.swdd.DltCore.API.MainFunction.ConditionsForMsgTransmissionNotMet.TransmissionLocked,1 */
          Dlt_BSWMasterContextPtr->EnterExclusiveArea();
          Dlt_InternalVarsTxRx[chnIdx].Dlt_IntegrationWindow++;
          Dlt_BSWMasterContextPtr->ExitExclusiveArea();
        }
        else
        {
          /* !LINKSTO Dlt.swdd.DltCore.API.MainFunction.DecreaseWaitStates,1 */
          Dlt_BSWMasterContextPtr->EnterExclusiveArea();
          Dlt_InternalVarsTxRx[chnIdx].Dlt_WaitStates--;
          Dlt_BSWMasterContextPtr->ExitExclusiveArea();
        }

#else /* (DLT_TRAFFIC_SHAPER_ENABLED == STD_ON) */
        /* !LINKSTO Dlt.swdd.DltCore.API.MainFunction.ConditionsForMsgTransmissionMet.TransmitMsg,1,
                    Dlt.ASR431.Ref_SWS_Dlt_00651_MessageTrafficShapingSettings,1 */
        if (isOkToTransmit == TRUE)
        {
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          (void)Dlt_TriggerTransmit(Dlt_CfgLogChannel[chnIdx].DltITxPduHandleId, &PduInfo[chnIdx]);
          isOkToTransmit = FALSE;
#else
          Dlt_TriggerTransmit(DLT_TX_PDU_ID, &PduInfo[chnIdx]);
#endif
        }
#endif /* (DLT_TRAFFIC_SHAPER_ENABLED == STD_ON) */
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      }
#endif
    }
#if (DLT_STARTUP_DELAY_TIMER > 0U)
    else
    {
      /* !LINKSTO Dlt.swdd.Dlt_MainFunction.MessageProcessing.DelayCounter,1 */
      Dlt_StartupTransmissionDelay--;
    }
#endif
  }

  DBG_DLT_MAINFUNCTION_EXIT();
}

#ifdef DLT_VFB_MAINFUNCTION_PERIOD
/*-------------------Dlt_VfbMainFunction--------------------------------*/
FUNC(void, DLT_CODE) Dlt_VfbMainFunction(void)
{
  while (Dlt_NoOfMessagesInVfbBuffer > 0U)
  {
    /* Send a trace message containing information about the hook function */
    Dlt_SendTraceMessageForHookFunctions();

    Dlt_EnterExclusiveAreaAnyCoreContext();
    Dlt_NoOfMessagesInVfbBuffer--;
    Dlt_IsVfbBufferFull = FALSE;
    Dlt_ExitExclusiveAreaAnyCoreContext();
  }
}
#endif /* #ifdef DLT_VFB_MAINFUNCTION_PERIOD */

#if (DLT_IMPLEMENT_VFB_TRACE == STD_ON)
FUNC(void, DLT_CODE) Dlt_SendTraceMessageForHookFunctions(void)
{
  Dlt_MessageTraceInfoType TraceInfo = {
    DLT_TRACE_VFB,                                  /* log_level_trace_info */
    DLT_TYPE_APP_TRACE << DLT_OPT_MESSAGE_TYPE_POS, /* options */
    DLT_VFB_CONTEXT_ID,                             /* context_id */
    DLT_VFB_APP_ID                                  /* app_id - VFBT */
  };

  Dlt_MsgLengthType LocalPayloadLength;

  Dlt_EnterExclusiveAreaAnyCoreContext();

  /* Retrieve the payload length from the circular buffer */
  if ((Dlt_TraceDataReadIdx + DLT_VFB_CTX_ID_PAYLOAD_LEN) > DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE)
  {
    Dlt_VfbComposePayloadLength();
    LocalPayloadLength = DLT_UINT_FROM_VFB_BYTE_ARRAY_MSB(Dlt_LocalTraceData, 0U);
  }
  else
  {
    LocalPayloadLength = DLT_UINT_FROM_VFB_BYTE_ARRAY_MSB(Dlt_TraceData, Dlt_TraceDataReadIdx);
  }

  /* Based on the retrieved payload length, verify if the full message rolled over or not */
  if ((Dlt_TraceDataReadIdx + DLT_VFB_CTX_ID_PAYLOAD_LEN + LocalPayloadLength) > DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE)
  {
    Dlt_VfbComposePayload(&LocalPayloadLength);
  }
  else
  {
    /* Copy the ContextId, PayloadLength and Payload from the circular buffer to the locally used buffer */
    TS_MemCpy(&Dlt_LocalTraceData[0U], &Dlt_TraceData[Dlt_TraceDataReadIdx], (Dlt_MsgLengthType)(DLT_VFB_CTX_ID_PAYLOAD_LEN + LocalPayloadLength));
  }

  /* Copy the ContextId into the TraceInfo variable, for the Dlt_SendTraceMessage() call */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  TS_MemCpy(&TraceInfo.context_id[0U], &Dlt_LocalTraceData[0U], sizeof(Dlt_ContextIDType));
#else
  TraceInfo.context_id = DLT_UINT32_FROM_VFB_BYTE_ARRAY_MSB(Dlt_LocalTraceData);
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

  /* Move the read index to the next message in the circular buffer */
  Dlt_TraceDataReadIdx = (Dlt_TraceDataReadIdx + DLT_VFB_CTX_ID_PAYLOAD_LEN + LocalPayloadLength) % DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE;

  Dlt_ExitExclusiveAreaAnyCoreContext();

  /* Send the trace message containing the hook function information */
  /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00277, 1 */
  /* The uint16 cast is safe due to the current message length limitations of the specifications.
   * The internal message handling uses PduLengthType to align with PduR's specification. */
  (void)Dlt_SendTraceMessage(DLT_RTE_MODULE_ID, &TraceInfo, &Dlt_LocalTraceData[DLT_VFB_CTX_ID_PAYLOAD_LEN], (uint16)LocalPayloadLength);
}

FUNC(boolean, DLT_CODE) Dlt_CheckTraceStatusForContextId(
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    P2CONST(Dlt_ContextIDType, AUTOMATIC, DLT_APPL_CONST) ContextId)
#else
    Dlt_ContextIDType ContextId)
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
{
  boolean ReturnValue = FALSE;
  Dlt_AppIdTableIdxType AppIdIdx = 0U;
  Dlt_ContextIdTableIdxType ContextIdIdx = 0U;
  Dlt_AppToContextIdTableIdxType AppToCtxIdx = 0U;

  /* !LINKSTO Dlt.swdd.DltCore.JetTemplates.HookFunctions.SendTraceMessage.GlobalLogging, 1 */
  if(Dlt_GlobalLogStatus == DLT_LOGGING_ENABLED)
  {
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
    CoreIdType CurrentCoreId = GetCoreID();

    Dlt_BSWDistributionCommonType LocalCoreContext = (CurrentCoreId != DLT_MASTER_CORE) ?
      Dlt_GetSatelliteContextPtr()->CoreContext : Dlt_BSWMasterContextPtr->CoreContext;
#else
    Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
#endif
    Dlt_FindApplicationIDEntry(DLT_RTE_MODULE_ID, DLT_VFB_APP_ID_MSB, &LocalCoreContext, &AppIdIdx);

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    if (Dlt_CheckForRegisteredContext(DLT_UINT32_CONVERT_TUPLE(*ContextId), AppIdIdx, &ContextIdIdx, &AppToCtxIdx) == TRUE)
#else
    if (Dlt_CheckForRegisteredContext(ContextId, AppIdIdx, &ContextIdIdx, &AppToCtxIdx) == TRUE)
#endif
    {
      /* !LINKSTO SWS_Dlt_00065,1 */
#if (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON)
      if (*LocalCoreContext.FilterMessages == DLT_FILTER_MESSAGES_ON)
      {
        /* !LINKSTO SWS_Dlt_00281,1 */
        if ((LocalCoreContext.ContextIdTable[ContextIdIdx].TraceStatus == DLT_TRACE_STATUS_ON) ||
            ((LocalCoreContext.ContextIdTable[ContextIdIdx].TraceStatus == DLT_TRACE_STATUS_DEFAULT) &&
                (*LocalCoreContext.DefaultTraceStatus == DLT_TRACE_STATUS_ON)))
        {
          ReturnValue = TRUE;
        }
      }
      else
#endif /* (DLT_IMPLEMENT_FILTER_MESSAGES == STD_ON) */
      {
        ReturnValue = TRUE;
      }
    }
  }

  return ReturnValue;
}

FUNC(void, DLT_CODE) Dlt_WriteCtxIdPayloadLengthMessageIdInVfbBuffer(
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    P2CONST(Dlt_ContextIDType, AUTOMATIC, DLT_APPL_CONST) ContextId,
#else
    Dlt_ContextIDType ContextId,
#endif
    const Dlt_MsgLengthType TraceDataLength,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) MessageId)
{
  uint8 LocalBuffer[DLT_VFB_PAYLOAD_BUFFER_OFFSET] = {0U};

  /* Copy all data into a local buffer */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  TS_MemCpy(&LocalBuffer[0U], &ContextId[0U], 4U);
#else
  DLT_FILL_BUFFER_32_MSB(LocalBuffer, 0U, ContextId);
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

  DLT_FILL_BUFFER_MSB(LocalBuffer, DLT_VFB_PAYLOAD_LEN_OFFSET, TraceDataLength);

  TS_MemCpy(&LocalBuffer[DLT_VFB_CTX_ID_PAYLOAD_LEN], &MessageId[0U], 4U);

  /* Data rolls over the buffer limit */
  if ( (Dlt_TraceDataWriteIdx + DLT_VFB_PAYLOAD_BUFFER_OFFSET) > DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE )
  {
    TS_MemCpy(&Dlt_TraceData[Dlt_TraceDataWriteIdx],
        &LocalBuffer[0U],
        (Dlt_MsgLengthType)(DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataWriteIdx));

    TS_MemCpy(&Dlt_TraceData[0U],
        &LocalBuffer[(Dlt_MsgLengthType)(DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataWriteIdx)],
        (Dlt_MsgLengthType)(DLT_VFB_PAYLOAD_BUFFER_OFFSET - (DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataWriteIdx)));
  }
  /* Data is contained within the buffer limit */
  else
  {
    TS_MemCpy(&Dlt_TraceData[Dlt_TraceDataWriteIdx], &LocalBuffer[0U], DLT_VFB_PAYLOAD_BUFFER_OFFSET);
  }

  /* Move the write index to the next available position in the circular buffer */
  Dlt_TraceDataWriteIdx = (Dlt_TraceDataWriteIdx + DLT_VFB_PAYLOAD_BUFFER_OFFSET) % DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE;

  if (Dlt_TraceDataWriteIdx == Dlt_TraceDataReadIdx)
  {
    Dlt_IsVfbBufferFull = TRUE;
  }
}

/* !LINKSTO SWS_Dlt_00278, 1 */
FUNC(void, DLT_CODE) Dlt_WriteArgsInVfbBuffer(
    CONSTP2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) ArgumentName,
    const Dlt_MsgLengthType ArgumentSize)
{
  P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) ArgumentMemOffset = NULL_PTR;

  if ((Dlt_TraceDataWriteIdx + ArgumentSize) > DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE)
  {
    /* !LINKSTO Dlt.ASR431.SWS_Dlt_00632, 1 */
    TS_MemCpy(&Dlt_TraceData[Dlt_TraceDataWriteIdx], ArgumentName,
        (Dlt_MsgLengthType)(DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataWriteIdx));

    ArgumentMemOffset = ArgumentName + (DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataWriteIdx);

    TS_MemCpy(&Dlt_TraceData[0U], ArgumentMemOffset,
        (Dlt_MsgLengthType)(ArgumentSize - (DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataWriteIdx)));
  }
  else
  {
    /* !LINKSTO Dlt.ASR431.SWS_Dlt_00632, 1 */
    TS_MemCpy(&Dlt_TraceData[Dlt_TraceDataWriteIdx], ArgumentName, ArgumentSize);
  }

  Dlt_TraceDataWriteIdx = (Dlt_TraceDataWriteIdx + ArgumentSize) % DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE;

  if (Dlt_TraceDataWriteIdx == Dlt_TraceDataReadIdx)
  {
    Dlt_IsVfbBufferFull = TRUE;
  }
}

FUNC(boolean, DLT_CODE) Dlt_IsSpaceAvailableInVfbBuffer(
    const Dlt_MsgLengthType TraceDataLength)
{
  boolean ReturnValue = FALSE;

  Dlt_EnterExclusiveAreaAnyCoreContext();

  if ( (TraceDataLength <= DLT_VFB_TRACE_PAYLOAD_MAX_SIZE) && (Dlt_IsVfbBufferFull == FALSE) )
  {
    if (Dlt_NoOfMessagesInVfbBuffer == 0U)
    {
      ReturnValue = TRUE;
    }
    else
    {
      if ((Dlt_TraceDataWriteIdx + TraceDataLength) < DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE)
      {
        /* CHECK: NOPARSE */
        if (Dlt_TraceDataWriteIdx > Dlt_TraceDataReadIdx)
        /* CHECK: PARSE */
        {
          ReturnValue = TRUE;
        }
        /* CHECK: NOPARSE */
        else
        {
          /* Reaching this branch implies a message so big in size that it wrote
           * from W0 up until R1. This involves writing over R0,
           * which is a case that gets dismissed by the previous if-condition.
           *
           * 0 ----------R0------------W0-------R1------------ 100
           *
           */
          DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_SID_SendTraceMessage);
        }
        /* CHECK: PARSE */
      }
      else
      {
        if (((Dlt_TraceDataWriteIdx + TraceDataLength) % DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE) <= Dlt_TraceDataReadIdx)
        {
          ReturnValue = TRUE;
        }
      }
    }
  }

  Dlt_ExitExclusiveAreaAnyCoreContext();

  return ReturnValue;
}

#endif /* #if (DLT_IMPLEMENT_VFB_TRACE == STD_ON) */

#if (DLT_IMPLEMENT_NV_RAM_STORAGE == STD_ON)
/*-------------------Dlt_GetLastRegisteredIndex-------------------------*/

FUNC(void, DLT_CODE) Dlt_GetLastRegisteredIndex
(
    P2VAR(Dlt_AppIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) appIdIdx,
    P2VAR(Dlt_AppToContextIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) appToCtxRefIdx
)
{
  *appIdIdx = Dlt_LastApplIdxRegistered;
  *appToCtxRefIdx = Dlt_LastAppToCtxRefIdxRegistered;
}

/*-------------------Dlt_IssueWriteRequestToNvM-------------------------*/
FUNC(Dlt_ReturnType, DLT_CODE) Dlt_IssueWriteRequestToNvM(void)
{
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ReturnType retVal = E_NOT_OK;
#else
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
#endif
  Std_ReturnType requestForNative = E_NOT_OK;
  Std_ReturnType requestForDataSet = E_NOT_OK;

  /*store the general configuration parameters*/
  /* !LINKSTO Dlt.DltPersistentStorage.DltConfigParam, 1,
              Dlt.swdd.DltPersistentStorage.UsedNvMAPI, 1,
              Dlt.swdd.DltPersistentStorage.BlockIdForNativeBlock, 1,
              Dlt.OptionalInterfaces, 1 */
  /* Deviation TASKING-7 */
  requestForNative = NvM_WriteBlock(DLT_STORE_NATIVE_NVRAM_BLOCK_ID, NULL_PTR);

  /* set the index of data set block that will be first to be written */
  if (*Dlt_BSWMasterContextPtr->CoreContext.ContextIdTableIdx > 0U)
  {
    /* !LINKSTO Dlt_StorePersistent.RequestToSetDataSetIndexFails,1,
                Dlt.swdd.DltPersistentStorage.BlockIdForDataSetBlock, 1 */
    requestForDataSet = NvM_SetDataIndex(DLT_STORE_DATASET_NVRAM_BLOCK_ID, 0U);

    if (E_OK == requestForDataSet)
    {
      /* trigger the persistent storage for configured pairs of ApplicationID and ContextId */
      /* !LINKSTO Dlt.DltPersistentStorage.BlockTypeDataSet, 2,
                  Dlt.swdd.DltPersistentStorage.BlockIdForDataSetBlock, 1 */
      /* Deviation TASKING-8 */
      requestForDataSet = NvM_WriteBlock(DLT_STORE_DATASET_NVRAM_BLOCK_ID, NULL_PTR);
    }
  }
  else
  {
    /* Deviation TASKING-9 */
    requestForDataSet = E_OK;
  }

#if (DLT_DEV_ERROR_DETECT == STD_OFF)
  TS_PARAM_UNUSED(requestForNative);
#else /* #if (DLT_DEV_ERROR_DETECT == STD_ON) */
  if((requestForNative != E_OK) || (requestForDataSet != E_OK))
  {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    /* !LINKSTO Dlt_StorePersistent.RequestToSetDataSetIndexDet, 1,
                Dlt.swdd.Dlt_IssueWriteRequestToNvM.WriteRequestFail.DET.SID.ASR43,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_StoreConfiguration, DLT_E_REQUEST_NOT_ACCEPTED);
#else
    /* !LINKSTO Dlt.swdd.Dlt_IssueWriteRequestToNvM.WriteRequestFail.DET.SID.ASR42,1 */
    DLT_DET_REPORT_ERROR(DLT_SID_StorePersistent, DLT_E_REQUEST_NOT_ACCEPTED);
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
  }
  else
#endif /* #if (DLT_DEV_ERROR_DETECT == STD_ON) */
  {
    retVal = DLT_E_OK;
  }

  return retVal;
}

#endif /* DLT_IMPLEMENT_NV_RAM_STORAGE == STD_ON */

/*-----------------------------[Dlt_FindApplicationIDEntry]------------------*/
FUNC(void, DLT_CODE) Dlt_FindApplicationIDEntry(
    Dlt_SessionIDType session_id,
    Dlt_Internal_ApplicationIDType app_id,
    CONSTP2CONST(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) LocalCoreContext,
    P2VAR(Dlt_AppIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) aIdx)
{
  Dlt_AppIdTableIdxType applIdx = 0U;

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  if (session_id != DLT_NO_SESSION_ID)
  {
    for (applIdx = *aIdx; applIdx < (*LocalCoreContext->MaxRegisteredAppldTableEntry); applIdx++)
    {
      if ((LocalCoreContext->AppIdTable[applIdx].AppId == app_id) && (LocalCoreContext->AppIdTable[applIdx].SessionId == session_id))
      {
        break;
      }
    }
  }
  else
  {
    for (applIdx = *aIdx; applIdx < *LocalCoreContext->MaxRegisteredAppldTableEntry; applIdx++)
    {
      if (Dlt_AppIdTable[applIdx].AppId == app_id)
      {
        break;
      }
    }
  }
#else
  for (applIdx = *aIdx; applIdx < Dlt_MaxRegisteredAppldTableEntry; applIdx++)
  {
    if (Dlt_AppIdTable[applIdx].AppId == app_id)
    {
      break;
    }
  }
  TS_PARAM_UNUSED(session_id);
  TS_PARAM_UNUSED(LocalCoreContext);
#endif

  *aIdx = applIdx;
}

#if ( (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) || (DLT_SWC_SESSION_REGISTERED > 0U) )
/*-----------------------------[Dlt_FindSessionIDEntry]------------------*/
STATIC FUNC(void, DLT_CODE) Dlt_FindSessionIDEntry(
    boolean runtime,
    Dlt_SessionIDType sessionId,
    CONSTP2CONST(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) LocalCoreContext,
    P2VAR(Dlt_SessionIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) sessionIdx)
{
  Dlt_SessionIdTableIdxType SessionIdIdx = 0U;

#if (DLT_SWC_SESSION_REGISTERED > 0)
  for (SessionIdIdx = 0U; SessionIdIdx < (DLT_SWC_SESSION_REGISTERED); SessionIdIdx++)
#endif
  {
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    if (runtime == FALSE)
    {
      if (Dlt_SwCLogInfo[SessionIdIdx].DltSwCSessionId == sessionId)
      {
        break;
      }
    }
    else
#endif
    {
#if (DLT_SWC_SESSION_REGISTERED > 0)
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      if (LocalCoreContext->SessionIdTable[SessionIdIdx].SessionId == sessionId)
#else
      if (Dlt_SessionIdTable[SessionIdIdx].SessionId == sessionId)
#endif
      {
        break;
      }
#endif
    }
  }

#if(DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
   TS_PARAM_UNUSED(runtime);
   TS_PARAM_UNUSED(LocalCoreContext);
#endif

#if(DLT_SWC_SESSION_REGISTERED == 0)
   TS_PARAM_UNUSED(sessionId);
#endif

  *sessionIdx = SessionIdIdx;
}
#endif /* #if ( (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) || (DLT_SWC_SESSION_REGISTERED > 0U) ) */

#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
/*-----------------------------[Dlt_FindCtxAppRegisteredTuple]------------------*/
STATIC FUNC(void, DLT_CODE) Dlt_FindCtxAppRegisteredTuple(
    Dlt_SessionIdTableIdxType sessIdx,
    Dlt_Internal_ApplicationIDType app_id,
    Dlt_Internal_ContextIDType context_id,
    P2VAR(Dlt_ContextIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) ctxtIdx)
{
  Dlt_Internal_ContextIDType contextIdx;
  const Dlt_SwCContextType * ContextInfo = DltSwCContextInfoPtr[sessIdx];
  /* Search in the SwC Context for the ApplicationId */
  for (contextIdx = 0U; contextIdx < Dlt_MaxCtxAppIdPerSwC[sessIdx]; contextIdx ++)
  {
    if((ContextInfo[contextIdx].Dlt_AppCtxTuple.DltSwCApplicationId == app_id) &&
      (ContextInfo[contextIdx].Dlt_AppCtxTuple.DltSwCContextId == context_id))
    {
      break;
    }
  }
  *ctxtIdx =  contextIdx;
}

/*-----------------------------[Dlt_FindChannelIdx]------------------*/
STATIC FUNC(void, DLT_CODE) Dlt_FindChannelIdx(
    P2VAR(Dlt_ChnIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) chnIdx,
    PduIdType pduId
    )
{
  Dlt_ChnIdTableIdxType chnIndex;
  /* Application Id was found. Search further for the channel id */
  for (chnIndex = 0U; chnIndex < DLT_TXPDU_NO; chnIndex++)
  {
    if(pduId == Dlt_CfgLogChannel[chnIndex].DltITxPduHandleId)
    {
      /* channel index was found */
      break;
    }
  }
  *chnIdx = chnIndex;
}

#endif
/*-----------------------------[Dlt_CheckForRegisteredContext]------------------*/
FUNC(boolean, DLT_CODE) Dlt_CheckForRegisteredContext(
    Dlt_Internal_ContextIDType contextId,
    Dlt_AppIdTableIdxType aIdx,
    P2VAR(Dlt_ContextIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) citIdx,
    P2VAR(Dlt_AppToContextIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) applToCitIdx)
{
  boolean contextIsRegistered = FALSE;
  Dlt_AppToContextIdTableIdxType atcIdx;
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
  Dlt_BSWDistributionCommonType LocalCoreContext;
  CoreIdType CurrentCoreId = GetCoreID();
  LocalCoreContext = (CurrentCoreId != DLT_MASTER_CORE) ?
  Dlt_GetSatelliteContextPtr()->CoreContext : Dlt_BSWMasterContextPtr->CoreContext;
#else
  Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
#endif
  /* This loop checks whether the context_id has already been registered
   * for the given app_id. This is the case when the loop completes without
   * executing the break; statement. As a result, atcIdx equals
   * Dlt_AppToContextIdTableIdx[aIdx]. */

  Dlt_EnterExclusiveAreaAnyCoreContext();
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  for (atcIdx = 0U; atcIdx < LocalCoreContext.AppToContextIdTableIdx[aIdx]; atcIdx++)
  {
    if (LocalCoreContext.ContextIdTable[
      LocalCoreContext.AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx]].ContextId == contextId)
    {
      break;
    }
  }
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
  for (atcIdx = 0U; atcIdx < Dlt_AppToContextIdTableIdx[aIdx]; atcIdx++)
  {
    if (LocalCoreContext.ContextIdTable[
      Dlt_AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx]].ContextId == contextId)
    {
      break;
    }
  }
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  if (atcIdx != LocalCoreContext.AppToContextIdTableIdx[aIdx])
  {
    /* context has already been registered, set the CitIdx to the found entry */
    *citIdx = LocalCoreContext.AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx];
    contextIsRegistered = TRUE;
  }
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
  if (atcIdx != Dlt_AppToContextIdTableIdx[aIdx])
  {
    /* context has already been registered, set the CitIdx to the found entry */
    *citIdx = Dlt_AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx];
    contextIsRegistered = TRUE;
  }
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
  else
  {
    /* the context does not exist, set the CitIdx to the next free index in ContextIdTable */
    *citIdx = *LocalCoreContext.ContextIdTableIdx;
    contextIsRegistered = FALSE;
  }
  Dlt_ExitExclusiveAreaAnyCoreContext();

  /* retrieve index of the contextId for the given applId */
  *applToCitIdx = atcIdx;

  return contextIsRegistered;
}

#if (((DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)&&(DLT_REGISTER_CONTEXT_NOTIFICATION == STD_ON))\
    || (DLT_RECEPTION_CONTROL_MESSAGES_ENABLED == STD_ON))
/*--------------------[Dlt_WriteDwordToByteArrayPayload]---------------------------*/

 FUNC(void, DLT_CODE) Dlt_WriteDwordToByteArrayPayload
(
  P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) DesPtr,
  uint32                                 Dword
)
{
#if (DLT_HEADER_PAYLOAD_ENDIANES_BIT != 0U )
  {
    /* MSB */
    DesPtr[3] = (uint8)Dword;
    DesPtr[2] = (uint8)(Dword >> 8U);
    DesPtr[1] = (uint8)(Dword >> 16U);
    DesPtr[0] = (uint8)(Dword >> 24U);
  }
#else
  {
    /* LSB */
    DesPtr[0] = (uint8)Dword;
    DesPtr[1] = (uint8)(Dword >> 8U);
    DesPtr[2] = (uint8)(Dword >> 16U);
    DesPtr[3] = (uint8)(Dword >> 24U);
  }
#endif
}

/*-----------------------------[Dlt_CalculateRespHdrLength]-----------*/
FUNC(uint8, DLT_CODE) Dlt_CalculateRespHdrLength(void)
{
  uint8 TotalHeaderLength;

  /* Response header length for the control messages has to contain the minimum length =
   * Minimum Header Length( = 4U) + ECU header Length ( = 4U) + Extended header length ( = 10U) */
  TotalHeaderLength = DLT_EXT_HEADER_LENGTH_STATIC + DLT_ECU_HEADER_LENGTH_STATIC + DLT_MIN_HEADER_LENGTH;

  Dlt_BSWMasterContextPtr->EnterExclusiveArea();

  if (Dlt_HeaderUseSessionID == DLT_HEADER_SESSION_ID_BIT)
  {
    TotalHeaderLength += DLT_SEID_HEADER_LENGTH;
  }
#if (DLT_IMPLEMENT_TIMESTAMP != STD_OFF)
  if (Dlt_HeaderUseTimestamp == DLT_HEADER_TIMESTAMP_BIT)
  {
    TotalHeaderLength += DLT_TMSP_HEADER_LENGTH;
  }

  Dlt_BSWMasterContextPtr->ExitExclusiveArea();

#endif /* DLT_IMPLEMENT_TIMESTAMP != STD_OFF */
 return TotalHeaderLength;
}

/*-----------------------------[Dlt_SendResponse]------------------*/
FUNC(void, DLT_CODE) Dlt_SendResponse
(
  P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) header,
  P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) payload,
  uint8 headerlen,
  Dlt_MsgLengthType datalen
)
{
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ReturnType retVal = DLT_E_ERROR;
  uint8 chnIdx = DEFAULT_LOG_CHN_IDX;
  Dlt_MsgLengthType MsgLen = Dlt_CfgLogChannel[DEFAULT_LOG_CHN_IDX].DltLogChannelMaxMessageLength;
  uint32 MaxMsgLen = Dlt_CfgLogChannel[DEFAULT_LOG_CHN_IDX].DltLogChannelBufferSize;
#else
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
  uint8 chnIdx = 0U;
  Dlt_MsgLengthType MsgLen = DLT_MAX_MESSAGE_LENGTH;
  uint32 MaxMsgLen = DLT_MESSAGE_BUFFER_SIZE;
#endif
  uint32 Dlt_LocalStoreIdx;

  Dlt_BSWMasterContextPtr->EnterExclusiveArea();
  Dlt_LocalStoreIdx = Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdx;
  Dlt_BSWMasterContextPtr->ExitExclusiveArea();

  /* Check whether the message fits into the buffer without potentially
     * overwriting a message in transmission */
  retVal = Dlt_CheckBuffer(chnIdx,
                           headerlen + datalen,
                           MsgLen,
                           MaxMsgLen,
                           Dlt_LocalStoreIdx);

  if (retVal == DLT_E_OK)
  {
    /* Store the header and the payload in the circular buffer and
     * ignore a possible buffer overflow.*/
    (void)Dlt_StoreInBuffer(chnIdx, header, payload, headerlen, datalen, Dlt_LocalStoreIdx);
  }
  else
  {
    /* response will be lost as we couldn't store it in our tx buffer. Dlt viewer should
     * have a response timeout and retrigger the request. */
  }
}
#endif
/*-----------------------------[Dlt_CreateStandardHeader]---------*/
/* !LINKSTO Dlt.DltCore.Dlt_StandardHeaderEntriesExtension,1 */
FUNC(void, DLT_CODE) Dlt_CreateStandardHeader(
   uint8 chidx,
   Dlt_SessionIDType session_id,
   P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) hdrbuf,
   P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) nexthdridx,
   Dlt_MsgLengthType MsgLen, uint32 timestamp)
{
  uint8 nextidx = *nexthdridx;

  DBG_DLT_CREATESTANDARDHEADER_ENTRY(chidx, session_id, hdrbuf, nexthdridx, MsgLen, timestamp);

  Dlt_BSWMasterContextPtr->EnterExclusiveArea();
  /* HTYP field
   * These fields cannot be changed during runtime, thus they can be set
   * outside the exclusive area and thus save locking time. */
  /* !LINKSTO SWS_Dlt_00082,1, SWS_Dlt_00301,1, SWS_Dlt_00302,1, SWS_Dlt_00458,1,
              SWS_Dlt_00094,1, SWS_Dlt_00103,1 */
  hdrbuf[DLT_HTYP_HEADER_OFFSET] |= Dlt_HeaderPayloadEndianes |
                                    Dlt_HeaderProtocolVersion;

  /* !LINKSTO SWS_Dlt_00084,1, SWS_Dlt_00105,1,
              SWS_Dlt_00106,1, Dlt.ASR431.SWS_Dlt_00671,1, Dlt.ASR431.SWS_Dlt_00677, 1 */
  Dlt_HeaderMessageCounter[chidx]++;

  /* MCNT field */
  hdrbuf[DLT_MCNT_HEADER_OFFSET] = Dlt_HeaderMessageCounter[chidx];
  Dlt_BSWMasterContextPtr->ExitExclusiveArea();

  /* LEN field */
  /* !LINKSTO SWS_Dlt_00091,1, SWS_Dlt_00085,1, SWS_Dlt_00107,1 */
  DLT_FILL_BUFFER_16_MSB(hdrbuf, DLT_LEN_HEADER_OFFSET, MsgLen);

  /* ECU field */
   /* !LINKSTO SWS_Dlt_00083,1, SWS_Dlt_00098,1, SWS_Dlt_00305,1,
               SWS_Dlt_00321,1, Dlt.ASR431.SWS_Dlt_00686, 1 */
  if((hdrbuf[DLT_HTYP_HEADER_OFFSET] & DLT_HEADER_ECU_ID_BIT) != 0U)
  {
#if  (STD_ON == DLT_GETECUID_AT_RUNTIME)
    /* !LINKSTO EB_Req_EcuIdChoice.Callout.NoInit, 1 */
    /* If Dlt_UserEcuId still has the initial value, it has to be initialized */
    if (0U == Dlt_UserEcuId[0])
    {
      /* !LINKSTO EB_Req_EcuIdChoice.Callout, 1 */
      P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA)  PEcuId = (uint8 *)Dlt_AppGetEcuIdAddress();
      if (NULL_PTR != PEcuId)
      {
        TS_MemCpy(Dlt_UserEcuId,PEcuId,DLT_ECU_HEADER_LENGTH_STATIC);
      }
#if (DLT_DEV_ERROR_DETECT == STD_ON)
      else
      {
        DLT_DET_REPORT_ERROR(DLT_SID_GetEcuIdAddress, DLT_E_PARAM_POINTER);
      }
#endif /* #if (DLT_DEV_ERROR_DETECT == STD_ON) */
    }

    hdrbuf[nextidx + 0U] = Dlt_UserEcuId[0];
    hdrbuf[nextidx + 1U] = Dlt_UserEcuId[1];
    hdrbuf[nextidx + 2U] = Dlt_UserEcuId[2];
    hdrbuf[nextidx + 3U] = Dlt_UserEcuId[3];
#else
    /* !LINKSTO SWS_Dlt_00308, 1,
     EB_Req_EcuIdChoice.Value, 1 */
    /* local array to hold the ECU standard header field */
    const uint8 EcuId[DLT_ECU_HEADER_LENGTH] = {DLT_ECU_ID};

    /* !LINKSTO Dlt.ASR431.SWS_Dlt_00687, 1 */
    hdrbuf[nextidx + 0U] = EcuId[0];
    hdrbuf[nextidx + 1U] = EcuId[1];
    hdrbuf[nextidx + 2U] = EcuId[2];
    hdrbuf[nextidx + 3U] = EcuId[3];
#endif

    nextidx += DLT_ECU_HEADER_LENGTH;
  }

  /* SEID field */
  /* !LINKSTO SWS_Dlt_00085,1, SWS_Dlt_00407,1, SWS_Dlt_00101,1,
              SWS_Dlt_00306,1, SWS_Dlt_00110,1 */
  if((hdrbuf[DLT_HTYP_HEADER_OFFSET] & DLT_HEADER_SESSION_ID_BIT) != 0U)
  {
    /* !LINKSTO SWS_Dlt_00091,1, Dlt.ASR431.SWS_Dlt_00688, 1 */
    DLT_FILL_BUFFER_32_MSB(hdrbuf, nextidx, session_id);
    nextidx += DLT_SEID_HEADER_LENGTH;
  }
#if (DLT_IMPLEMENT_TIMESTAMP != STD_OFF)
  /* TMSP field */
   /* !LINKSTO SWS_Dlt_00083,1, SWS_Dlt_00102,1, SWS_Dlt_00307,1,
               SWS_Dlt_00323,1, Dlt.swdd.CreateStandardHeader.API.Timestamp,1 */
  if((hdrbuf[DLT_HTYP_HEADER_OFFSET] & DLT_HEADER_TIMESTAMP_BIT) != 0U)
  {
    Dlt_BSWMasterContextPtr->EnterExclusiveArea();
    if(Dlt_InitStateMaster == DLT_UNINITIALIZED)
    {
      /* !LINKSTO SWS_Dlt_00483,1 */
      /* !LINKSTO Dlt.swdd.CreateStandardHeader.API.Timestamp.Uninitialized,1 */
      DLT_FILL_BUFFER_32_MSB(hdrbuf, nextidx, 0U);
    }
    else
    {
      /* !LINKSTO SWS_Dlt_00091,1, SWS_Dlt_00323,1 */
      /* !LINKSTO Dlt.swdd.CreateStandardHeader.API.Timestamp.Initialized,1 */
      DLT_FILL_BUFFER_32_MSB(hdrbuf, nextidx, timestamp);
    }
    Dlt_BSWMasterContextPtr->ExitExclusiveArea();
    nextidx += DLT_TMSP_HEADER_LENGTH;
  }
#else /* #if (DLT_IMPLEMENT_TIMESTAMP == STD_OFF) */
  TS_PARAM_UNUSED(timestamp);
#endif /* DLT_IMPLEMENT_TIMESTAMP != STD_OFF */

  *nexthdridx = nextidx;

  DBG_DLT_CREATESTANDARDHEADER_EXIT(chidx, nextidx, session_id, hdrbuf, nexthdridx, MsgLen, timestamp);
}

#if (DLT_IMPLEMENT_EXTENDED_HEADER == STD_ON)
/*-----------------------------[Dlt_CreateExtendedHeader]---------*/
FUNC(void, DLT_CODE) Dlt_CreateExtendedHeader(
   P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_CONST) msg_info,
   P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) hdrbuf,
   P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) nexthdridx)
{
  uint8 nextidx = *nexthdridx;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_Internal_ApplicationIDType msgInfoAppId_Internal = DLT_UINT32_FROM_BYTE_ARRAY_VFB_HEADER(msg_info->app_id);
  Dlt_Internal_ContextIDType msgInfoContextId_Internal = DLT_UINT32_FROM_BYTE_ARRAY_VFB_HEADER(msg_info->context_id);
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
  Dlt_ApplicationIDType msgInfoAppId_Internal = msg_info->app_id;
  Dlt_ContextIDType msgInfoContextId_Internal = msg_info->context_id;
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

  DBG_DLT_CREATEEXTENDEDHEADER_ENTRY(msg_info, hdrbuf, nexthdridx);

  /* !LINKSTO SWS_Dlt_00086,1, SWS_Dlt_00088,1, SWS_Dlt_00087,1, SWS_Dlt_00406, 1,
              SWS_Dlt_00095,1, SWS_Dlt_00303,1, SWS_Dlt_00457,1, SWS_Dlt_00117, 1 */

  /* Check if extended header is allowed to be created or if this is a response to a
  control message (in that case extended header is always sent) */
  if(((hdrbuf[DLT_HTYP_HEADER_OFFSET] & DLT_HEADER_EXTENDED_HEADER_BIT) != 0U) ||
     ((uint8)((uint8)(msg_info->options) & DLT_OPT_MESSAGE_TYPE_MASK) == (DLT_TYPE_CONTROL << DLT_OPT_MESSAGE_TYPE_POS))
    )
  {

    /* !LINKSTO SWS_Dlt_00118,1, SWS_Dlt_00324,1, SWS_Dlt_00325,1, SWS_Dlt_00121,1,
                SWS_Dlt_00122,1, SWS_Dlt_00123,1, SWS_Dlt_00124,1, PRS_Dlt_00618,1,
                Dlt.ASR431.Ref_SWS_Dlt_00695, 1, Dlt.ASR431.SWS_Dlt_00696, 1 */
    /* Message Info (MSIN) field - 1 byte */

    /* Bit 0       - Verbose (VERB) bit
     * Bit 1, 2, 3 - Message Type (MSTP) bits */
    hdrbuf[nextidx] =
        (uint8)(((uint8)(((uint8)((uint8)(msg_info->options) & DLT_OPT_VERBOSE_MODE_MASK))
                >> DLT_OPT_VERBOSE_MODE_POS) |
        (uint8)(((uint8)((uint8)(msg_info->options) & DLT_OPT_MESSAGE_TYPE_MASK))
                << DLT_OPT_MESSAGE_TYPE_MSTP_BSHIFT)));

    /* Bit 4, 5, 6, 7 - Message Type Info (MTIN) bits */
    if((uint8)((uint8)(msg_info->options) & DLT_OPT_MESSAGE_TYPE_MASK)  == (DLT_TYPE_LOG << DLT_OPT_MESSAGE_TYPE_POS))
    {
      hdrbuf[nextidx] |=
          (uint8)(((uint8)(msg_info->log_level_trace_info) & DLT_LOG_LEVEL_TYPE_MASK)
              << DLT_LOG_TRACE_TYPE_POS);
    }
    else if((uint8)((uint8)(msg_info->options) & DLT_OPT_MESSAGE_TYPE_MASK) == (DLT_TYPE_APP_TRACE << DLT_OPT_MESSAGE_TYPE_POS))
    {
      hdrbuf[nextidx] |=
          (uint8)(((uint8)(msg_info->log_level_trace_info) & DLT_TRACE_TYPE_MASK)
              << DLT_LOG_TRACE_TYPE_POS);
    }
    else if((uint8)((uint8)(msg_info->options) & DLT_OPT_MESSAGE_TYPE_MASK) == DLT_TYPE_CONTROL << DLT_OPT_MESSAGE_TYPE_POS)
    {
      /* !LINKSTO SWS_Dlt_00123,1 */
      hdrbuf[nextidx] |= (uint8)(DLT_CONTROL_RESPONSE_BITS_IN_MSIN);
    }
    else
    {
      /* Do nothing */
    }

    /* !LINKSTO Dlt.DltProtocol.NumberOfAguments.Verbose,1, Dlt.DltProtocol.VERB_Bit.Set,1, Dlt.DltProtocol.VERB_Bit.Cleared,1, SWS_Dlt_00326,1 */
    if(((uint8)((msg_info->options) & DLT_OPT_VERBOSE_MODE_MASK)) != 0U)
    {
      DLT_PRECONDITION_ASSERT(DLT_INSTANCE_ID, (msg_info->arg_count < 255U), DLT_INTERNAL_API_ID);
      hdrbuf[nextidx + DLT_MSIN_HEADER_LEN] = (uint8)msg_info->arg_count;
    }
    else
    {
      /* !LINKSTO Dlt.DltProtocol.NumberOfAguments.NonVerbose,1 */
      hdrbuf[nextidx + DLT_MSIN_HEADER_LEN] = 0U;
    }
    /* APID field */
    /* !LINKSTO SWS_Dlt_00091,1, SWS_Dlt_00127,1 */
    DLT_FILL_BUFFER_32_MSB(hdrbuf, nextidx +
        (DLT_MSIN_HEADER_LEN + DLT_NOAR_HEADER_LEN), msgInfoAppId_Internal);

    /* CTID field */
    /* !LINKSTO SWS_Dlt_00091,1, SWS_Dlt_00128,1 */
    DLT_FILL_BUFFER_32_MSB(hdrbuf, nextidx +
        (DLT_MSIN_HEADER_LEN + DLT_NOAR_HEADER_LEN + DLT_APID_HEADER_LEN), msgInfoContextId_Internal);

    nextidx += (DLT_MSIN_HEADER_LEN + DLT_NOAR_HEADER_LEN + DLT_APID_HEADER_LEN + DLT_CTID_HEADER_LEN);
  }

  *nexthdridx = nextidx;

  DBG_DLT_CREATEEXTENDEDHEADER_EXIT(nextidx, msg_info, hdrbuf, nexthdridx);
}
#endif /* #if (DLT_IMPLEMENT_EXTENDED_HEADER == STD_ON) */


/*-----------------------------[Dlt_GetTimestamp]------------------*/
FUNC(uint32, DLT_CODE) Dlt_GetTimestamp(void)
{
  uint32 retVal = 0U;

#if (DLT_IMPLEMENT_TIMESTAMP == STBM_TIMESTAMP)
  StbM_TimeStampType timestamp = {0U, 0U, 0U, 0U};
  StbM_UserDataType  userData  = {0U, 0U, 0U, 0U};

  DBG_DLT_GETTIMESTAMP_ENTRY();

  /* !LINKSTO SWS_Dlt_00113, 1, Dlt.ASR431.SWS_Dlt_00655, 1, Dlt.OptionalInterfaces, 1 */
  retVal = StbM_GetCurrentTime(DLT_STBM_TIMEBASE_REF_ID, &timestamp, &userData);

  if (retVal == E_OK)
  {
    /* Calculate the timestamp so the resolution is 0.1 ms */
    retVal = (timestamp.nanoseconds / 100000U) + (timestamp.seconds * 10000U);
  }
  else
  {
    /* !LINKSTO Dlt.ASR431.SWS_Dlt_00653,1 */
    retVal = 0U;
  }

#elif (DLT_IMPLEMENT_TIMESTAMP == OS_TIMESTAMP)
  os_timestamp_t timestamp;

  DBG_DLT_GETTIMESTAMP_ENTRY();

  TS_MemBZero(&timestamp, sizeof(timestamp));

  /* !LINKSTO SWS_Dlt_00113,1 */
  OS_GetTimeStamp(&timestamp);

  retVal = (uint32)OS_TimeGetLo(timestamp);

#else /* if (DLT_IMPLEMENT_TIMESTAMP == STD_OFF) */

  DBG_DLT_GETTIMESTAMP_ENTRY();

#endif /* DLT_IMPLEMENT_TIMESTAMP == STBM_TIMESTAMP */

  DBG_DLT_GETTIMESTAMP_EXIT(retVal);

  return retVal;
}

/*==================[internal function definitions]=========================*/

#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
/*-----------------------------[Dlt_TriggerTransmit]------------------*/
STATIC FUNC(Std_ReturnType, DLT_CODE) Dlt_TriggerTransmit(
 PduIdType TxPduId,
 P2VAR(PduInfoType, AUTOMATIC, DLT_APPL_DATA) PduInfoPtr )
#else
STATIC FUNC(void, DLT_CODE) Dlt_TriggerTransmit(
 PduIdType TxPduId,
 P2VAR(PduInfoType, AUTOMATIC, DLT_APPL_DATA) PduInfoPtr)
#endif
{
  Dlt_ChnIdTableIdxType chnIdx = 0U;
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Std_ReturnType retVal = E_NOT_OK;
  Dlt_FindChannelIdx(&chnIdx, TxPduId);
#else
  TxPduId = DLT_TX_PDU_ID;
#endif
#if (DLT_DEV_ERROR_DETECT == STD_ON)
  /* CHECK: NOPARSE */
  if (NULL_PTR == PduInfoPtr)
  {
    /*
     * Since Dlt_TriggerTransmit is not public, and the Pdu pointer is passed, initialized
     * locally and only called by Dlt_MainFunction() function, it is impossible at this point to have
     * a function call with a null pointer
     */
    DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_SID_TriggerTransmit);
    /* !LINKSTO Dlt.EB_Req_TxNullPtr, 1 */
    DLT_DET_REPORT_ERROR(DLT_SID_TriggerTransmit, DLT_E_PARAM_POINTER);
  }
  /* CHECK: PARSE */

#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  /* Something strange happened if these do not match */

  /* CHECK: NOPARSE */
  else if (chnIdx == DLT_TXPDU_NO)
  {
    /* The TxPduIds and the channels are defined in the Tresos configuration and there will be a PduID per channel.
     * The PduIds are 0 based and consecutive, which means that it is impossible to define an invalid configuration which would cover this branch
     */
    DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_SID_TriggerTransmit);
      /* !LINKSTO Dlt.EB_Req_TxPduIDNotFound, 1 */
    DLT_DET_REPORT_ERROR(DLT_SID_TriggerTransmit, DLT_E_WRONG_PARAMETERS);
  }
  /* CHECK: PARSE */
#endif
  else
#endif /* (DLT_DEV_ERROR_DETECT == STD_ON) */
  {
    DBG_DLT_TRIGGERTRANSMIT_ENTRY(TxPduId, PduInfoPtr);
    Dlt_BSWMasterContextPtr->EnterExclusiveArea();

    /* CHECK: NOPARSE */
    if (Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer == TRUE)
    /* CHECK: PARSE */
    {
#if(DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
      /* !LINKSTO Dlt.swdd.MultipleFramesTransmissionEnabled,1,
                  Dlt.swdd.MultipleFramesTransmissionDisabled,1 */
      Dlt_LastMessageLen[chnIdx] = Dlt_GetCurMessageLength(chnIdx, DLT_MESSAGE_BUFFER_SIZE);
      /* This pointer is not used but it must be valid. Thus we simply pass the
       * Dlt_MessageBuffer here. */
      PduInfoPtr->SduDataPtr = Dlt_MessageBuffer;
#else
      /* !LINKSTO Dlt.swdd.MultipleFramesTransmissionEnabled,1,
                  Dlt.swdd.MultipleFramesTransmissionDisabled,1  */
      Dlt_LastMessageLen[chnIdx] = Dlt_GetCurMessageLength(chnIdx, Dlt_CfgLogChannel[chnIdx].DltLogChannelBufferSize);
      /* This pointer is not used but it must be valid. Thus we simply pass the
       * Dlt_MessageBuffer here. */
      PduInfoPtr->SduDataPtr = Dlt_CfgLogChannel[chnIdx].DltMessageTxBuffer;
#endif
      Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmissionOngoing = TRUE;
      Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferTxIdx = Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx;
      PduInfoPtr->SduLength = Dlt_LastMessageLen[chnIdx];

      Dlt_BSWMasterContextPtr->ExitExclusiveArea();

      /* !LINKSTO Dlt.swdd.Communication.Interface, 1,
                  Dlt.ASR431.SWS_Dlt_00675, 1,
                  Dlt.ASR431.SWS_Dlt_00780, 1,
                  Dlt.ASR431.Ref_SWS_Dlt_00697_PduR_DltTransmit, 1 */
      if (PduR_DltTransmit(TxPduId, PduInfoPtr) == E_NOT_OK)
      {
        uint32 MsgLen = 0U;

        Dlt_BSWMasterContextPtr->EnterExclusiveArea();
#if (DLT_DISCARD_MSG_TX_FAIL == STD_ON)
        /* !LINKSTO Dlt.Transmit.DltDiscardMsgTxFail.Behavior.Enabled,1 */
        /* PduR_DltTransmit returns E_NOT_OK. The message shall be discarded -
           update the internal buffer and move the buffer index to the next entry in the
           buffer */
        MsgLen = (uint32)Dlt_LastMessageLen[chnIdx];
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        /* Move the tx index to the next entry in the buffer. */
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx = DLT_BUFFER_IDX(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx, MsgLen, Dlt_CfgLogChannel[chnIdx].DltLogChannelBufferSize);
#else
        /* Move the tx index to the next entry in the buffer. */
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx = DLT_BUFFER_IDX(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx, MsgLen, DLT_MESSAGE_BUFFER_SIZE);
#endif
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferTxIdx = Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx;
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        if ((Dlt_CfgLogChannel[chnIdx].DltLogChannelBufferSize == MsgLen) || (Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx == Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy) )
#else
        if ((DLT_MESSAGE_BUFFER_SIZE == MsgLen) || (Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx == Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy) )
#endif
        {
          /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00697_PduR_DltTransmit, 1 */
          Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer = FALSE;
        }
#else  /* (DLT_DISCARD_MSG_TX_FAIL == STD_ON) */
        /* !LINKSTO Dlt.Transmit.DltDiscardMsgTxFail.Behavior.Disabled,1 */
        /* PduR_DltTransmit returns E_NOT_OK. Internal buffer is not affected and
           message is not discarded */
        TS_PARAM_UNUSED(MsgLen);
#endif /* (DLT_DISCARD_MSG_TX_FAIL == STD_ON) */
        /* clear the flag indicating that a transmission is ongoing */
        Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmissionOngoing = FALSE;

        Dlt_BSWMasterContextPtr->ExitExclusiveArea();
      }
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      else
      {
        retVal = E_OK;
      }
#endif
    }
    /* CHECK: NOPARSE */
    else
    {
      /* Dlt_MainFunction calls Dlt_TriggerTransmit only if Dlt_MessageInBuffer is "true", never if "false".
       * Because of this, it is impossible to cover the false branch */
      DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_SID_TriggerTransmit);
      Dlt_BSWMasterContextPtr->ExitExclusiveArea();
    }
    /* CHECK: PARSE */
  }
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  DBG_DLT_TRIGGERTRANSMIT_EXIT_43(TxPduId, PduInfoPtr, retVal);
  return retVal;
#else
  DBG_DLT_TRIGGERTRANSMIT_EXIT(TxPduId, PduInfoPtr);
#endif
}

/*------------------[Dlt_GetCurMessageLength]-------------------------------*/
STATIC FUNC(Dlt_MsgLengthType, DLT_CODE) Dlt_GetCurMessageLength(Dlt_ChnIdTableIdxType chnIdx, uint32 BufferSize)
#if (DLT_ENABLE_MULTIPLE_FRAMES == STD_OFF)
/* !LINKSTO Dlt.swdd.MultipleFramesTransmissionDisabled,1 */
{
  Dlt_MsgLengthType retVal = 0U;

  DBG_DLT_GETCURMESSAGELENGTH_ENTRY(chnIdx, BufferSize);

  DLT_PRECONDITION_ASSERT(DLT_INSTANCE_ID, (Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer == TRUE), DLT_INTERNAL_API_ID);
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  /* Create the 16-bit length from DLT_LEN_HEADER_OFFSET (high byte) and
     DLT_LEN_HEADER_OFFSET+1 (low byte) in the message header */
  retVal =  DLT_GET_MESSAGE_LEN_LOG_CHN(chnIdx, Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx, BufferSize);
#else
  retVal = DLT_GET_MESSAGE_LEN(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx, BufferSize);
#endif
  DBG_DLT_GETCURMESSAGELENGTH_EXIT(retVal, chnIdx, BufferSize);

  return retVal;
}
#else /* (DLT_ENABLE_MULTIPLE_FRAMES == STD_ON) */
/* !LINKSTO Dlt.swdd.MultipleFramesTransmissionEnabled,1 */
{
  uint32 retVal = 0U;
  Dlt_MsgLengthType tmpLen = 0U;
  uint32 iterations = 0U;
  uint32 tmpMeIdx;
  uint32 tmpStIdx;
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  uint32 TmpMaxMsgLen;
#endif
  tmpMeIdx = Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx;
  tmpStIdx = Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy;

  DBG_DLT_GETCURMESSAGELENGTH_ENTRY(chnIdx, BufferSize);

#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  DLT_PRECONDITION_ASSERT(DLT_INSTANCE_ID, (Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer == TRUE), DLT_INTERNAL_API_ID);

  TmpMaxMsgLen = Dlt_CfgLogChannel[chnIdx].DltLogChannelMaxMessageLength;

  if((TmpMaxMsgLen == BufferSize) && (tmpMeIdx == tmpStIdx))
  {
    /* return value is equal to the buffer size*/
    retVal = BufferSize;
  }
  else
  {
    do
    {
      iterations++;
      retVal += tmpLen;
      tmpMeIdx = DLT_BUFFER_IDX(tmpMeIdx, tmpLen, BufferSize);
      tmpLen = DLT_GET_MESSAGE_LEN_LOG_CHN(chnIdx, tmpMeIdx, BufferSize);
    }while(((retVal+tmpLen) <= TmpMaxMsgLen) && ((tmpMeIdx != tmpStIdx)||(iterations == 1U)));
  }

#else
  DLT_PRECONDITION_ASSERT(DLT_INSTANCE_ID, (Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer == TRUE), DLT_INTERNAL_API_ID);
#if (DLT_MAX_MESSAGE_LENGTH == DLT_MESSAGE_BUFFER_SIZE)
  if(tmpMeIdx == tmpStIdx)
  {
    retVal = DLT_MESSAGE_BUFFER_SIZE;
  }
  else
#endif /* (DLT_MAX_MESSAGE_LENGTH == DLT_MESSAGE_BUFFER_SIZE) */
  {
    do
    {
      iterations++;
      retVal += tmpLen;
      tmpMeIdx = DLT_BUFFER_IDX(tmpMeIdx, tmpLen, BufferSize);
      tmpLen = DLT_GET_MESSAGE_LEN(tmpMeIdx, BufferSize);
    } while(((retVal+tmpLen) <= DLT_MAX_MESSAGE_LENGTH) && ((tmpMeIdx != tmpStIdx)||(iterations == 1U)));
  }
#endif /*if(DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)*/
  DBG_DLT_GETCURMESSAGELENGTH_EXIT(retVal, chnIdx, BufferSize);
  return (Dlt_MsgLengthType)retVal;
}
#endif

/*-----------------------------[Dlt_StoreInBuffer]------------------*/
STATIC FUNC(uint8, DLT_CODE) Dlt_StoreInBuffer(
    Dlt_ChnIdTableIdxType chnIdx,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) header,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) data,
    uint8 headerlen,
    Dlt_MsgLengthType datalen,
    uint32 storeindex)
{
  uint8 retVal = DLT_BUF_FULL;
  uint32 i;
  uint8 k;
  uint32 len;
  Dlt_MsgLengthType length;
  P2CONST(uint8, AUTOMATIC, AUTOMATIC) txdata;
  uint8 preconditionExit = FALSE;
  uint32 BufferSize;
  Dlt_MsgLengthType MsgLength;
  uint32 tempMsgLen;
  DBG_DLT_STOREINBUFFER_ENTRY(chnIdx, header, data, headerlen, datalen, storeindex);
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  BufferSize = Dlt_CfgLogChannel[chnIdx].DltLogChannelBufferSize;
#else
  BufferSize = DLT_MESSAGE_BUFFER_SIZE;
#endif
  /* Two iterations, 1st for the header, 2nd for the payload */
  for (k=0U; k<=1U; k++)
  {
    i=0U;
    if (k==0U)
    {
      txdata=header;
      length=headerlen;
    }
    else
    {
      txdata=data;
      length=datalen;
    }
    do
    {
      /* If currently the store pointer is below the read pointer but the
       * store pointer + length is above the read pointer, we will overflow
       * the buffer and have to move the read pointer to the next message.
       * We don't have to handle a wrap around of the store pointer here,
       * because this will be done automatically at the next iteration of
       * the outer do-while loop.
       */
      Dlt_BSWMasterContextPtr->EnterExclusiveArea();
       /* !LINKSTO SWS_Dlt_00053,1 */
      while(((Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer == TRUE) && (storeindex <= Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx)) &&
         ((storeindex + (length-i)) > Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx) && (preconditionExit == FALSE))
      {
        /* CHECK: NOPARSE */
        if((Dlt_StoreInterruptedCnt > 1U) && (Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx == Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy))
        {
          /* This unreachable branch eliminates inconsistent data if a concurrent access to the
           * function occurs (e.g Dlt_StoreInBuffer() interrupted by Dlt_MainFunction()).
           * This concurrent access cannot be verified easily. */
          DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_SID_SendLogMessage);

          Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer = FALSE;
        }
        /* CHECK: PARSE */
        else
        {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          MsgLength = DLT_GET_MESSAGE_LEN_LOG_CHN(chnIdx, Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx, BufferSize);
#else
          MsgLength = DLT_GET_MESSAGE_LEN(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx, BufferSize);
#endif
          tempMsgLen = (uint32)MsgLength;
          /* Move the read index to the next entry in the buffer. */
          Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx = DLT_BUFFER_IDX(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx, MsgLength, BufferSize);
          Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx = Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx;

          /* When the overflow situation occurs, the Dlt_MessageInBuffer is set to FALSE in order
           * to exit the loop which evaluates the overflow case. Once the overflow has been detected,
           * Dlt_MessageInBuffer = FALSE shall ensure that this loop is safely exited and in the end
           * Dlt_MessageInBuffer is set back to TRUE to signal the existence of messages in the Dlt
           * buffer */
          if ((Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx == Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdx) || (tempMsgLen == BufferSize)
              || (tempMsgLen == 0U))
          {
            preconditionExit = TRUE;
          }

          /* Signal the overflow to the caller */
          /* !LINKSTO SWS_Dlt_00297,1 */
          retVal = DLT_BUF_OVERFLOW;
        }
      }
      Dlt_BSWMasterContextPtr->ExitExclusiveArea();

      DBG_DLT_SENDPRIORITYREQUEST_ENTRY();

      /* Does the (remaining) message fit into the message buffer? If yes,
       * copy the message, if not copy only that part that fits and do a
       * wrap around. */
      if((storeindex + (length-i)) <= BufferSize)
      {
        len = length-i;
      }
      else
      {
        len = BufferSize - storeindex;
      }
      Dlt_BSWMasterContextPtr->EnterExclusiveArea();
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      /* !LINKSTO EB_Ref_Dlt.ASR431.SWS_Dlt_00650_STEP6,1 */
      TS_MemCpy(&Dlt_CfgLogChannel[chnIdx].DltMessageTxBuffer[storeindex], &txdata[i], len);
#else
      TS_MemCpy(&Dlt_MessageBuffer[storeindex], &txdata[i], len);
#endif
      Dlt_BSWMasterContextPtr->ExitExclusiveArea();

      DBG_DLT_SENDPRIORITYREQUEST_EXIT();

      i+=len;
      storeindex += len;

      /* If we reached the end of the buffer, wrap around */
      if (storeindex == BufferSize)
      {
        storeindex = 0U;
      }
    /* Continue if there are further data left to be copied */
    } while (i<length);
  }

  Dlt_BSWMasterContextPtr->EnterExclusiveArea();
  /* Decrement counter which protects the update of the Dlt_BufferStoreIdx */
  Dlt_StoreInterruptedCnt--;
  if (Dlt_StoreInterruptedCnt == 0)
  {
    /* Update global variable with the value of the copy global variable*/
    Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy = Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdx;
    Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreLengthCopy = (uint32)headerlen + datalen;
    Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer = TRUE;
  }
  Dlt_BSWMasterContextPtr->ExitExclusiveArea();

  DBG_DLT_STOREINBUFFER_EXIT(retVal, chnIdx, header, data, headerlen, datalen, storeindex);

  return retVal;
}

/*-----------------------------Dlt_InternalRegisterContext-------------------------*/
FUNC(Dlt_ReturnType, DLT_CODE) Dlt_InternalRegisterContext(
    Dlt_SessionIDType session_id,
    Dlt_Internal_ApplicationIDType app_id,
    Dlt_Internal_ContextIDType context_id,
    P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) CoreContext,
    P2CONST(uint8, DLT_CONST, DLT_CONST) AppDesc,
    uint8 AppDescLen,
    boolean OverwriteEntry)
{
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ReturnType ReturnValue = DLT_E_UNKNOWN_SESSION_ID;
#else
  Dlt_ReturnType ReturnValue = DLT_E_ERROR_UNKNOWN;
#endif

  if ((app_id != DLT_APP_ID_NULL ) && (context_id != DLT_CTX_ID_NULL))
  {
    boolean preconditionCheck = FALSE;
#if (DLT_SWC_SESSION_REGISTERED > 0U)
    Dlt_SessionIdTableIdxType SessionIdStartIdx = 0U;
#endif
    Dlt_BSWDistributionCommonType LocalCoreContext = Dlt_BSWMasterContextPtr->CoreContext;

    DBG_DLT_INTERNALREGISTERCONTEXT_ENTRY(session_id, app_id, context_id, CoreContext, AppDesc, AppDescLen, OverwriteEntry);

#if (DLT_SWC_SESSION_REGISTERED == 0U)
      TS_PARAM_UNUSED(session_id);
#endif /* (DLT_SWC_SESSION_REGISTERED > 0U) */

#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
    TS_PARAM_UNUSED(AppDesc);
    TS_PARAM_UNUSED(AppDescLen);
    if (session_id >= DLT_SWC_SESSION_ID_BASE)
    {
#if (DLT_SWC_SESSION_REGISTERED > 0U)
      /* The session Id is that of a SW-C, i.e. if the session Id is valid, the
       * Dlt_SessionIdTable already contains the corresponding entries */
      Dlt_FindSessionIDEntry(TRUE, session_id, &LocalCoreContext, &SessionIdStartIdx);

      /* The session Id is that of a SW-C, but not contained in the session Id
       * table. This can only happen if the port defined argument value mapping
       * went wrong. The SWS does not specify this case, so we call Det and return
       * DLT_E_UNKNOWN_SESSION_ID, which seems to be a reasonable error value.*/
      if (SessionIdStartIdx == DLT_SWC_SESSION_REGISTERED)
      {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_WRONG_PARAMETERS);
#endif /* (DLT_DEV_ERROR_DETECT == STD_ON) */
        ReturnValue = DLT_E_UNKNOWN_SESSION_ID;
      }
      else
      {
        preconditionCheck = TRUE;
      }
#else /* (DLT_SWC_SESSION_REGISTERED > 0) */
      /* The session Id is that of a SW-C, but no SW-Cs with Dlt connection exist. */
#if (DLT_DEV_ERROR_DETECT == STD_ON)
      DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_UNKNOWN_SESSION_ID);
#endif
      ReturnValue = DLT_E_UNKNOWN_SESSION_ID;
#endif /* (DLT_SWC_SESSION_REGISTERED > 0) */
    }
    else
#endif /*(DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)*/
    {
      preconditionCheck = TRUE;
    }
    /* Deviation TASKING-10 */
    if (preconditionCheck == TRUE)
    {
      boolean ContextIdIsIdentified;
      Dlt_ContextIdTableIdxType IdentifiedContextIdIdx = 0U;
      Dlt_ContextIdTableIdxType ContextIdsPerAppIdIdx = 0U;
      Dlt_AppIdTableIdxType AppIdStartIdx = 0U;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      Dlt_AppIdTableIdxType RegisteredAppIdsIdx;
#endif
      /* This will give us the entry in the AppId table if there exists one,
       * or the next free entry if there doesn't exist one already */
      Dlt_FindApplicationIDEntry(session_id, app_id, &LocalCoreContext, &AppIdStartIdx);

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      /* Find valid session in the pre-configured table
       * When this will be stored in the runtime variable Dlt_SessionIdTable, it will have the
       * index corresponding with the one from the configuration */
      Dlt_FindSessionIDEntry(FALSE, session_id, &LocalCoreContext, &SessionIdStartIdx);

      /* Search in the configuration table to find out how many contexts are
       * registered on the application id*/
      /* CHECK: NOPARSE */
      for (RegisteredAppIdsIdx = 0U; RegisteredAppIdsIdx < DLT_MAX_COUNT_APP_IDS; RegisteredAppIdsIdx++)
      {
        /* The application ID used in this function is always valid (because of prior checks), meaning that the DLT_MAX_COUNT_APP_IDS
         * will never be reached */
        /* CHECK: PARSE */
        if (app_id == Dlt_MaxCtxtPerApplication[RegisteredAppIdsIdx].DltSwCApplicationId)
        {
          ContextIdsPerAppIdIdx = Dlt_MaxCtxtPerApplication[RegisteredAppIdsIdx].CtxtNo;
          break;
        }
      }
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
      ContextIdsPerAppIdIdx = DLT_MAX_COUNT_CONTEXT_IDS_PER_APP_ID;
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

      Dlt_BSWMasterContextPtr->EnterExclusiveArea();
      ContextIdIsIdentified = Dlt_ContextIdIdentified(context_id, AppIdStartIdx, session_id, LocalCoreContext, &IdentifiedContextIdIdx);
      Dlt_BSWMasterContextPtr->ExitExclusiveArea();

      /* CHECK: NOPARSE */
      if ( (ContextIdIsIdentified == TRUE) && (OverwriteEntry == FALSE) )
      {
        /* This branch cannot be covered for true since the validation of a tuple - check if it is not registered already
         * and if it is part of the configuration - is done prior to the internal register process, meaning that only
         * valid non-registered contexts will reach this branch, and failing for the true check */
        ReturnValue = DLT_E_CONTEXT_ALREADY_REG;
      }
      /* CHECK: PARSE */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      else if ( (AppIdStartIdx == DLT_MAX_COUNT_APP_IDS) || (LocalCoreContext.AppToContextIdTableIdx[AppIdStartIdx] == ContextIdsPerAppIdIdx) )
#else
      else if ( (AppIdStartIdx == DLT_MAX_COUNT_APP_IDS) || (Dlt_AppToContextIdTableIdx[AppIdStartIdx] == ContextIdsPerAppIdIdx) )
#endif
      {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        DLT_DET_REPORT_ERROR(DLT_SID_RegisterContext, DLT_E_ERROR_TO_MANY_CONTEXT);
#endif
      }
      else
      {
        Dlt_ContextIdTableIdxType ContextIdIdx = 0U;
        Dlt_AppToContextIdTableIdxType AppToContextIdIdx = 0U;
        DLT_PRECONDITION_ASSERT(DLT_INSTANCE_ID, (AppIdStartIdx < DLT_MAX_COUNT_APP_IDS), DLT_INTERNAL_API_ID);

        /* If there is an entry in the AppIdTable, check if the context has already been registered or not */
        preconditionCheck = (Dlt_CheckForRegisteredContext(context_id, AppIdStartIdx, &ContextIdIdx, &AppToContextIdIdx) == FALSE);

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        /* If any valid applicationId/contextId tuple was found as being already registered
         * but the session index for the tuple is not matching with the session index in the runtime session table,
         * it means that the tuple was registered, but on another session */

        /* CHECK: NOPARSE */
        if ((preconditionCheck == FALSE) && (LocalCoreContext.ContextIdTable[ContextIdIdx].SessionIdTableIdx == DLT_NO_SESSION_ID))
        {
          /* DLT_NO_SESSION_ID is used for tuples registered under AR 4.2 only and this check is made under AR 4.3 which
           * makes it impossible to cover under Autosar 4.3. */
          preconditionCheck = TRUE;
          DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_SID_InternalRegisterContext);
        }
        /* CHECK: PARSE */
#endif /* DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431 */

        /* If all preconditions are ok save contextId and associated information: LogLevel and TraceStatus */
        /* CHECK: NOPARSE */
        if ( (preconditionCheck == TRUE) || (OverwriteEntry == TRUE) )
        /* CHECK: PARSE */
        {
          /* preconditionCheck will always be true at this point. In order to have preconditionCheck false we would have to have an already registered
           * context in the current function which is impossible since the registration process is validated prior to the call of the
           * internal register function  */
#if (DLT_IMPLEMENT_NV_RAM_STORAGE == STD_ON)
          uint8 chnidx;
          if (OverwriteEntry == TRUE)
          {
            LocalCoreContext.ContextIdTable[ContextIdIdx].LogLevel = CoreContext->ContextIdTable[0U].LogLevel;
            LocalCoreContext.ContextIdTable[ContextIdIdx].TraceStatus = CoreContext->ContextIdTable[0U].TraceStatus;
            LocalCoreContext.ContextIdTable[ContextIdIdx].VerboseMode = CoreContext->ContextIdTable[0U].VerboseMode;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
            /* Set Channels */
            for (chnidx = 0; chnidx < DLT_TXPDU_NO; chnidx++)
            {
              LocalCoreContext.ContextIdTable[ContextIdIdx].ChannelsIdx[chnidx] = CoreContext->ContextIdTable[0U].ChannelsIdx[chnidx];
            }
#else
            TS_PARAM_UNUSED(chnidx);
#endif
          }
          else
#endif
          {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
            Dlt_ContextIdTableIdxType ContextIdStartIdx = 0U;

            /* Find matching Tuple ApplicationId/ContextId in the preconfigured table */
            Dlt_FindCtxAppRegisteredTuple(SessionIdStartIdx, app_id, context_id, &ContextIdStartIdx);
            /* store in the table the session Id at the same index as the one in the configuration */
            Dlt_InternalRegisterContextStoreSessionId(&LocalCoreContext, session_id, SessionIdStartIdx, ContextIdIdx, ContextIdStartIdx);
#else
            LocalCoreContext.ContextIdTable[ContextIdIdx].LogLevel = *CoreContext->DefaultLogLevel;
            LocalCoreContext.ContextIdTable[ContextIdIdx].TraceStatus = *CoreContext->DefaultTraceStatus;
            LocalCoreContext.ContextIdTable[ContextIdIdx].VerboseMode = Dlt_HeaderUseVerboseMode;
#endif
          }
#if ( (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) && (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) )
          LocalCoreContext.ContextIdTable[ContextIdIdx].OsCoreId = CoreContext->ContextIdTable[0U].OsCoreId;
#endif /* #if ( (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) && (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) ) */
          /* !LINKSTO Dlt.ASR431.SWS_Dlt_00766,1 */
          LocalCoreContext.ContextIdTable[ContextIdIdx].ContextId = context_id;
#if(DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
#if (DLT_SWC_SESSION_REGISTERED > 0U)
          /* !LINKSTO SWS_Dlt_00021,1 */
          if (session_id >= DLT_SWC_SESSION_ID_BASE)
          {
            Dlt_BSWMasterContextPtr->EnterExclusiveArea();
            LocalCoreContext.ContextIdTable[ContextIdIdx].SessionIdTableIdx = SessionIdStartIdx;
            Dlt_BSWMasterContextPtr->ExitExclusiveArea();
          }
          else
#endif /* (DLT_SWC_SESSION_REGISTERED > 0U) */
          {
            Dlt_BSWMasterContextPtr->EnterExclusiveArea();
            LocalCoreContext.ContextIdTable[ContextIdIdx].SessionIdTableIdx = DLT_NO_SESSION_ID;
            Dlt_BSWMasterContextPtr->ExitExclusiveArea();
          }
#endif /*(DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)*/
#if (DLT_IMPLEMENT_NV_RAM_STORAGE == STD_ON)
          Dlt_BSWMasterContextPtr->EnterExclusiveArea();
          /* store index of the last registered applId*/
          Dlt_LastApplIdxRegistered = AppIdStartIdx;
          /* store index of the last registered ctxId to a given applId */
          Dlt_LastAppToCtxRefIdxRegistered = AppToContextIdIdx;
          Dlt_BSWMasterContextPtr->ExitExclusiveArea();
#endif
          if (preconditionCheck == TRUE)
          {
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
            /* Store the session_id and its position for the new table entry */
            LocalCoreContext.ContextIdTable[ContextIdIdx].SessionIdTableIdx = SessionIdStartIdx;
            LocalCoreContext.SessionIdTable[SessionIdStartIdx].SessionId = session_id;
#endif /* #if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

            /* Create a new entry */
            Dlt_InternalRegisterContextCreateNewEntry(session_id ,&LocalCoreContext, AppIdStartIdx, app_id, ContextIdIdx, AppToContextIdIdx);
            /* !LINKSTO  Dlt.ASR431.SWS_Dlt_00765,1 */
            /* register the length of the context description */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
            Dlt_BSWMasterContextPtr->EnterExclusiveArea();
            LocalCoreContext.ContextIdTable[ContextIdIdx].ContextDescription.CtxtDescLen = CoreContext->ContextIdTable->ContextDescription.CtxtDescLen;
            Dlt_AppIdTable[AppIdStartIdx].DltAppDescription.AppDescLen = AppDescLen;
            if ((AppDesc != NULL_PTR)&&(AppDescLen != 0U))
            {
              /* Register the application only if valid data are provided
               * If application description is null and length is 0, this means the application was already registered,
               * but another context id is wanted to be registered on the same application id*/
              TS_MemCpy(&Dlt_AppIdTable[AppIdStartIdx].DltAppDescription.AppDesc[0U], AppDesc, AppDescLen);
            }
            TS_MemCpy(&LocalCoreContext.ContextIdTable[ContextIdIdx].ContextDescription.CtxtDesc[0U],
                      &CoreContext->ContextIdTable->ContextDescription.CtxtDesc[0U],
                       LocalCoreContext.ContextIdTable[ContextIdIdx].ContextDescription.CtxtDescLen);
            Dlt_BSWMasterContextPtr->ExitExclusiveArea();
#endif /*(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)*/
          }
#if ( (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) && (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) )
          /* when the context is registered from an external client (API call),
            * trigger the synchronization */
          if (OverwriteEntry == FALSE)
          {
            Dlt_SendTablesToSatellites(DLT_ALL_SATELLITES);
          }
#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */
          ReturnValue = DLT_E_OK;
        }
        /* CHECK: NOPARSE */
        else
        {
          /* Context has already been registered */
          DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_SID_InternalRegisterContext);
          ReturnValue = DLT_E_CONTEXT_ALREADY_REG;
        }
        /* CHECK: PARSE */
      }
    }
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    if (DLT_E_OK != ReturnValue)
    {
      Dlt_BSWMasterContextPtr->EnterExclusiveArea();
      /* Reset Description and Length Description for Context in case registration cannot be done */
      LocalCoreContext.ContextIdTable[*LocalCoreContext.ContextIdTableIdx].ContextDescription.CtxtDescLen = 0U;
      TS_MemBZero(&LocalCoreContext.ContextIdTable[*LocalCoreContext.ContextIdTableIdx].ContextDescription.CtxtDesc[0U],
                  LocalCoreContext.ContextIdTable[*LocalCoreContext.ContextIdTableIdx].ContextDescription.CtxtDescLen);
      Dlt_BSWMasterContextPtr->ExitExclusiveArea();
    }
#endif /* DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431 */
  }

  DBG_DLT_INTERNALREGISTERCONTEXT_EXIT(ReturnValue, session_id, app_id, context_id, CoreContext, AppDesc, AppDescLen, OverwriteEntry);

  return ReturnValue;
}


/*-----------------------------[Dlt_ReadFromBuffer]------------------*/
STATIC FUNC(uint8, DLT_CODE) Dlt_ReadFromBuffer(
    Dlt_ChnIdTableIdxType chnIdx,
    P2VAR(uint8, AUTOMATIC, DLT_APPL_DATA) data,
    Dlt_MsgLengthType length, Dlt_MsgLengthType offset)
{
  uint8 retVal = DLT_BUF_FULL;
  Dlt_MsgLengthType i = 0U;
  Dlt_MsgLengthType MsgLen;
  uint32 BufferSize = 0U;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  BufferSize = Dlt_CfgLogChannel[chnIdx].DltLogChannelBufferSize;
#else
  BufferSize = DLT_MESSAGE_BUFFER_SIZE;
#endif
  DBG_DLT_READFROMBUFFER_ENTRY(chnIdx, data, offset);

  Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx = DLT_BUFFER_IDX(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx, offset, BufferSize);

  if (Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer == TRUE)
  {
    MsgLen = Dlt_GetCurMessageLength(chnIdx, BufferSize);

    if ( (length + offset) > MsgLen)
    {
      retVal = DLT_BUF_INVALID;
    }
    else
    {
      do
      {
        /* Is the message fully contained in the remaining message buffer?
         * If yes, copy the message, if not copy until the end of the buffer
         * and then do a wrap around. */
        if (((Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx + length) - i) <= BufferSize)
        {
          MsgLen = length - i;
        }
        else
        {
          MsgLen = (Dlt_MsgLengthType)(BufferSize - Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx);
        }
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        TS_MemCpy(&data[i], &Dlt_CfgLogChannel[chnIdx].DltMessageTxBuffer[Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx], MsgLen);
#else
        TS_MemCpy(&data[i], &Dlt_MessageBuffer[Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx], MsgLen);
#endif
        i+=MsgLen;
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx += MsgLen;

        /* If we reached the end of the buffer, wrap around */
        if (Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx == BufferSize)
        {
          Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferReadIdx = 0U;
        }
      /* Continue if there are further data left to be copied */
      } while(i<length);
    }
  }
  else
  {
    /* A transmission is ongoing only if there is a message in the ring
     * buffer (Dlt_MessageInBuffer = TRUE).*/
    retVal = DLT_BUF_EMPTY;
  }

  DBG_DLT_READFROMBUFFER_EXIT(retVal, chnIdx, data, offset);
  return retVal;
}

 /* !LINKSTO Dlt.swdd.Dlt_ReceiveMessageFromSatellite.BSW.Enable,1,
             Dlt.swdd.Dlt_ReceiveContextFromSatellite.BSW.Enable,1,
             Dlt.swdd.Dlt_ReceiveSessionIdFromSatellite.BSW.Enable,1,
             Dlt.swdd.Dlt_ReceiveTablesFromMaster.BSW.Enable,1 */
#if (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON)
/*-----------------------------[Dlt_InternalDispatchSendMessage]-----------*/
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_InternalDispatchSendMessage(
    P2CONST(boolean, AUTOMATIC, DLT_APPL_CONST) ChannelsIdx,
    Dlt_SessionIDType session_id,
    P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_CONST) msg_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) msg_data,
    Dlt_MsgLengthType msg_data_length,
    uint8 ServiceId,
    uint32 timestamp)
{
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ReturnType retVal = DLT_E_ERROR;
  boolean MessageWasSent = FALSE;
  uint8 chnIdx;
#else
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

  DBG_DLT_INTERNALDISPATCHMESSAGE_ENTRY(ChannelsIdx, session_id, msg_info, msg_data,
      msg_data_length, ServiceId, timestamp);

  /* !LINKSTO Dlt.swdd.DltCore.API.SendTraceMessage.MultiCorePassFilterCondition,1,
              Dlt.swdd.DltCore.API.SendLogMessage.MultiCoreArchitecture,1,
              Dlt.swdd.DltCore.API.SendLogMessage.CoreSpecificImplementation,1 */
  if(GetCoreID() == DLT_MASTER_CORE)
  {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    for (chnIdx = 0; chnIdx < DLT_TXPDU_NO; chnIdx++)
    {
      if (ChannelsIdx[chnIdx] == TRUE)
      {
        /* !LINKSTO Dlt.swdd.SendMessage.API.SendTraceMessage,1,
                    Dlt.swdd.DltCore.API.SendTraceMessage.MultiCoreMessageForwardREQ,1,
                    Dlt.swdd.DltCore.API.SendLogMessage.ForwardREQMulticore,1,
                    Dlt.swdd.SendMessage.API.SendLogMessage.ForwardREQ,1 */
        retVal = Dlt_InternalSendMessage(chnIdx, session_id, msg_info, msg_data,
                                         msg_data_length, ServiceId, timestamp);

        if (retVal == DLT_E_OK)
        {
          MessageWasSent = TRUE;
        }
      }
    }

    if (MessageWasSent == TRUE)
    {
      retVal = DLT_E_OK;
    }
#else
    retVal = Dlt_InternalSendMessage(0U, session_id, msg_info, msg_data,
            msg_data_length, ServiceId, timestamp);
    TS_PARAM_UNUSED(ChannelsIdx);
#endif
  }
  else
  {
    Std_ReturnType SchmSlaveSendMsg;
    Dlt_IOCSendMessageType Dlt_IOCSendMessage;
    Dlt_MsgLengthType MessageDataIndex;
    /* WARNING: SatelliteContextPtr is NULL_PTR on MASTER core */
    Dlt_BSWSatelliteContextPtrType SatelliteContextPtr = Dlt_GetSatelliteContextPtr();

    /* !LINKSTO Dlt.swdd.DltCore.API.SendTraceMessage.MultiCoreDispatchFromSlaveData,1,
                Dlt.swdd.DltCore.API.SendTraceMessage.MultiCoreDispatchFromSlaveLength,1,
                Dlt.swdd.DltCore.API.SendLogMessage.MultiCoreDispatchFromSatelite,1,
                Dlt.swdd.DltCore.API.SendLogMessage.MultiCoreMessageSend,1,
                Dlt.swdd.DltCore.API.SendTraceMessage.MultiCoreMessageFilteringDisabled,1 */
    Dlt_IOCSendMessage.session_id = session_id;
    Dlt_IOCSendMessage.msg_data_length = msg_data_length;
    Dlt_IOCSendMessage.ServiceId = ServiceId;
    Dlt_IOCSendMessage.timestamp = timestamp;

    Dlt_IOCSendMessage.msg_info.arg_count = msg_info->arg_count;
    Dlt_IOCSendMessage.msg_info.log_level_trace_info = msg_info->log_level_trace_info;
    Dlt_IOCSendMessage.msg_info.options = msg_info->options;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    TS_MemCpy(&Dlt_IOCSendMessage.msg_info.context_id, msg_info->context_id, sizeof(msg_info->context_id));
    TS_MemCpy(&Dlt_IOCSendMessage.msg_info.app_id, msg_info->app_id, sizeof(msg_info->app_id));
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
    Dlt_IOCSendMessage.msg_info.context_id = msg_info->context_id;
    Dlt_IOCSendMessage.msg_info.app_id = msg_info->app_id;
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    /* Prepare Message assigned channels */
    for (chnIdx = 0; chnIdx < DLT_TXPDU_NO; chnIdx++)
    {
      Dlt_IOCSendMessage.ChannelsIdx[chnIdx] = ChannelsIdx[chnIdx];
    }
#endif
    for (MessageDataIndex = 0U; MessageDataIndex < msg_data_length; MessageDataIndex++)
    {
      Dlt_IOCSendMessage.msg_data[MessageDataIndex] = msg_data[MessageDataIndex];
    }
    SchmSlaveSendMsg = SatelliteContextPtr->SlaveSendMessage(&Dlt_IOCSendMessage);

    /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.MultiCoreMessageSlaveReturnOK,1 */
    retVal = (SchmSlaveSendMsg != SCHM_E_OK) ? SCHM_E_LIMIT : DLT_E_OK;
  }

  DBG_DLT_INTERNALDISPATCHMESSAGE_EXIT(retVal, ChannelsIdx, session_id, msg_info, msg_data,
      msg_data_length, ServiceId, timestamp);
  return retVal;
}

/*-----------------------------[Dlt_ReceiveMessageFromSatellite]-----------*/
FUNC(void, DLT_CODE) Dlt_ReceiveMessageFromSatellite(void)
{
  Dlt_IOCSendMessageType Dlt_IOCSendMessage;
  Std_ReturnType ret = E_NOT_OK;
#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
  Dlt_ChnIdTableIdxType chnIdx = 0U;
#else
  Dlt_ChnIdTableIdxType chnIdx = DEFAULT_LOG_CHN_IDX;
#endif
  DBG_DLT_RECEIVEMESSAGEFROMSATELLITE_ENTRY();
  /* Receive message, unpack it, forward it to Dlt_InternalSendMessage() */
  do
  {
    /* !LINKSTO Dlt.swdd.ReceiveMessageFromSatellite.SchmCall,1 */
    ret = SchM_Receive_Dlt_MasterReceiveMessagePort(&Dlt_IOCSendMessage);

    if (ret == SCHM_E_OK)
    {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      for (chnIdx = 0U; chnIdx < DLT_TXPDU_NO; chnIdx++)
      {
        if (Dlt_IOCSendMessage.ChannelsIdx[chnIdx] == TRUE)
        {
          /* !LINKSTO Dlt.swdd.ReceiveMessageFromSatellite.API.MasterCore.ForwardMessage,1 */
          (void)Dlt_InternalSendMessage(chnIdx, Dlt_IOCSendMessage.session_id, &Dlt_IOCSendMessage.msg_info,
              (P2CONST(uint8, AUTOMATIC, DLT_APPL_DATA))&Dlt_IOCSendMessage.msg_data,
              Dlt_IOCSendMessage.msg_data_length, Dlt_IOCSendMessage.ServiceId,
              Dlt_IOCSendMessage.timestamp);
        }
      }
#else
      /* !LINKSTO Dlt.swdd.ReceiveMessageFromSatellite.API.MasterCore.ForwardMessage,1 */
      (void)Dlt_InternalSendMessage(chnIdx, Dlt_IOCSendMessage.session_id, &Dlt_IOCSendMessage.msg_info,
          (P2CONST(uint8, AUTOMATIC, DLT_APPL_DATA))&Dlt_IOCSendMessage.msg_data,
          Dlt_IOCSendMessage.msg_data_length, Dlt_IOCSendMessage.ServiceId,
          Dlt_IOCSendMessage.timestamp);
#endif
    }
  } while (ret == SCHM_E_OK);

  DBG_DLT_RECEIVEMESSAGEFROMSATELLITE_EXIT();
}

/*-----------------------------[Dlt_ReceiveContextFromSatellite]-----------*/
FUNC(void, DLT_CODE) Dlt_ReceiveContextFromSatellite(void)
{
  Std_ReturnType ret = E_NOT_OK;
  Dlt_IOCRegisterContextMessageType Dlt_IOCRegisterContextMessage;
  Dlt_BSWDistributionCommonType localCoreContext;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_BSWDistributionCommonType MasterCoreContext = Dlt_BSWMasterContextPtr->CoreContext;
#endif
  Dlt_ContextIdTableType LocalContextIdTable;
  uint32 LocalContextIdTableIdx;

  localCoreContext.ContextIdTableIdx  = &LocalContextIdTableIdx;
  localCoreContext.ContextIdTable     = &LocalContextIdTable;
  localCoreContext.DefaultLogLevel    = &Dlt_DefaultLogLevel;
  localCoreContext.DefaultTraceStatus = &Dlt_DefaultTraceStatus;
  localCoreContext.FilterMessages     = &Dlt_FilterMessages;

  /* !LINKSTO Dlt.swdd.ReceiveContextFromSatellite.API.OnMasterCoreReceiveRegisteredContext,1 */
  do
  {
    ret = SchM_Receive_Dlt_MasterReceiveContextMessagePort(&Dlt_IOCRegisterContextMessage);

    localCoreContext.ContextIdTable->LogLevel    = Dlt_IOCRegisterContextMessage.LogLevel;
    localCoreContext.ContextIdTable->TraceStatus = Dlt_IOCRegisterContextMessage.TraceStatus;
    localCoreContext.ContextIdTable->VerboseMode = Dlt_IOCRegisterContextMessage.VerboseMode;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    TS_MemCpy(&localCoreContext.ContextIdTable->ContextDescription.CtxtDesc[0U],
              &Dlt_IOCRegisterContextMessage.context_description[0U],
              Dlt_IOCRegisterContextMessage.len_context_description);
    localCoreContext.ContextIdTable->ContextDescription.CtxtDescLen = Dlt_IOCRegisterContextMessage.len_context_description;
    *localCoreContext.ContextIdTableIdx = Dlt_IOCRegisterContextMessage.contextIdTableIdx;
    localCoreContext.ContextIdTable->OsCoreId = Dlt_IOCRegisterContextMessage.OsCoreId;
#endif
    if(ret == SCHM_E_OK)
    {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      if (Dlt_IOCRegisterContextMessage.register_or_unregister == DLT_IS_REGISTER)
      {
        /* !LINKSTO Dlt.swdd.ReceiveContextFromSatellite.API.OnMasterCoreForwardInformation,1 */
        (void)Dlt_InternalRegisterContext(
            Dlt_IOCRegisterContextMessage.session_id,
            Dlt_IOCRegisterContextMessage.app_id,
            Dlt_IOCRegisterContextMessage.context_id,
            &localCoreContext,
            &Dlt_IOCRegisterContextMessage.app_description[0U],
            Dlt_IOCRegisterContextMessage.len_app_description,
            FALSE
          );
      }
      else
      {
        (void)Dlt_InternalUnregisterContext(
            Dlt_IOCRegisterContextMessage.OsCoreId,
            Dlt_IOCRegisterContextMessage.session_id,
            Dlt_IOCRegisterContextMessage.app_id,
            Dlt_IOCRegisterContextMessage.context_id,
            &MasterCoreContext);
      }
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
      /* !LINKSTO Dlt.swdd.ReceiveContextFromSatellite.API.OnMasterCoreForwardInformation,1 */
      (void)Dlt_InternalRegisterContext(
          Dlt_IOCRegisterContextMessage.session_id,
          Dlt_IOCRegisterContextMessage.app_id,
          Dlt_IOCRegisterContextMessage.context_id,
          &localCoreContext,
          NULL_PTR,
          0U,
          FALSE
        );
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
    }
  } while (ret == SCHM_E_OK);

}

/*-----------------------------[Dlt_ReceiveSessionIdFromSatellite]-----------*/
/* !LINKSTO Dlt.swdd.Dlt_ReceiveSessionIdFromSatellite.API.NvM.Enable,1 */
#if (DLT_IMPLEMENT_NV_RAM_STORAGE == STD_ON)
/* !LINKSTO Dlt_ReceiveSessionIdFromSatellite,1 */
FUNC(void, DLT_CODE) Dlt_ReceiveSessionIdFromSatellite(void)
{
  Dlt_SessionIDType session_id = 0U;
  Std_ReturnType ret = E_NOT_OK;
  do
  {
    /* !LINKSTO Dlt.swdd.ReceiveSessionIdFromSatellite.API.OnMasterCoreReceiveSessionId,1 */
    ret = SchM_Receive_Dlt_MasterReceiveSessionIdPort(&session_id);

    if (ret == SCHM_E_OK)
    {
      /* !LINKSTO Dlt.swdd.ReceiveSessionIdFromSatellite.API.OnMasterCoreStorePersistent,1 */
#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
      (void)Dlt_StorePersistent(session_id);
#else /* DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431 */
      TS_PARAM_UNUSED(session_id);
      (void)Dlt_StoreConfiguration();
#endif /* DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431 */
    }
  } while (ret == SCHM_E_OK);
}
#endif /* (DLT_IMPLEMENT_NV_RAM_STORAGE == STD_ON) */

/*-----------------------------[Dlt_SendTablesToSatellites]-----------*/
FUNC(void, DLT_CODE) Dlt_SendTablesToSatellites(uint8 SatelliteIndex)
{
  /* !LINKSTO Dlt.swdd.SendTablesToSatellites.API.EnableMulticore,1 */
  Dlt_IOCSyncTableType Dlt_IOCSyncTable;
  Dlt_ContextIdTableIdxType i;

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ChnIdTableIdxType chnIdx;
#endif

  DBG_DLT_SENDTABLESTOSATELLITES_ENTRY();

  /* Make sure that the array index (SatelliteIndex) is never out-of-bounds */
  DLT_PRECONDITION_ASSERT(DLT_INSTANCE_ID,
                          ((SatelliteIndex < DLT_NUMBER_OF_SATELLITES) ||
                           (SatelliteIndex == DLT_ALL_SATELLITES)),
                          DLT_INTERNAL_API_ID);

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_IOCSyncTable.MaxRegisteredAppldTableEntry = *Dlt_BSWMasterContextPtr->CoreContext.MaxRegisteredAppldTableEntry;
#endif
  Dlt_IOCSyncTable.numberOfContextIds = *Dlt_BSWMasterContextPtr->CoreContext.ContextIdTableIdx;
  Dlt_IOCSyncTable.defaultLogLevel = *Dlt_BSWMasterContextPtr->CoreContext.DefaultLogLevel;
  Dlt_IOCSyncTable.defaultTraceStatus = *Dlt_BSWMasterContextPtr->CoreContext.DefaultTraceStatus;
  Dlt_IOCSyncTable.filterMessageStatus = *Dlt_BSWMasterContextPtr->CoreContext.FilterMessages;
  i = 0U;
  do{
    Dlt_IOCSyncTable.ContextIdTable[i].ContextId =
      Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[i].ContextId;
    Dlt_IOCSyncTable.ContextIdTable[i].LogLevel =
      Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[i].LogLevel;
    Dlt_IOCSyncTable.ContextIdTable[i].VerboseMode =
      Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[i].VerboseMode;
    Dlt_IOCSyncTable.ContextIdTable[i].TraceStatus =
      Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[i].TraceStatus;
    Dlt_IOCSyncTable.ContextIdTable[i].SessionIdTableIdx =
      Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[i].SessionIdTableIdx;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
    Dlt_IOCSyncTable.ContextIdTable[i].OsCoreId = Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[i].OsCoreId;
    /* copy also description for each context */
    Dlt_IOCSyncTable.ContextIdTable[i].ContextDescription.CtxtDescLen = Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[i].ContextDescription.CtxtDescLen;
    Dlt_IOCSyncTable.ContextIdTable[i].Flags = Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[i].Flags;
    TS_MemCpy(&Dlt_IOCSyncTable.ContextIdTable[i].ContextDescription.CtxtDesc,
        Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[i].ContextDescription.CtxtDesc,sizeof(Dlt_IOCSyncTable.ContextIdTable[i].ContextDescription.CtxtDesc));
    for (chnIdx = 0; chnIdx < DLT_TXPDU_NO; chnIdx ++)
    {
      Dlt_IOCSyncTable.ContextIdTable[i].ChannelsIdx[chnIdx] = Dlt_BSWMasterContextPtr->CoreContext.ContextIdTable[i].ChannelsIdx[chnIdx];
    }
#endif /* (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
    i++;
  } while(i < (*Dlt_BSWMasterContextPtr->CoreContext.ContextIdTableIdx));

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  i = 0U;

  do{
    Dlt_IOCSyncTable.AppIdTable[i].AppId = Dlt_BSWMasterContextPtr->CoreContext.AppIdTable[i].AppId;
    TS_MemCpy(&Dlt_IOCSyncTable.AppIdTable[i].DltAppDescription.AppDesc,
        Dlt_BSWMasterContextPtr->CoreContext.AppIdTable[i].DltAppDescription.AppDesc,
        sizeof(Dlt_IOCSyncTable.AppIdTable[i].DltAppDescription.AppDesc));
    Dlt_IOCSyncTable.AppIdTable[i].DltAppDescription.AppDescLen =
        Dlt_BSWMasterContextPtr->CoreContext.AppIdTable[i].DltAppDescription.AppDescLen;

    i++;
  } while(i < (*Dlt_BSWMasterContextPtr->CoreContext.MaxRegisteredAppldTableEntry));

  i = 0U;

  do{
    Dlt_IOCSyncTable.SessionIdTable[i].SessionId = Dlt_BSWMasterContextPtr->CoreContext.SessionIdTable[i].SessionId;

    i++;
  } while(i < DLT_SWC_REGISTERED_NO);
#endif


  for (SatelliteIndex = 0U; SatelliteIndex < DLT_NUMBER_OF_SATELLITES; SatelliteIndex++)
  {
    if (Dlt_BSWMasterContextPtr->MasterSendSyncTable[SatelliteIndex](&Dlt_IOCSyncTable) != SCHM_E_OK)
    {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
      /* Signal core synchronization failure */
      DLT_DET_REPORT_ERROR(DLT_INTERNAL_API_ID, DLT_E_CORE_SYNC_FAILED);
#endif /* (DLT_DEV_ERROR_DETECT == STD_ON) */
    }
  }

  DBG_DLT_SENDTABLESTOSATELLITES_EXIT();
}

/*-----------------------------[Dlt_ReceiveTablesFromMaster]-----------*/
FUNC(void, DLT_CODE) Dlt_ReceiveTablesFromMaster(void)
{
  Dlt_IOCSyncTableType Dlt_IOCSyncTable;
  Dlt_ContextIdTableIdxType i = 0U;
  Std_ReturnType ret;
  boolean rcvFlag = FALSE;
  Dlt_BSWSatelliteContextPtrType SatelliteContextPtr = Dlt_GetSatelliteContextPtr();
  Dlt_BSWDistributionCommonType SatelliteCoreContext = SatelliteContextPtr->CoreContext;
  DBG_DLT_RECEIVETABLESFROMMASTER_ENTRY();

  /* We are only interested in the latest update of the tables */
  do
  {
    ret = SatelliteContextPtr->SlaveReceiveSyncTable(&Dlt_IOCSyncTable);

    if(ret == SCHM_E_OK)
    {
      rcvFlag = TRUE;
    }

  } while(ret == SCHM_E_OK);

  /* CHECK: NOPARSE */
  if (rcvFlag == TRUE)
  /* CHECK: PARSE */
  {
    /* The fact that this branch is not covered for false does not involve any functional issue. In all situations data should be correctly received. */

    /* Update local copies of the default settings */
    *(SatelliteCoreContext.DefaultLogLevel)    = Dlt_IOCSyncTable.defaultLogLevel;
    *(SatelliteCoreContext.DefaultTraceStatus) = Dlt_IOCSyncTable.defaultTraceStatus;
    *(SatelliteCoreContext.FilterMessages)     = Dlt_IOCSyncTable.filterMessageStatus;
#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
    *(SatelliteCoreContext.ContextIdTableIdx)  = Dlt_IOCSyncTable.numberOfContextIds;
#endif

    /* Loop over all assigned context ids */
    do{

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      /* Check if the tuple is relevant for this CoreId */
      if (GetCoreID() == Dlt_IOCSyncTable.ContextIdTable[i].OsCoreId)
#endif
      {
        Dlt_ContextIdTableIdxType idx;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        /* Check if the context was registered and it's only necessary to update ContextIdTable */
        Dlt_AppIdTableIdxType aIdx = 0U;
        Dlt_ContextIdTableIdxType CitIdx = 0U;
        Dlt_AppToContextIdTableIdxType ApplToCtxIdx = 0U;
        Dlt_ContextIdTableIdxType IdentifiedContextIdIdx = 0U;
        boolean TupleIdentified;
        uint8 chnIdx = 0U;

        Dlt_FindApplicationIDEntry(Dlt_IOCSyncTable.SessionIdTable[Dlt_IOCSyncTable.ContextIdTable[i].SessionIdTableIdx].SessionId,
                                   Dlt_IOCSyncTable.AppIdTable[i].AppId,
                                   &SatelliteCoreContext,
                                   &aIdx);

        TupleIdentified = Dlt_ContextIdIdentified(Dlt_IOCSyncTable.ContextIdTable[i].ContextId,
                                                  aIdx,
                                                  Dlt_IOCSyncTable.SessionIdTable[Dlt_IOCSyncTable.ContextIdTable[i].SessionIdTableIdx].SessionId,
                                                  SatelliteCoreContext,
                                                  &IdentifiedContextIdIdx);

        (void)Dlt_CheckForRegisteredContext(Dlt_IOCSyncTable.ContextIdTable[i].ContextId, aIdx, &CitIdx, &ApplToCtxIdx);

#endif
#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
        idx = i;
#else
        idx = CitIdx;

        if ( TupleIdentified == TRUE )
#endif
        {
          SatelliteCoreContext.ContextIdTable[idx].ContextId = Dlt_IOCSyncTable.ContextIdTable[i].ContextId;
          SatelliteCoreContext.ContextIdTable[idx].SessionIdTableIdx = Dlt_IOCSyncTable.ContextIdTable[i].SessionIdTableIdx;
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          for (chnIdx = 0; chnIdx < DLT_TXPDU_NO; chnIdx ++)
          {
            SatelliteCoreContext.ContextIdTable[idx].ChannelsIdx[chnIdx] =  Dlt_IOCSyncTable.ContextIdTable[i].ChannelsIdx[chnIdx];
          }
#endif
#if(DLT_SWC_SESSION_REGISTERED > 0)
          /* !LINKSTO Dlt.swdd.ReceiveTablesFromMaster.API.OnSlaveCore,1 */
          /* Has the log level changed? */
          /* Update local copy of the context table */
          SatelliteCoreContext.ContextIdTable[idx].LogLevel = Dlt_IOCSyncTable.ContextIdTable[i].LogLevel;
          /* Update local copy of the context table */
          SatelliteCoreContext.ContextIdTable[idx].TraceStatus = Dlt_IOCSyncTable.ContextIdTable[i].TraceStatus;
          /* Update local copy of the context table */
          SatelliteCoreContext.ContextIdTable[idx].VerboseMode = Dlt_IOCSyncTable.ContextIdTable[i].VerboseMode;
#else /* (DLT_SWC_SESSION_REGISTERED > 0) */
          SatelliteCoreContext.ContextIdTable[idx].LogLevel = Dlt_IOCSyncTable.ContextIdTable[i].LogLevel;
          SatelliteCoreContext.ContextIdTable[idx].TraceStatus = Dlt_IOCSyncTable.ContextIdTable[i].TraceStatus;
          SatelliteCoreContext.ContextIdTable[idx].VerboseMode = Dlt_IOCSyncTable.ContextIdTable[i].VerboseMode;
#endif /* (DLT_SWC_SESSION_REGISTERED > 0) */
        }
#if(DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
        else
        {
          Dlt_SessionIdTableIdxType SessionIdIdx = 0U;
          Dlt_ContextIdTableIdxType ContextIdStartIdx = 0U;

          Dlt_FindSessionIDEntry(FALSE, Dlt_IOCSyncTable.SessionIdTable[i].SessionId, &SatelliteCoreContext, &SessionIdIdx);

          /* CHECK: NOPARSE */
          if (SessionIdIdx != DLT_SWC_REGISTERED_NO)
          /* CHECK: PARSE */
          {
            /* Find matching Tuple ApplicationId/ContextId in the pre-configured table */
            Dlt_FindCtxAppRegisteredTuple(SessionIdIdx, Dlt_IOCSyncTable.AppIdTable[i].AppId, Dlt_IOCSyncTable.ContextIdTable[i].ContextId, &ContextIdStartIdx);

            (void)Dlt_InternalRegisterLocalContext(Dlt_IOCSyncTable.SessionIdTable[Dlt_IOCSyncTable.ContextIdTable[i].SessionIdTableIdx].SessionId,
                                             Dlt_IOCSyncTable.AppIdTable[i].AppId,
                                             Dlt_IOCSyncTable.ContextIdTable[i].ContextId,
                                             &SatelliteCoreContext,
                                             NULL_PTR,
                                             0U,
                                             SessionIdIdx,
                                             ContextIdStartIdx);
          }
          /* CHECK: NOPARSE */
          else
          {
            /* The master core validates all data before sending it to the satellite cores.
             * The search for the SessionId in the pre-configured table shall always result in a valid SessionIdIdx. */
            DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_INTERNAL_API_ID);
          }
          /* CHECK: PARSE */
        }
        /* copy also description for each context */
        SatelliteCoreContext.ContextIdTable[idx].ContextDescription.CtxtDescLen = Dlt_IOCSyncTable.ContextIdTable[i].ContextDescription.CtxtDescLen;
        TS_MemCpy(&SatelliteCoreContext.ContextIdTable[idx].ContextDescription.CtxtDesc,
          Dlt_IOCSyncTable.ContextIdTable[i].ContextDescription.CtxtDesc,sizeof(SatelliteCoreContext.ContextIdTable[idx].ContextDescription.CtxtDesc));
#endif
      }
      i++;
    }while(i<*(SatelliteCoreContext.ContextIdTableIdx));
  }
  /* CHECK: NOPARSE */
  else
  {
    DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_INTERNAL_API_ID);
  }
  /* CHECK: PARSE */

  DBG_DLT_RECEIVETABLESFROMMASTER_EXIT();
}

FUNC_P2CONST(Dlt_BSWSatelliteContextType, AUTOMATIC, DLT_CODE) Dlt_GetSatelliteContextPtr(void)
{
  Dlt_BSWSatelliteContextPtrType ContextPointer = NULL_PTR;
  CoreIdType coreId = GetCoreID();
  uint8 iterator = 0U;

  for (iterator = 0U; iterator < DLT_NUMBER_OF_SATELLITES; iterator++)
  {
    /* The for loop cannot reach DLT_NUMBER_OF_SATELLITES since an invalid core ID cannot be returned by GetCoreID() */
    if (coreId == Dlt_BSWSatelliteContextTable[iterator].OsCoreId)
    {
      ContextPointer = &(Dlt_BSWSatelliteContextTable[iterator]);
    }
  }

  /* This function should be called only from satellite context, so it must not return NULL_PTR */
  DLT_PRECONDITION_ASSERT(DLT_INSTANCE_ID, (ContextPointer != NULL_PTR), DLT_INTERNAL_API_ID);

  return ContextPointer;
}

#endif /* (DLT_ENABLE_BSW_DISTRIBUTION == STD_ON) */

/*-----------------------------[Dlt_InternalSendMessage]------------------*/
/* !LINKSTO SWS_Dlt_00467,1, SWS_Dlt_00005,1 */
FUNC(Dlt_ReturnType, DLT_CODE) Dlt_InternalSendMessage(
    Dlt_ChnIdTableIdxType chnIdx,
    Dlt_SessionIDType session_id,
    P2CONST(Dlt_MessageCommonInfoType, AUTOMATIC, DLT_APPL_CONST) msg_info,
    P2CONST(uint8, AUTOMATIC, DLT_APPL_CONST) msg_data,
    Dlt_MsgLengthType msg_data_length,
    uint8 ServiceId,
    uint32 timestamp)
{
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ReturnType retVal = DLT_E_ERROR;
#else
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
#endif
  uint8 Dlt_NextHeaderFieldIdx = DLT_MIN_HEADER_LENGTH; /* Minimum length of the header */
  uint8 Dlt_LocalHeaderBuffer[DLT_MAX_HEADER_LENGTH];
  uint8 Dlt_LocalHeaderLength;
  uint32 Dlt_LocalStoreIdx;
  Dlt_MsgLengthType Dlt_LocalMessageLength;

  DBG_DLT_INTERNALSENDMESSAGE_ENTRY(chnIdx, session_id, msg_info, msg_data, msg_data_length, ServiceId, timestamp);

#if (DLT_DEV_ERROR_DETECT == STD_OFF)
  TS_PARAM_UNUSED(ServiceId);
#endif

  Dlt_BSWMasterContextPtr->EnterExclusiveArea();
  Dlt_LocalStoreIdx = Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdx;
#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
  TS_PARAM_UNUSED(chnIdx);
#endif

  Dlt_LocalHeaderLength = Dlt_HeaderLength;
  Dlt_LocalMessageLength = Dlt_LocalHeaderLength + msg_data_length;
  /* HTYP field
   * These flags must be set in the exclusive area, because they could be
   * changed by concurrent calls to the Dlt control API. */
  /* !LINKSTO SWS_Dlt_00082,1, SWS_Dlt_00301,1, SWS_Dlt_00302,1, SWS_Dlt_00458,1,
              SWS_Dlt_00094,1, SWS_Dlt_00408,1 */
  Dlt_LocalHeaderBuffer[DLT_HTYP_HEADER_OFFSET] = Dlt_HeaderUseExtendedHeader
                                                  | Dlt_HeaderUseEcuId
                                                  | Dlt_HeaderUseSessionID
#if (DLT_IMPLEMENT_TIMESTAMP != STD_OFF)
                                                  | Dlt_HeaderUseTimestamp
#endif /* DLT_IMPLEMENT_TIMESTAMP != STD_OFF */
                                                  ;


#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
  retVal = Dlt_CheckBuffer(chnIdx,
                           Dlt_LocalMessageLength,
                           DLT_MAX_MESSAGE_LENGTH,
                           DLT_MESSAGE_BUFFER_SIZE,
                           Dlt_LocalStoreIdx);
#else
  retVal = Dlt_CheckBuffer(chnIdx,
                           Dlt_LocalMessageLength,
                           Dlt_CfgLogChannel[chnIdx].DltLogChannelMaxMessageLength,
                           Dlt_CfgLogChannel[chnIdx].DltLogChannelBufferSize,
                           Dlt_LocalStoreIdx);
#endif
  Dlt_BSWMasterContextPtr->ExitExclusiveArea();

  /* The message cannot be stored in the buffer. */
  if (retVal != DLT_E_OK)
  {
#if (DLT_DEV_ERROR_DETECT == STD_ON)
    /* !LINKSTO Dlt.swdd.SendMessage.API.SendLogMessage.ServiceId.DET,1 */
    DLT_DET_REPORT_ERROR(ServiceId, DLT_E_WRONG_PARAMETERS);
#endif /* (DLT_DEV_ERROR_DETECT == STD_ON) */
  }
  /* Everything is fine, so we prepare the message header and store the message
   * in the circular buffer. Further locking is no longer necessary, as we work
   * on local data only. */
  else
  {
    /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00651_MessageHeaderSettings, 1 */
    /* Create the standard header fields in Dlt_LocalHeaderBuffer */
    Dlt_CreateStandardHeader(chnIdx, session_id, Dlt_LocalHeaderBuffer,
      &Dlt_NextHeaderFieldIdx, Dlt_LocalMessageLength, timestamp);

#if (DLT_IMPLEMENT_EXTENDED_HEADER == STD_ON)
    /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00651_MessageHeaderSettings, 1 */
    /* Create the extended header fields in Dlt_LocalheaderBuffer */
    Dlt_CreateExtendedHeader(msg_info, Dlt_LocalHeaderBuffer,
      &Dlt_NextHeaderFieldIdx);
#else
    TS_PARAM_UNUSED(msg_info);
#endif /* (DLT_IMPLEMENT_EXTENDED_HEADER == STD_ON) */


    /* Store the header and the payload in the circular buffer.*/
    /* !LINKSTO Dlt.DltCore.StoreIncommingMsgToDlt,1, SWS_Dlt_00080,1, SWS_Dlt_00298,1,
                SWS_Dlt_00089,1, SWS_Dlt_00467,1, SWS_Dlt_00314,1, SWS_Dlt_00315,1,
                SWS_Dlt_00409,1, SWS_Dlt_00052,1, Dlt.ASR431.SWS_Dlt_00685, 1 */
    if (Dlt_StoreInBuffer(chnIdx, Dlt_LocalHeaderBuffer, msg_data, Dlt_LocalHeaderLength,
         msg_data_length, Dlt_LocalStoreIdx) == DLT_BUF_OVERFLOW)
    {
        /* !LINKSTO SWS_Dlt_00314,1, SWS_Dlt_00315,1 */
#if (DLT_DEV_ERROR_DETECT == STD_ON)
        /* !LINKSTO EB_Req_Dlt_SendInternalMessage.BufferOverwritten,1 */
        /* !LINKSTO Dlt.swdd.SendMessage.API.SendTraceMessage.ServiceIdDET,1 */
        DLT_DET_REPORT_ERROR(ServiceId, DLT_E_MSG_LOOSE);
#endif
    }
  }

  DBG_DLT_INTERNALSENDMESSAGE_EXIT(retVal, chnIdx, session_id, msg_info, msg_data, msg_data_length, ServiceId, timestamp);
  return retVal;
}

/*-----------------------------[Dlt_CheckBuffer]------------------*/
/* !LINKSTO Dlt.swdd.CheckBuffer.Functionality,1,
            Dlt.swdd.CheckBuffer.Prototype,1 */
STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_CheckBuffer(
    uint8 chnIdx,
    Dlt_MsgLengthType MsgLen,
    Dlt_MsgLengthType MaxMsgLen,
    uint32 BufferSize,
    uint32 StoreIdx)
{
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  Dlt_ReturnType retVal = DLT_E_ERROR;
#else
  Dlt_ReturnType retVal = DLT_E_ERROR_UNKNOWN;
#endif

  DBG_DLT_CHECKBUFFER_ENTRY(chnIdx, MsgLen, MaxMsgLen, BufferSize, StoreIdx);
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  if(MsgLen > BufferSize)
  {
    /* !LINKSTO Dlt.ASR431.Ref_SWS_Dlt_00670_LogChannel_NoBuffer,1 */
    retVal = DLT_E_NO_BUFFER;
  }
  else
#endif
  {
    /* !LINKSTO SWS_Dlt_00351,1, SWS_Dlt_00081,1, Dlt.ASR431.SWS_Dlt_00669,1, EB_Ref_Dlt.ASR431.SWS_Dlt_00650_STEP4,1*/
    if (MsgLen > MaxMsgLen)
    {
      retVal = DLT_E_MSG_TOO_LARGE;
    }
    else
    {
      uint32 LocalMessageLength = (uint32) MsgLen;
      uint32 LocalNextStoreIdx = DLT_BUFFER_IDX(StoreIdx, MsgLen,BufferSize);

      Dlt_BSWMasterContextPtr->EnterExclusiveArea();
      /* A transmission is currently ongoing, so let's check whether we are about
       * to overflow the buffer of the message in transmission */
      if (Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmissionOngoing == TRUE)
      {
        if (( StoreIdx <= Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferTxIdx ) &&
             (( LocalNextStoreIdx < StoreIdx) ||
               ( LocalMessageLength == BufferSize))
            )
        {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          retVal = DLT_E_NO_BUFFER;
#else
          retVal = DLT_E_IF_BUSY;
#endif
        }
        else if (( LocalNextStoreIdx < StoreIdx ) &&
                  ( LocalNextStoreIdx > Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferTxIdx ))
        {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          retVal = DLT_E_NO_BUFFER;
#else
          retVal = DLT_E_IF_BUSY;
#endif
        }
        else if (( StoreIdx <= Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferTxIdx ) &&
                  (( LocalNextStoreIdx > Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferTxIdx ) ||
                    (LocalMessageLength == BufferSize)) )
        {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          retVal = DLT_E_NO_BUFFER;
#else
          retVal = DLT_E_IF_BUSY;
#endif
        }
        else
        {
          /* no corruption detected */
        }
      }
      /* At least one store request is currently ongoing, therefore a check is performed in
       * order to detect if an overflow occurs for the first interrupted store request which
       * has been previously triggered */

      /* !LINKSTO Dlt.Messages.InterruptionBufferOverwrite, 1 */
      if (Dlt_StoreInterruptedCnt != 0U)
      {
        boolean conflictFound = FALSE;
        if ( (( LocalNextStoreIdx < StoreIdx ) && (( StoreIdx <= Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy ) ||
                                                   ( Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy < LocalNextStoreIdx ))) ||
             (( StoreIdx <= Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy ) && ( Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy < LocalNextStoreIdx)))
        {
          conflictFound = TRUE;
        }

        /* Check that the interrupted message (not this one - this is the message that interrupted that one)
         * will not require Dlt_BufferMsgIdx to be moved
         *
         * SI is the original message store index (by original meaning the message that is being interrupted)
         */

        /* Situation 1
         *
         * StoreIndex (SI) < MessageIndex (MI)
         * StoreIndex (SI) + Length To be stored > MessageIndex (MI)
         *
         * 0-----SI-------MI------------------------END
         *
         */
        if ((Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy < Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx) &&
           ((Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy + Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreLengthCopy) > Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx))
        {
          conflictFound = TRUE;
        }
        /* Situation 2
         *
         * StoreIndex (SI) > MessageIndex (MI) AND
         * StoreIndex (SI) + Length To be stored  > MessageIndex (MI) AND Overflow
         *
         * 0-----MI----------------------------SI---END
         *
         */
        if (((Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy > Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx) &&
           (DLT_BUFFER_IDX(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy, Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreLengthCopy, BUFFER_SIZE) > Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx)) &&
         ((Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy + Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreLengthCopy) >= BUFFER_SIZE))
        {
          conflictFound = TRUE;
        }
        /* Situation 3
         *
         * StoreIndex (SI) < MessageIndex (MI) AND
         * StoreIndex (SI) + Length To be stored < MessageIndex (MI) AND Overflow
         *
         * 0---------------------------------SI-MI--END
         *
         */
        if (((Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy < Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx) &&
           (DLT_BUFFER_IDX(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy, Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreLengthCopy, BUFFER_SIZE) < Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx)) &&
         ((Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy + Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreLengthCopy) >= StoreIdx))
        {
          conflictFound = TRUE;
        }
        if (
             /* Situation 4
              * The previous 3 situations cover the case only for the first message interrupted,
              * but we might end up (and we do) with the second message overflowing
              * the MessageIndex (MI) and that one being interrupted by the third one and,
              * therefore, the previous checks will not detect that.
              * We reject all messages that keep interrupting the original message. I.e. not
              * allowing multiple interrupts
              */
             /* !LINKSTO Dlt.Messages.MultipleInterrupts, 1 */
             ((Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy + Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreLengthCopy) != StoreIdx) ||

             /* Situation 5
              *
              * StoreIndex (SI) == MessageIndex (MI)
              *
              * 0-----MI/SI-------------------------------END
              *
              */
             (Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy == Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferMsgIdx))
        {
          conflictFound = TRUE;
        }

        if (TRUE == conflictFound)
        {
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          retVal = DLT_E_NO_BUFFER;
#else
          retVal = DLT_E_IF_BUSY;
#endif
        }
        else
        {
          /* no corruption detected */
        }
      }
      Dlt_BSWMasterContextPtr->ExitExclusiveArea();

      /* We cannot continue as this would corrupt the buffer in transmission */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
      if (retVal != DLT_E_NO_BUFFER)
#else
      if (retVal != DLT_E_IF_BUSY)
#endif
      {
        /* If we reach this point, then no error has been found and we are ready for
         * transmitting the current message. Thus the store pointer can be moved to the
         * next free space in the buffer. */
        Dlt_BSWMasterContextPtr->EnterExclusiveArea();
        if (Dlt_StoreInterruptedCnt == 0)
        {
          /* Update copy of the global variable with the value of the global store index */
          Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdxCopy = Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdx;
          /* Update copy of the global variable with the value of the local store length */
          Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreLengthCopy = LocalMessageLength;
        }
        Dlt_StoreInterruptedCnt++;
        /* Update store index to the next available store location in the buffer */
        Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdx = DLT_BUFFER_IDX(Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferStoreIdx, MsgLen,BufferSize);
        Dlt_BSWMasterContextPtr->ExitExclusiveArea();

        retVal = DLT_E_OK;
      }
    }
  }

  DBG_DLT_CHECKBUFFER_EXIT(retVal, chnIdx, MsgLen, MaxMsgLen, BufferSize, StoreIdx);
  return retVal;
}


STATIC FUNC(uint8, DLT_CODE) Dlt_ComputeHeaderLength(void)
{
  uint8 LocalHeaderLength = DLT_MIN_HEADER_LENGTH;

  if (Dlt_HeaderUseEcuId != 0U)
  {
    LocalHeaderLength += DLT_ECU_HEADER_LENGTH;
  }
  if (Dlt_HeaderUseSessionID != 0U)
  {
    LocalHeaderLength += DLT_SEID_HEADER_LENGTH;
  }
#if (DLT_IMPLEMENT_TIMESTAMP != STD_OFF)
  if (Dlt_HeaderUseTimestamp != 0U)
  {
    LocalHeaderLength += DLT_TMSP_HEADER_LENGTH;
  }
#endif /* DLT_IMPLEMENT_TIMESTAMP != STD_OFF */
  if (Dlt_HeaderUseExtendedHeader != 0U)
  {
    LocalHeaderLength += DLT_EXT_HEADER_LENGTH;
  }

  return LocalHeaderLength;
}

STATIC FUNC(boolean, DLT_CODE) Dlt_ContextIdIdentified
  (
    Dlt_Internal_ContextIDType context_id,
    Dlt_AppIdTableIdxType aIdx,
    Dlt_SessionIDType session_id,
    Dlt_BSWDistributionCommonType LocalCoreContext,
    P2VAR(Dlt_ContextIdTableIdxType, AUTOMATIC, DLT_APPL_DATA) foundContextIdIdx
  )
{
  boolean ContextIdIdentified = FALSE;
  Dlt_ContextIdTableIdxType ctxid = 0U;
  Dlt_AppToContextIdTableIdxType atcIdx;

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  if (aIdx != *LocalCoreContext.MaxRegisteredAppldTableEntry)
  {
    /* Check whether the context Id is registered */
    for (atcIdx = 0U; atcIdx < LocalCoreContext.AppToContextIdTableIdx[aIdx]; atcIdx++)
    {
      if (LocalCoreContext.ContextIdTable[
        LocalCoreContext.AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx]].ContextId == context_id)
      {
        break;
      }
    }

    if (atcIdx != LocalCoreContext.AppToContextIdTableIdx[aIdx])
    {
      ctxid = LocalCoreContext.AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx];
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
  if (aIdx != Dlt_MaxRegisteredAppldTableEntry)
  {
    /* Check whether the context Id is registered */
    for (atcIdx = 0U; atcIdx < Dlt_AppToContextIdTableIdx[aIdx]; atcIdx++)
    {
      if (LocalCoreContext.ContextIdTable[
        Dlt_AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx]].ContextId == context_id)
      {
        break;
      }
    }

    if (atcIdx != Dlt_AppToContextIdTableIdx[aIdx])
    {
      ctxid = Dlt_AppToContextIdTable[aIdx].ContextIdTableIdx[atcIdx];
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

      /* If there are Session IDs, checks whether they also match sessionId of BSW-C */
      if (session_id < DLT_SWC_SESSION_ID_BASE)
      {
#if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431)
        if (LocalCoreContext.ContextIdTable[ctxid].SessionIdTableIdx == DLT_NO_SESSION_ID)
#endif /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
        {
          ContextIdIdentified = TRUE;
          *foundContextIdIdx = ctxid;
        }
      }
      /* When Autosar_42 is used, the session no is generated via a java assistant, but in the Autosar_43, the number of sessions
       * is corresponding with the no of the configured Sw-C*/
#if(DLT_SWC_SESSION_REGISTERED != 0U)
      else
      {
        /* sessionId of SWC >= DLT_SWC_SESSION_ID_BASE */
        const Dlt_SessionIDType LocalSessionIdx =
          LocalCoreContext.ContextIdTable[ctxid].SessionIdTableIdx;

        /* sessionId index must be different than DLT_NO_SESSION_ID */
        if (LocalSessionIdx != DLT_NO_SESSION_ID)
        {
          /* check that the session id used to request the send
           * is registered for the current context */
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          /* CHECK: NOPARSE */
          /* !LINKSTO Dlt.swdd.DltCore.API.SendLogMessage.SessionIDCheck,1,
                      Dlt.swdd.DltCore.API.SendTraceMessage.SessionIDCheck,1 */
          if (LocalCoreContext.SessionIdTable[LocalSessionIdx].SessionId == session_id)
          /* CHECK: PARSE */
#else /* #if (DLT_DEFAULT_ASR_RETVAL != AUTOSAR_431) */
          if (Dlt_SessionIdTable[LocalSessionIdx].SessionId == session_id)
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
          {
            ContextIdIdentified = TRUE;
            *foundContextIdIdx = ctxid;
          }
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
          /* CHECK: NOPARSE */
          else
          {
            /* Before entering this function, session_id is found within the pre-configured table.
             * In this function, app_id is verified if its registered on the session_id,
             * and for this aIdx it is checked if context_id exists.
             * If context_id exists, go on to verify session_id's value.
             * If not, return ContextIdIdentified == FALSE.
             * If session_id >= 0x1000U, retrieve the context's SessionIdTableIdx
             * and compare it with the given session_id.
             * Because session_id, app_id and context_id are validated prior to this point,
             * there is currently no way the false branch can be covered.
             */
            DLT_UNREACHABLE_CODE_ASSERT(DLT_INSTANCE_ID, DLT_INTERNAL_API_ID);
          }
          /* CHECK: PARSE */
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */
        }
      }
#endif
    }
  }
  if (ContextIdIdentified == FALSE)
  {
    *foundContextIdIdx = *LocalCoreContext.ContextIdTableIdx;
  }

  return ContextIdIdentified;
}

STATIC FUNC(void, DLT_CODE) Dlt_InitInternalBuffer(void)
{
  Dlt_ChnIdTableIdxType chnIdx;

  /* !LINKSTO Dlt.swdd.Dlt_Init.BufferIndex.Reset,1 */
  for (chnIdx = 0; chnIdx < DLT_TXPDU_NO; chnIdx++)
  {
    Dlt_InternalVarsTxRx[chnIdx].Dlt_BufferTxIdx        = 0U;
    Dlt_LastMessageLen[chnIdx]                          = 0U;
    Dlt_TxConnection[chnIdx].PositionInMessage          = 0U;
    Dlt_TxConnection[chnIdx].ConfirmedPositionInMessage = 0U;
  }
  /* Compute the length of the header according to current settings */
  Dlt_HeaderLength = Dlt_ComputeHeaderLength();

  /* If this is the first call to Dlt_Init(), we try to empty the transmit
   * buffer, in case Dlt_SendXxxMessage() has been called before. We must
   * not do this if Dlt_Init() is called for an already initialized module,
   * because this would create a parallel transmit session. */

  /* !LINKSTO SWS_Dlt_00003,1, Dlt.swdd.Dlt_Init.Transmission.Reset,1 */
  if (*Dlt_BSWMasterContextPtr->CoreContext.InitState == DLT_UNINITIALIZED)
  {
    for (chnIdx = 0; chnIdx < DLT_TXPDU_NO; chnIdx++)
    {
      if (Dlt_InternalVarsTxRx[chnIdx].Dlt_MessageInBuffer == FALSE)
      {
        /* !LINKSTO Dlt.swdd.Dlt_Init.BufferIndex.Reset,1 */
        Dlt_InternalVarsTxRx[chnIdx].Dlt_TransmissionOngoing = FALSE;
        DLT_RESET_BUFFER_IDXS(chnIdx);
      }
    }
    *Dlt_BSWMasterContextPtr->CoreContext.InitState = DLT_INITIALIZED;
  }
}

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
STATIC FUNC(void, DLT_CODE) Dlt_InternalUnregisterContextShiftAppIds(
  Dlt_AppIdTableIdxType AppIdStartIdx,
  P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) CoreContext)
{
  Dlt_AppIdTableIdxType AppIdIdx;
  Dlt_ContextIdTableIdxType ContextIdIdx;

  for (AppIdIdx = AppIdStartIdx; AppIdIdx < (*CoreContext->MaxRegisteredAppldTableEntry); AppIdIdx++)
  {
    /* Shift the applicationIds from the Dlt_AppIdTable with one position */
    if (AppIdIdx == ((*CoreContext->MaxRegisteredAppldTableEntry) - 1U))
    {
      TS_MemBZero(&CoreContext->AppIdTable[AppIdIdx], sizeof(CoreContext->AppIdTable[AppIdIdx]));
      CoreContext->AppToContextIdTableIdx[AppIdIdx] = 0U;

      for (ContextIdIdx = 0U; ContextIdIdx < DLT_MAX_COUNT_CONTEXT_IDS_PER_APP_ID; ContextIdIdx++)
      {
        CoreContext->AppToContextIdTable[AppIdIdx].ContextIdTableIdx[ContextIdIdx] = 0U;
      }
    }
#if (DLT_MAX_COUNT_APP_IDS > 1) /* If we have only one appId, there is nothing to shift */
    else
    {
      TS_MemCpy(&CoreContext->AppToContextIdTable[AppIdIdx],
          &CoreContext->AppToContextIdTable[AppIdIdx + 1U],
          sizeof(CoreContext->AppToContextIdTable[AppIdIdx]));
      TS_MemCpy(&CoreContext->AppIdTable[AppIdIdx],
          &CoreContext->AppIdTable[AppIdIdx + 1U],
          sizeof(CoreContext->AppIdTable[AppIdIdx]));
      CoreContext->AppToContextIdTableIdx[AppIdIdx] = CoreContext->AppToContextIdTableIdx[AppIdIdx + 1U];
    }
#endif /* #if (DLT_MAX_COUNT_APP_IDS > 1) */
  }
}


STATIC FUNC(void, DLT_CODE) Dlt_InternalUnregisterContextClearSessionIdTable(
    Dlt_SessionIdTableIdxType SessionIdStartIdx,
    P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) CoreContext)
{
  Dlt_ContextIdTableIdxType ContextIdIdx;

  for (ContextIdIdx = 0U; ContextIdIdx < (*CoreContext->ContextIdTableIdx); ContextIdIdx++)
  {
    if (CoreContext->ContextIdTable[ContextIdIdx].SessionIdTableIdx == SessionIdStartIdx)
    {
      break;
    }
  }

  if (ContextIdIdx == (*CoreContext->ContextIdTableIdx))
  {
    CoreContext->SessionIdTable[SessionIdStartIdx].SessionId = 0U;
  }
}
#endif

STATIC FUNC(void, DLT_CODE) Dlt_InternalRegisterContextCreateNewEntry(
    Dlt_SessionIDType session_id,
    P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) CoreContext,
    Dlt_AppIdTableIdxType aIdx,
    Dlt_Internal_ApplicationIDType app_id,
    Dlt_ContextIdTableIdxType CitIdx,
    Dlt_AppToContextIdTableIdxType ApplToCtxIdx)
{
  /* !LINKSTO SWS_Dlt_00057,1, SWS_Dlt_00021,1 */
  Dlt_BSWMasterContextPtr->EnterExclusiveArea();
#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
  if (aIdx == *CoreContext->MaxRegisteredAppldTableEntry)
  {
    CoreContext->AppIdTable[aIdx].AppId = app_id;
    CoreContext->AppIdTable[aIdx].SessionId = session_id;
    (*CoreContext->MaxRegisteredAppldTableEntry)++;
  }
  CoreContext->AppToContextIdTable[aIdx].ContextIdTableIdx[ApplToCtxIdx] = CitIdx;
  /* !LINKSTO  Dlt.ASR431.SWS_Dlt_00765,1 */
  /* a new Context was added, increase the number of entries for the app */
  CoreContext->AppToContextIdTableIdx[aIdx]++;
  /* a new Context was added to ContextIdTable,
   * increase the index of the next free entry */
#else
  if (aIdx == Dlt_MaxRegisteredAppldTableEntry)
  {
    Dlt_AppIdTable[aIdx].AppId = app_id;
    Dlt_MaxRegisteredAppldTableEntry++;
  }
  Dlt_AppToContextIdTable[aIdx].ContextIdTableIdx[ApplToCtxIdx] = CitIdx;
  /* !LINKSTO  Dlt.ASR431.SWS_Dlt_00765,1 */
  /* a new Context was added, increase the number of entries for the app */
  Dlt_AppToContextIdTableIdx[aIdx]++;
  TS_PARAM_UNUSED(session_id);
#endif
  /* a new Context was added to ContextIdTable,
   * increase the index of the next free entry */
  (*CoreContext->ContextIdTableIdx)++;
  Dlt_BSWMasterContextPtr->ExitExclusiveArea();
}

#if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431)
STATIC FUNC(void, DLT_CODE) Dlt_InternalRegisterContextStoreSessionId(
    P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) CoreContext,
    Dlt_SessionIDType session_id,
    Dlt_SessionIdTableIdxType sesIdx,
    Dlt_ContextIdTableIdxType CitIdx,
    Dlt_ContextIdTableIdxType contextIdx)
{
  uint8 chnidx = 0U;
  Dlt_BSWMasterContextPtr->EnterExclusiveArea();
  CoreContext->SessionIdTable[sesIdx].SessionId = session_id;
  CoreContext->ContextIdTable[CitIdx].SessionIdTableIdx = sesIdx;
  Dlt_BSWMasterContextPtr->ExitExclusiveArea();
  CoreContext->ContextIdTable[CitIdx].LogLevel = DltSwCContextInfoPtr[sesIdx][contextIdx].DltLoglevel;
  CoreContext->ContextIdTable[CitIdx].TraceStatus = DltSwCContextInfoPtr[sesIdx][contextIdx].DltTraceStatus;
  CoreContext->ContextIdTable[CitIdx].VerboseMode = DLT_USE_VERBOSE_MODE;
  /* Set Channels - values are taken from the configuration*/
  for (chnidx = 0; chnidx < DLT_TXPDU_NO; chnidx++)
  {
    CoreContext->ContextIdTable[CitIdx].ChannelsIdx[chnidx] = DltSwCContextInfoPtr[sesIdx][contextIdx].DltLogChannelIdx[chnidx];
  }
}

STATIC FUNC(Dlt_ReturnType, DLT_CODE) Dlt_InternalRegisterLocalContext(
    Dlt_SessionIDType session_id,
    Dlt_Internal_ApplicationIDType app_id,
    Dlt_Internal_ContextIDType context_id,
    P2VAR(Dlt_BSWDistributionCommonType, AUTOMATIC, DLT_APPL_DATA) CoreContext,
    P2CONST(uint8, DLT_CONST, DLT_CONST) AppDesc,
    uint8 AppDescLen,
    Dlt_SessionIdTableIdxType sesIdx,
    Dlt_ContextIdTableIdxType contextIdx)
{
  Dlt_AppIdTableIdxType          AppIdStartIdx     = 0U;
  Dlt_ContextIdTableIdxType      ContextIdStartIdx = 0U;
  Dlt_AppToContextIdTableIdxType AppToContextIdIdx = 0U;

  DBG_DLT_INTERNALREGISTERLOCALCONTEXT_ENTRY(session_id, app_id, context_id, CoreContext, AppDesc, AppDescLen, sesIdx, contextIdx);

  /* This will give us the entry in the AppId table if there exists one,
   * or the next free entry if there doesn't exist one already */
  Dlt_FindApplicationIDEntry(session_id, app_id, CoreContext, &AppIdStartIdx);

  /* Checks for the existence of the tuple at run-time are made before calling Dlt_InternalRegisterLocalContext() */
  (void)Dlt_CheckForRegisteredContext(context_id, AppIdStartIdx, &ContextIdStartIdx, &AppToContextIdIdx);

  /* store in the table the session Id at the same index as the one in the configuration */
  Dlt_InternalRegisterContextStoreSessionId(CoreContext, session_id, sesIdx, ContextIdStartIdx, contextIdx);

  /* We have to create a new entry */
  Dlt_InternalRegisterContextCreateNewEntry(session_id, CoreContext, AppIdStartIdx, app_id, ContextIdStartIdx, AppToContextIdIdx);

  Dlt_EnterExclusiveAreaAnyCoreContext();

  /* !LINKSTO SWS_Dlt_00347,1, Dlt.ASR431.SWS_Dlt_00766,1 */
  CoreContext->ContextIdTable[ContextIdStartIdx].ContextId = context_id;

  CoreContext->AppIdTable[AppIdStartIdx].DltAppDescription.AppDescLen = AppDescLen;

  if ((AppDesc != NULL_PTR) && (AppDescLen != 0U))
  {
    /* Register the application only if valid data are provided
     * If application description is null and length is 0, this means the application was already registered,
     * but another context id is wanted to be registered on the same application id*/
    TS_MemCpy(&CoreContext->AppIdTable[AppIdStartIdx].DltAppDescription.AppDesc[0U], AppDesc, AppDescLen);
  }

  Dlt_ExitExclusiveAreaAnyCoreContext();

  DBG_DLT_INTERNALREGISTERLOCALCONTEXT_EXIT(session_id, app_id, context_id, CoreContext, AppDesc, AppDescLen, sesIdx, contextIdx);

  return DLT_E_OK;
}
#endif /* #if (DLT_DEFAULT_ASR_RETVAL == AUTOSAR_431) */

#if (DLT_IMPLEMENT_VFB_TRACE == STD_ON)

STATIC FUNC(void, DLT_CODE) Dlt_VfbComposePayload(
    P2VAR(Dlt_MsgLengthType, AUTOMATIC, DLT_APPL_DATA) PayloadLength)
{
  /* Copy all data until the end of the buffer */
  TS_MemCpy(&Dlt_LocalTraceData[0U], &Dlt_TraceData[Dlt_TraceDataReadIdx],
      (Dlt_MsgLengthType)(DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataReadIdx));
  /* Copy the remaining data at the beginning of the buffer */
  TS_MemCpy(&Dlt_LocalTraceData[(Dlt_MsgLengthType)(DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataReadIdx)],
      &Dlt_TraceData[0U], (Dlt_MsgLengthType)((*PayloadLength + DLT_VFB_CTX_ID_PAYLOAD_LEN) -
          (DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataReadIdx)));
}

STATIC FUNC(void, DLT_CODE) Dlt_VfbComposePayloadLength(void)
{
  /* Copy all data until the end of the buffer */
  TS_MemCpy(&Dlt_LocalTraceData[0U],
      &Dlt_TraceData[Dlt_TraceDataReadIdx],
      (Dlt_MsgLengthType)(DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataReadIdx));
  /* Copy the remaining data at the beginning of the buffer */
  TS_MemCpy(&Dlt_LocalTraceData[DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataReadIdx],
      &Dlt_TraceData[0U], (Dlt_MsgLengthType)(DLT_VFB_CTX_ID_PAYLOAD_LEN - (DLT_VFB_TRACE_PAYLOAD_BUFFER_SIZE - Dlt_TraceDataReadIdx)));
}

#endif /* #if (DLT_IMPLEMENT_VFB_TRACE == STD_ON) */

#define DLT_STOP_SEC_CODE
#include <Dlt_MemMap.h>

/*==================[end of file]===========================================*/
